<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title id='sop-run-mode-tab-title'>OpsPath Studio · SOP Builder</title>
  <style>
    :root {
      --fg: #0b1220;
      --bg: #f7f9fc;
      --muted: #60708a;
      --card: #ffffff;
      --line: #e4e8f0;
      --accent: #2563eb;
      --accent-weak: #eef3ff;
      --ok: #16a34a;
      --warn: #dc2626;
      --shadow: 0 2px 10px rgba(16, 24, 40, .06), 0 1px 3px rgba(16, 24, 40, .06);
      --radius: 16px;
      --surface: #ffffff;
      --text: #0f172a;
      --line: #cfd6dd;
      --input-bg: #f6f8fa;
      --hl-bg: #F7B733;
      --hl-fg: #0f172a;
      /* --hl-fg: #ff0000; */
      --content-w: 1000px;
      --gutter: 16px;
      --grid-dot: color-mix(in srgb, var(--line) 65%, transparent);

    }

    html[data-theme="dark"] {
      --fg: #e5e7eb;
      --bg: #0b1220;
      --muted: #9aa4b2;
      --card: #0f172a;
      --line: #334155;
      /* was #233044: too low-contrast */
      --accent: #3b82f6;
      --accent-weak: rgba(59, 130, 246, .16);
      --ok: #22c55e;
      --warn: #ef4444;
      --shadow: none;
      --surface: #0f172a;
      --text: #e5ecf4;
      --input-bg: rgba(255, 255, 255, .06);
      --hl-bg: #F7B733;
      --hl-fg: #0f172a;
      /* --hl-fg: #ff0000; */

      --content-w: 1000px;
      --gutter: 16px;
      --grid-dot: color-mix(in srgb, var(--line) 45%, transparent);

    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
      color: var(--fg);
      background: var(--bg);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: saturate(1.2) blur(6px);
      background: rgba(247, 249, 252, .85);
      border-bottom: 1px solid var(--line);
    }

    /* .wrap {
      max-width: 1240px;
      margin: 0 auto;
      padding: 12px 16px;
    } */

    /* main {
      max-width: 1240px;
      margin: 16px auto 60px;
      padding: 0 16px 24px;
    } */




    /* main,
    .wrap {
      width: min(100%, var(--content-w));
      margin-inline: auto;
      padding-inline: var(--gutter);
    }

    main {
      margin: 16px auto 60px;
      padding-block-end: 24px;
    }

    .wrap {
      margin: 0 auto;
      padding-block: 12px;
    } */

    /* main {
      width: min(100%, var(--content-w));
      margin-inline: auto;
      padding-inline: var(--gutter);
    } */

    .wrap {
      width: min(100%, var(--content-w));
      margin-inline: auto;
      padding-inline: var(--gutter);
    }

    main {
      margin: 16px auto 60px;
      padding-block-end: 24px;
    }

    .wrap {
      margin: 0 auto;
      padding-block: 12px;
    }

    @media (max-width: 1439px) {

      :root,
      html[data-theme="dark"] {
        --content-w: 96vw;
        /* fill more of the screen */
        --gutter: 12px;
      }
    }

    /* ≥ 1600px */
    @media (min-width: 1600px) {

      :root,
      html[data-theme="dark"] {
        --content-w: 1320px;
        --gutter: 24px;
      }
    }

    /* ≥ 1920px */
    @media (min-width: 1920px) {

      :root,
      html[data-theme="dark"] {
        --content-w: 1440px;
        --gutter: 28px;
      }
    }

    /* ≥ 2560px (27–30") */
    @media (min-width: 2560px) {

      :root,
      html[data-theme="dark"] {
        --content-w: 1560px;
        --gutter: 36px;
      }
    }

    /* optional 4K+ */
    @media (min-width: 3200px) {

      :root,
      html[data-theme="dark"] {
        --content-w: 1680px;
        --gutter: 40px;
      }
    }


    .row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .2px;
    }

    .grow {
      flex: 1;
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button,
    .btn {
      border: 1px solid var(--line);
      background: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    .btn-accent {
      background: var(--accent);
      /* color: #fff; */
      color: var(--bg);
      border-color: transparent;

    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 4px rgba(16, 24, 40, .08);
    }

    input[type="file"] {
      font-size: 13px;
    }

    select,
    input[type="text"],
    textarea,
    input[type="number"] {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      font: inherit;
    }

    label {
      font-weight: 600;
      margin: 10px 0 6px;
      display: block;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    .hr {
      height: 1px;
      background: var(--line);
      margin: 12px 0;
    }



    .layout {
      display: flex;
      grid-template-columns: 280px 1fr 360px;
      gap: 3px;
      align-items: start;
      width: 100%;

    }

    .panel {
      background: #fff;
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }

    .panel h2 {
      font-size: 14px;
      margin: 0 0 8px;
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: calc(100vh - 220px);
      overflow: auto;
    }

    .item {
      padding: 8px;
      border: 1px solid var(--line);
      border-radius: 10px;
      cursor: pointer;
      background: #fff;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .item .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .kv {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .rowflex {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* NEW */
    .badge {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--card);
      /* follows theme */
      color: var(--muted);
    }

    .warn {
      color: var(--warn);
    }

    .success {
      color: var(--ok);
    }

    [screen="mapping"][data-mode="edit"] .graph-panel {
      height: calc(100vh - var(--topbar-h, 56px));
      min-height: 640px;
      width: 100%;
      margin: 0;
      padding: 0;
      grid-column: 1 / -1;
      /* safe if parent isn't grid */

      flex: 0 0 var(--graph-w, 600px);
      /* resizable width */
      min-width: 300px;
      max-width: calc(100% - 280px);
      /* leave room for right panel */
      overflow: hidden;
    }

    /* #rightPanel {
      flex: 1 1 auto;
      min-width: 280px;
      overflow: auto;

    } */

    #rightPanel {
      flex: 0 0 var(--right-w, 360px);
      width: var(--right-w, 360px);
      width: 33%;
      /* overflow: auto; */
    }

    /* Splitter */
    .splitter {
      width: 10px;
      align-self: stretch;
      color: var(--muted);
      /* cursor: col-resize; */
      /* background: linear-gradient(90deg, transparent 0 2px, var(--line, #cfd6dd) 2px 4px, transparent 4px 100%); */
      background-clip: padding-box;
      user-select: none;
      touch-action: none;
      flex: 0 0 6px;
      cursor: col-resize;
      display: flex;
      padding-top: 20%;
      border-radius: 6px;
      outline: none;
    }

    .splitter:focus {
      /* outline: 2px solid var(--accent, #2563eb); */
      outline-offset: -2px;
      outline: none;
      box-shadow: none;
    }

    /* Optional: nicer hover target */
    .splitter:hover {
      background-color: var(--accent-weak);
    }

    /* Hide the Preview/Edit switch when <html run-mode="guide"> */
    html[run-mode="guide"] [data-hide~="guide"] {
      display: none !important;
    }



    /* make cy container fill the panel */
    .graph-panel>* {
      width: 100%;
      height: 100%;
    }

    /* tighten page wrappers on mapping editor (use what you have) */
    .vw-shell,
    .vw-main {
      max-width: none;
      padding-inline: 8px;
    }


    .graph-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .graph-zoom button {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--card);
      /* follows theme */
      color: var(--fg);
      cursor: pointer;
    }


    .graph-svg {
      width: 100%;
      height: 520px;
      display: block;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
    }


    .graph-svg.dragging {
      cursor: grabbing;
    }



    /* .edge {
      stroke: #98a2b3;
      stroke-width: 1.2;
      fill: none;
      marker-end: url(#arrow);
    } */

    /* .edge-label {
      font-size: 11px;
      fill: #667085;
      pointer-events: none;
    } */

    .node-label {
      font-size: 12px;
      fill: #0b1220;
      pointer-events: none;
    }

    /* .link-like {
      color: var(--accent);
      text-decoration: underline;
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      font-size: 13px;
    } */

    .graph-panel:fullscreen,
    .graph-panel:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      padding: 8px;
      box-sizing: border-box;
    }



    .graph-panel:fullscreen .graph-svg,
    .graph-panel:-webkit-full-screen .graph-svg {
      height: calc(100vh - 56px);
    }

    .table {
      width: 100%;
      border-collapse: collapse;
    }

    .table th,
    .table td {
      border: 1px solid var(--line);
      padding: 6px;
      font-size: 13px;
      vertical-align: top;
    }

    .table th {
      background: #f8fafc;
      text-align: left;
    }

    .iconbtn {
      padding: 6px 8px;
    }

    .center {
      text-align: center;
    }

    .error {
      color: var(--warn);
      font-size: 12px;
      margin-top: 4px;
    }

    /* Steps list spacing */
    #stepsList {
      gap: 14px;
      margin-top: 12px;
    }

    /* Step item */
    #stepsList .item {
      padding: 14px 16px;
      border-radius: 14px;
      border: 1.5px solid var(--line);
      background: var(--card);
      /* follows theme */
      position: relative;
      transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
    }

    /* Save button is visible only in Edit mode */
    [data-mode="view"] #globalSaveBtn {
      display: none;
    }

    /* Save button: stand out when enabled, muted when disabled */
    #globalSaveBtn {
      letter-spacing: .2px;
      transition: transform .12s ease, box-shadow .2s ease, filter .15s ease;
    }

    /* Enabled: bold green, subtle glow, disk icon */
    #globalSaveBtn:not([disabled]) {
      background: linear-gradient(180deg, #16a34a, #15803d);
      color: #fff;
      border: 1px solid #0f5132;
      box-shadow: 0 6px 18px rgba(22, 163, 74, .35);
    }

    #globalSaveBtn:not([disabled]):hover {
      transform: translateY(-1px);
      filter: brightness(1.04);
      box-shadow: 0 8px 22px rgba(22, 163, 74, .45);
    }

    /* Disabled: low contrast, dashed border */
    #globalSaveBtn[disabled] {
      background: transparent;
      color: #6b7280;
      border: 1px dashed #9ca3af;
      box-shadow: none;
      cursor: not-allowed;
    }


    button[disabled],
    .btn[disabled] {
      background: var(--card);
      color: var(--muted);
      opacity: .6;
    }

    .upload {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    /* #importHtmlBtn {
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
    }

    #importHtmlBtn:hover {
      box-shadow: 0 4px 14px rgba(2, 6, 23, .08);
    } */

    #importHtmlNote {
      color: var(--muted);
    }

    /* thin, subtle divider under the step title */
    .vw-hr {
      border: 0;
      border-top: 1px solid var(--line);
      margin: 6px 0 12px;
    }

    .vw-title {
      margin: 0;
    }


    #stepsList .item:hover {
      border-color: #cfd8ea;
      box-shadow: 0 6px 18px rgba(2, 6, 23, .06);
    }

    #stepsList .item.active {
      border: 2px solid #1d4ed8;
      /* stronger blue */
      background: linear-gradient(0deg, rgba(29, 78, 216, .08), rgba(29, 78, 216, .08)), #fff;
    }

    #stepsList .item.active::before {
      content: "";
      position: absolute;
      left: -6px;
      top: 10px;
      bottom: 10px;
      width: 4px;
      border-radius: 3px;
      background: #1d4ed8;
    }

    /* make title pop a bit */
    #stepsList .item strong {
      font-weight: 700;
    }

    /* Danger (trash) buttons */
    .btn-danger {
      border: 1px solid #fca5a5;
      background: #fef2f2;
      color: #b91c1c;
    }

    .btn-danger:hover {
      background: #fee2e2;
      border-color: #fb7185;
    }

    .btn-danger:active {
      transform: translateY(1px);
      box-shadow: none;
    }


    /* dark mode */
    /* Use vars for common surfaces so dark can override cleanly */

    /* HTML labels inside nodes */
    /* HTML labels inside nodes */
    .node-fo {
      pointer-events: none;
    }

    .node-fo .label {
      font: inherit;
      line-height: 1.15;

      /* center the text both axes */
      height: 100%;
      display: flex;
      align-items: center;
      /* vertical center */
      justify-content: center;
      /* centers the text box horizontally */

      text-align: center;
      overflow-wrap: anywhere;
      /* break even single long words */
      word-break: break-word;
      /* fallback */
      white-space: normal;

      margin: 0;
      padding: 0;
    }



    select {
      background-image: none;
    }

    html[data-theme="dark"] header {
      background: rgba(10, 14, 22, .85);
      border-bottom-color: var(--line);
    }

    /* Ensure all controls actually use the vars */
    button,
    .btn,
    select,
    input[type="text"],
    textarea,
    input[type="number"],
    .panel,
    .item,
    .graph-svg,
    .table th,
    .table td {
      background: var(--card);
      color: var(--fg);
      border-color: var(--line);
    }

    /* Focus + placeholder in both themes */
    input,
    select,
    textarea {
      color: var(--fg);
    }

    input::placeholder,
    textarea::placeholder {
      color: var(--muted);
      opacity: 1;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: 2px solid var(--accent);
      border-color: transparent;
      box-shadow: 0 0 0 2px var(--accent-weak);
    }

    /* Graph: tie lines/labels to theme vars */
    /* .edge {
      stroke: var(--muted);
      stroke-width: 1.2;
      fill: none;
    } */

    .edge-label {
      fill: var(--muted);
    }

    .node-label {
      fill: var(--fg);
    }

    /* Selected list item stays readable */
    html[data-theme="dark"] #stepsList .item.active {
      background: linear-gradient(0deg, rgba(59, 130, 246, .18), rgba(59, 130, 246, .18)), var(--card);
      border-color: var(--accent);
    }

    /* === Map polish (dark + light) === */
    .graph-svg {
      /* subtle grid so spacing is readable */
      background:
        radial-gradient(circle at 1px 1px, var(--grid-dot) 1px, transparent 1px),
        radial-gradient(circle at 1px 1px, rgba(148, 163, 184, .06) 1px, transparent 1px);
      background-size: 16px 16px, 80px 80px;
      background-position: 0 0, -1px -1px;
      border-color: var(--line);
    }

    /* nodes */
    .node-rect {
      fill: var(--card);
      stroke: var(--line);
      stroke-width: 1.4;
      rx: 10;
      /* soft depth without blur stink */
      filter: drop-shadow(0 1px 0 rgba(0, 0, 0, .08));
    }

    .node-rect.current {
      stroke: var(--accent);
      stroke-width: 2;
    }

    /* labels */
    .node-label {
      font-size: 12.5px;
      /* up from 12 */
      font-weight: 600;
      fill: var(--fg);
    }

    .edge {
      stroke: var(--muted);
      stroke-width: 1;
      fill: none;
      marker-end: url(#arrow);
    }

    .edge-label {
      font-size: 11.5px;
      fill: var(--muted);
      pointer-events: none;
    }


    .hidden {
      display: none !important;
    }

    /* Segmented control */
    .seg {
      display: inline-flex;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      /* clip children to clean curves */
      background: var(--card);
      /* unify background behind buttons */
    }

    .seg-btn {
      padding: 8px 14px;
      background: transparent;
      color: var(--fg);
      border: 0;
      border-radius: 0;
      /* container owns the curves */
      line-height: 1;
    }

    /* divider line between buttons */
    .seg-btn+.seg-btn {
      box-shadow: inset 1px 0 0 var(--line);
    }

    /* default “active” look */
    .seg-btn.active {
      background: var(--accent);
      color: #fff;
      box-shadow: none;
    }

    /* automatic active states via data-mode */
    [data-mode="view"] #modeView {
      background: var(--accent);
      color: var(--bg);
      box-shadow: none;
    }

    [data-mode="edit"] #modeEdit {
      background: var(--accent);
      color: var(--bg);
      box-shadow: none;
    }

    /* Hide all by default */
    /* --- Default hidden --- */
    #vwLanding,
    #vwHeader,
    #starter,
    #vwWizard,
    #editStarter {
      display: none;
    }

    /* --- Landing screen --- */

    [screen="landing"] .vw-card--add {
      display: none;
    }

    [screen="landing"][data-mode="edit"] .vw-card--add {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    [screen="landing"] #vwLanding {
      display: block;
    }

    /* Landing + view → header text */
    [screen="landing"] #vwHeader {
      display: flex;
      justify-content: end;
    }



    /* Landing + edit → header editor */
    /* [screen="landing"][data-mode="edit"] #vwHeader {
      display: none;
    } */


    /* --- Starter screen --- */
    [screen="starter"] #starter {
      display: block;
    }

    /* Starter + view → show wizard */
    [screen="starter"][data-mode="view"] #vwWizard {
      display: block;
    }

    [screen="starter"][data-mode="view"] #editStarter {
      display: none;
    }

    /* Starter + edit → show editor */
    [screen="starter"][data-mode="edit"] #vwWizard {
      display: none;
    }

    [screen="starter"][data-mode="edit"] #editStarter {
      display: flex;
      min-height: 0;
    }

    [screen="starter"][data-mode="edit"] #sop-run-mode-title,
    [data-mode="view"] #sop-run-mode-title {
      display: block;
      cursor: pointer;
    }

    [screen="landing"][data-mode="edit"] #sop-run-mode-title {
      display: none;
    }

    [screen="starter"][data-mode="edit"] #sop-run-mode-title-input,
    [data-mode="view"] #sop-run-mode-title-input {
      display: none;
    }

    [screen="landing"][data-mode="edit"] #sop-run-mode-title-input {
      display: block;
    }



    /* optional: keyboard focus */
    .seg-btn:focus-visible {
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(96, 165, 250, .6);
    }



    /* ---- Preview landing cards (match Viewer) ---- */
    .vw-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 14px;
      margin-top: 12px;
    }

    .vw-card {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: pointer;
      text-align: left;
      background: var(--card);
      /* border: 2px solid var(--line); */
      outline: 2px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      min-height: 120px;
      box-shadow: var(--shadow);
    }

    .vw-card h3 {
      margin: 0 0 6px;
      font-size: 18px;
    }

    .vw-card p {
      margin: 0;
      color: var(--muted);
    }

    /* HOVER ONLY — all cards */
    .vw-card:hover,
    .vw-card:focus-visible {
      background: rgba(0, 0, 0, .04);
      /* border: 3px solid var(--line); */
      outline: 3px solid var(--line);
      /* border-color: var(--line-hover, #dbe3ea); */
      transition: background-color .2s ease, border-color .2s ease;
    }

    /* HOVER ONLY — “+ New” card, and only when in Edit mode */
    .vw-card--add:hover,
    .vw-card--add:focus-visible {
      /* border-style: dashed; */
      /* fewer cuts than dotted */
      /* border-width: 3px; */
      outline: 3px solid var(--line);
      /* bolder */
      /* border-color: var(--line-hover, #dbe3ea); */
      /* background: rgba(0, 0, 0, .03); */
      transition: background-color .2s ease, border-color .2s ease, border-width .2s ease;
      background: var(--card);

    }


    .vw-pill {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: var(--card);
      border: 1px solid var(--line);
      color: var(--muted);
      margin-top: 10px;
    }

    .vw-pill strong {
      color: var(--fg);
    }

    /* view-mode wizard */
    .vw-crumbs {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    /* base link style */
    .vw-crumbs a,
    .drop-zone a {
      color: var(--accent);
      text-decoration: none;

    }

    /* keep visited links the same blue */
    .vw-crumbs a:link,
    .vw-crumbs a:visited,
    .drop-zone a:link,
    .drop-zone a:visited {
      color: var(--accent);
    }

    /* underline on hover */
    .vw-crumbs a:hover,
    .drop-zone a:hover {
      text-decoration: underline;
    }

    .vw-crumbs a {
      flex: 1;
      text-align: end;
    }



    /* === Map Dialog ========================================================= */
    .dlg {
      position: fixed;
      inset: 105px auto auto 252px;
      /* adjust if you want */
      width: 720px;
      max-width: min(92vw, 920px);
      height: 520px;
      max-height: min(86vh, 720px);
      z-index: 9999;

      display: flex;
      /* flex only when not [hidden] */
      flex-direction: column;

      background: var(--card, #fff);
      color: var(--fg, #111);
      border: 1px solid var(--line, #ddd);
      border-radius: 12px;
      box-shadow: var(--shadow, 0 10px 30px rgba(0, 0, 0, .2));

      resize: both;
      /* user can drag bottom-right */
      overflow: auto;
    }

    .dlg[hidden] {
      display: none !important;
    }

    .dlg-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      cursor: move;
      user-select: none;
      background: var(--panel, rgba(0, 0, 0, .03));
      border-bottom: 1px solid var(--line, #eee);
    }

    .btn-sm {
      font: 500 12px/1 system-ui, Arial;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--line, #ddd);
      background: var(--card, #fff);
      color: var(--fg, #111);
      cursor: pointer;
    }

    .btn-sm:hover {
      border-color: var(--accent, #4f8cff);
    }

    .dlg-x {
      border: 1px solid var(--line, #ddd);
      border-radius: 8px;
      background: var(--card, #fff);
      padding: 4px 8px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      color: var(--fg, #111);
    }

    .dlg-body {
      flex: 1;
      min-height: 0;
      display: flex;
    }

    /* === Mini Viewport (centered + scroll + dotted background) ============= */
    .mini-viewport {
      flex: 1;
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;

      /* dotted grid */
      /* --mini-grid-size: 16px; */
      /* JS can update this if you want zoom-aware dots */
      /* --mini-dot: rgba(0, 0, 0, .15); */
      background-image: radial-gradient(var(--mini-dot) 1px, transparent 1px);
      background-size: var(--mini-grid-size) var(--mini-grid-size);
    }

    :root.dark .mini-viewport {
      --mini-dot: rgba(255, 255, 255, .12);
    }

    #vwMiniGraph {
      width: 100%;
      height: 100%;
      max-width: 1400px;
      max-height: 1000px;
    }

    /*
    .graph-svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .edge {
      stroke: var(--graph-edge, #98a2b3);
      stroke-width: 1.5;
      fill: none;
    }

    .node-rect {
      fill: var(--card, #fff);
      stroke: var(--line, #cfcfcf);
      stroke-width: 1.5;
      rx: 8;
    }

    .node-rect.current {
      stroke: var(--accent, #4f8cff);
      stroke-width: 2;
    }

    .node-label {
      font: 600 13px/1.2 system-ui, Segoe UI, Roboto, Arial;
      fill: var(--fg, #111);
      text-anchor: middle;
      dominant-baseline: middle;
    }

    .is-mini .edge {
      stroke-width: 1.1;
    }

    .mini-node-rect {
      fill: var(--card, #fff);
      stroke: var(--line, #cfcfcf);
      stroke-width: 1.1;
      rx: 8;
    }

    .mini-node-rect.current {
      stroke: var(--accent, #4f8cff);
      stroke-width: 1.6;
    }

    .mini-label {
      font: 600 12px/1.2 system-ui, Segoe UI, Roboto, Arial;
      fill: var(--fg, #111);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .mini-node {
      cursor: pointer;
    } */



    #vwStep {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
    }

    #vwStep h3 {
      margin: 0 0 8px;
    }

    #vwStep ul {
      margin: 8px 0 0 20px;
    }

    #vwStep p,
    #f_body p {
      margin: 0px 0 0;
    }

    .vw-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      gap: 10px;
    }

    .vw-grid-sel {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
    }

    .vw-option {
      display: block;
      width: 100%;
      text-align: left;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
    }

    .vw-option.selected {
      outline: 2px solid var(--accent);
      color: var(--accent);
    }

    .thumb {
      display: block;
      width: 66%;
      margin: 12px auto 0;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--card);
    }



    /* Simple confirm modal */
    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .45);
      z-index: 9999
    }

    .modal.hidden {
      display: none
    }

    .modal-card {
      min-width: 320px;
      max-width: 520px;
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 16px
    }

    .modal-title {
      margin: 0 0 8px
    }

    .modal-text {
      margin: 0 0 12px;
      color: var(--muted)
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end
    }

    .vw-card--add {
      display: flex;
      flex-direction: column;
      justify-content: center;
      /* border: 2px dashed var(--line, #3a4353); */
      outline: 2px dashed var(--line, #3a4353);
      background: transparent;
      color: var(--muted, #9aa4b2);
    }

    /* .vw-card--add:hover {
      border-style: solid;
    } */

    .vw-card--add-icon {
      font-size: 2.2rem;
      line-height: 1;
    }



    /* overlay (uses same pattern as confirm modal) */
    #dlgNewStarter.hidden {
      display: none;
    }

    #dlgNewStarter {
      position: fixed;
      inset: 0;
      z-index: 1000;
      padding: 4vh 16px;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, .45);
      /* fades correctly in light/dark */
    }

    #dlgNewStarter .vw-dialog__panel {
      width: min(560px, 92vw);
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, .35);
    }



    /* REPLACE your inputs/textarea rules */
    #dlgNewStarter .vw-field {
      display: grid;
      gap: 6px;
      margin: 12px 0;
    }

    #dlgNewStarter input,
    #dlgNewStarter textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: transparent;
      /* respects dark & light */
      color: var(--fg);
    }

    #dlgNewStarter input::placeholder,
    #dlgNewStarter textarea::placeholder {
      color: var(--muted);
    }

    .rt-sep {
      width: 1px;
      height: 22px;
      background: var(--line);
      margin: 0 4px;
      align-self: center;
    }



    /* Wrapper with shared border/radius; toolbar on top, editor below */
    .rt-wrap {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: var(--card);
      color: var(--fg);
      position: relative;
    }

    /* Toolbar */
    .rt-toolbar {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      padding: 6px;
      border-bottom: 1px solid var(--line);
    }

    .push-right {
      margin-left: auto;
    }


    .rt-toolbar .rt-fs {
      width: auto;
      min-width: 64px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: var(--card);
      color: var(--fg);
      font: inherit;
      padding: 4px 6px;
    }




    /* Buttons */
    .rt-btn {
      padding: 4px 8px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: var(--card);
      color: var(--fg);
      font: inherit;
      font-size: larger;
      cursor: pointer;
    }

    /* keep your existing hover */
    .rt-btn:hover {
      background-color: var(--input-bg);
    }

    /* improved disabled state */
    .rt-btn:disabled,
    .rt-btn[disabled] {
      opacity: .5;
      cursor: not-allowed;
      /* was: default */
    }

    /* kill hover when disabled */
    .rt-btn:disabled:hover,
    .rt-btn[disabled]:hover {
      background-color: inherit;
      /* no hover bg when disabled */
    }


    /* Editor (same look/feel as your fields) */
    .rt-editor {
      display: block;
      width: 100%;
      min-height: 110px;
      padding: 10px;
      border: 0;
      /* border comes from .rt-wrap */
      border-radius: 0 0 10px 10px;
      /* rounded bottom only */
      background: var(--card);
      color: var(--fg);
      font: inherit;
      line-height: 1.5;
      overflow: auto;
    }

    .rt-editor,
    .rt-editor p,
    .rt-editor li,
    .rt-editor blockquote {
      line-height: 1.2;
    }

    /* Make inline highlights not add extra vertical space */
    .rt-editor [style*="background-color"]:not([style*="transparent"]) {
      line-height: 1.2;
      display: inline;
      /* keep it inline, not inline-block */
      background-clip: padding-box;
    }

    .rt-editor:focus {
      outline: none;
      border-color: var(--line-strong, var(--line));
      box-shadow: 0 0 0 2px var(--focus-ring, transparent);
    }

    .rt-editor img {
      max-width: 100%;
      height: auto;
    }



    /* .rt-editor p {
      margin: 0 0 .5rem;
    } */




    /* Focus state consistent with your fields */
    /* .rt-editor:focus {
      outline: none;
      border-color: var(--line-strong, var(--line));
      box-shadow: 0 0 0 2px var(--focus-ring, transparent);
    } */

    /* Make pasted images/text behave nicely */
    /* .rt-editor img {
      max-width: 100%;
      height: auto;
    } */

    /* .rt-editor p {
      margin: 0 0 .5rem;
    } */

    .rt-editor:empty:before {
      content: attr(data-placeholder);
      color: var(--muted);
    }

    /* highlight FG marker — uses your root var */
    .rt-editor .hl-fg {
      color: var(--hl-fg) !important;
    }

    .embed-chip {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      padding: 2px 6px;
      border-radius: 6px;
      background: var(--input-bg);
      border: 1px solid var(--muted);
    }

    .embed-chip .embed-del {
      all: unset;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
      opacity: .8;
    }

    .embed-chip .embed-del:hover {
      opacity: 1;
    }



    /* ADD: invalid state + focus */
    #dlgNewStarter input.is-invalid {
      border-color: var(--warn);
    }

    #dlgNewStarter input.is-invalid+.vw-error {
      display: block;
    }

    .vw-error {
      display: none;
      color: var(--warn);
      font-size: .875rem;
      margin-top: 4px;
      margin-bottom: 0px;
    }

    #dlgNewStarter input:focus,
    #dlgNewStarter textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak);
    }

    #dlgNewStarter .vw-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    /* Same overlay + panel behavior as New */
    #dlgImport.hidden {
      display: none;
    }

    #dlgImport {
      position: fixed;
      inset: 0;
      z-index: 1000;
      padding: 4vh 16px;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, .45);
    }

    #dlgImport .vw-dialog__panel {
      width: min(var(--content-w)*0.85);
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, .35);
    }

    /* Fields & inputs (identical look to New) */
    #dlgImport .vw-field {
      display: grid;
      gap: 6px;
      margin: 12px 0;
    }

    #dlgImport input,
    #dlgImport textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: transparent;
      color: var(--fg);
    }

    #dlgImport input::placeholder,
    #dlgImport textarea::placeholder {
      color: var(--muted);
    }

    #dlgImport input:focus,
    #dlgImport textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak);
    }

    #dlgImport .vw-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    #dlgImport input.is-invalid {
      border-color: var(--warn);
    }

    #dlgImport input.is-invalid+.vw-error {
      display: block;
    }

    /* Import dialog: drop-zone size */
    #dlgImport .drop-zone {
      border: 2px dashed var(--line);
      border-radius: 10px;
      padding: 20px;
      min-height: 30vh;
      /* bigger drop area */
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      text-align: center;
      background: transparent;
      /* color: var(--fg); */
      color: color-mix(in srgb, var(--fg) 50%, transparent);
    }

    #dlgImport .drop-zone.drag {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak) inset;
      background-color: var(--accent-weak);
    }

    /* Normal text (not bold) */
    #dlgImport .drop-zone .dz-text,
    .drop-zone a {
      font-weight: 400;
      font-size: medium;
    }

    /* centered horizontal separator with "or" */
    #dlgImport .vw-sep {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 12px 0;
      color: var(--muted);
      user-select: none;
    }

    #dlgImport .vw-sep::before,
    #dlgImport .vw-sep::after {
      content: "";
      flex: 1 1 auto;
      height: 1px;
      background: var(--line);
    }

    #dlgImport .vw-sep>span {
      line-height: 1;
      padding: 0 6px;
    }

    /* colorize the icon */
    #dlgImport .drop-zone .dz-icon {
      color: var(--accent);
      /* turns the SVG blue */
    }





    /* Confirm dialog — uses your CSS vars */
    .cfm-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      background: rgba(0, 0, 0, .45);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cfm-panel {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: min(420px, 92vw);
      padding: 18px;
      font: inherit;
    }

    .cfm-title {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .cfm-msg {
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .cfm-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .cfm-btn {
      padding: 8px 12px;
      border-radius: 8px;
      font: inherit;
      border: 1px solid var(--line);
      cursor: pointer;
    }

    .cfm-btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    /* Cancel: flat, simple */
    .cfm-btn--cancel {
      background: var(--input-bg);
      color: var(--text);
    }

    /* {
      filter: brightness(0.98);
    } */

    /* OK: primary or danger, no gradients */
    .cfm-btn--ok {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .cfm-btn--ok:hover,
    .cfm-btn--cancel:hover {
      filter: brightness(1.5);
    }

    .cfm-btn--danger {
      background: var(--warn);
      border-color: var(--warn);
    }

    .cfm-btn--neutral {
      background: var(--input-bg);
      color: var(--text);
      border-color: var(--line);
    }

    .cfm-btn--neutral:hover {
      filter: brightness(2.5);
    }

    /* Subtle danger (calm, but distinct) */
    .cfm-btn--subtleDanger {
      background: var(--input-bg);
      color: var(--warn);
      border-color: var(--line);
    }

    .cfm-btn--subtleDanger:hover {
      border-color: var(--warn);
    }

    /* Settings menu */
    .settings-overlay {
      position: fixed;
      inset: 0;
      z-index: 9998;
      background: transparent;
      /* click-outside catcher */
    }

    /* Default (view): hide edit cards */
    html[data-mode="view"] .vw-card--edit {
      display: none;
    }

    /* Edit: hide read-only cards, show edit cards */
    html[data-mode="edit"] .vw-card {
      display: none;
    }

    html[data-mode="edit"] .vw-card--edit {
      display: block;
    }


    /* Starter card — inline edit */
    .vw-card--edit input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--card);
      color: var(--fg);
    }

    .vw-card--edit input+input {
      margin-top: 8px;
    }

    .vw-card__meta {
      margin-top: 10px;
    }

    .vw-card__actions {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-top: 10px;
    }


    .settings-panel {
      position: absolute;
      z-index: 9999;
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      width: 150px;
      /* smaller fixed width */
      max-width: 92vw;
      /* keep mobile-safe */
      min-width: 0;
      padding: 6px;
    }

    /* Variables menu row layout + wrapping for long IDs */
    .settings-panel .settings-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
    }

    .settings-panel .settings-item .var-id {
      flex: 1 1 auto;
      min-width: 0;
      /* allow flexbox to shrink the field */
      overflow-wrap: anywhere;
      /* break even single long tokens */
      word-break: break-word;
      /* fallback for older engines */
    }

    .settings-panel .settings-item .var-type {
      flex: 0 0 auto;
      white-space: nowrap;
      /* keep “(input)” / “(select)” on one line */
      opacity: .7;
    }


    /* Let the two variants participate in the grid like normal cards */
    .starter-dual {
      display: contents;
      /* children become the grid items */
    }


    .settings-item {
      width: 100%;
      text-align: left;
      border: 0;
      background: transparent;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
    }

    .settings-item:hover {
      background: var(--input-bg);
    }

    /* wrapper to anchor floating controls inside the graph area */
    .graph-canvas {
      position: relative;
    }

    /* top-centered buttons INSIDE the graph */
    .graph-canvas .graph-fabs--top {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 6;
      pointer-events: none;
      /* let graph drag/pan pass through */
    }

    .graph-canvas .graph-action {
      /* but keep buttons clickable */
      pointer-events: auto;
    }

    .graph-canvas .graph-action[disabled] {
      cursor: not-allowed;
    }

    /* Make the 'Required' checkbox bigger + aligned */
    .kv div:has(#f_req) {
      display: flex;
      align-items: end;
      gap: 0.4rem;
    }

    /* center it vertically */
    #f_req {
      transform: scale(1.5);
      /* tweak 1.9–2.3 to match your input height */
      transform-origin: bottom;
      accent-color: var(--accent);
      /* theme color when checked */
      margin: 4px;
      outline: none;
      box-shadow: none;
      /* small breathing room */
    }



    /* #editStarter.layout {
      display: flex;
      width: 100%;
      min-width: 0;
    } */

    #graphPanel {
      /* left pane */
      flex: 1 1 auto;
      min-width: 260px;
      /* floor so right can expand into the left */
      min-inline-size: 0;
      /* avoid hidden min-content floor */
    }



    /* #rightPanel {
      flex: 0 0 var(--right-w, 360px);
      width: var(--right-w, 360px);
      min-width: 180px;
      overflow: auto;
    } */

    /* .img-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    } */

    /* .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 42px;
      height: 42px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: var(--card);
      color: var(--fg);
      cursor: pointer;
    } */

    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 42px;
      height: 42px;
      padding: 0;
      /* keep the icon perfectly centered/square */
      line-height: 0;
      /* kills baseline gap */
      border: 1px solid var(--line);
      border-radius: 8px;
      background: var(--card);
      color: var(--fg);
      cursor: pointer;
    }

    .icon-btn:hover {
      /* filter: brightness(1.05); */
      background-color: var(--input-bg);
    }

    .icon-btn.danger {
      color: var(--danger, #b00020);
    }

    .thumb.mini {
      width: 42px;
      height: 42px;
      object-fit: cover;
      border: 1px solid var(--line);
      border-radius: 6px;
      margin: 0px;
      cursor: pointer;
    }

    .file-name {
      max-inline-size: 40ch;
      /* wrap nicely */
      word-wrap: break-word;
      overflow-wrap: anywhere;
      color: var(--fg-muted, var(--fg));
      font-size: 0.9em;
    }

    /* highlight palette dropdown */
    .hl-menu {
      position: absolute;
      min-width: 220px;
      z-index: 1000;
      background: var(--c-bg-2, #222);
      color: var(--c-fg, #fff);
      border: 1px solid var(--c-bd, #444);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
      padding: 8px;
    }

    .hl-row {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      margin-bottom: 8px;
    }

    .hl-swatch {
      width: 28px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid rgba(0, 0, 0, .25);
      cursor: pointer;
    }

    .hl-actions {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
    }

    .hl-clear {
      background: transparent;
      color: inherit;
      border: 1px solid var(--c-bd, #444);
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
    }

    .hl-clear:hover {
      background: var(--input-bg);
    }


    .icon-btn svg {
      display: block;
      /* prevents vertical extra space */
      width: 18px;
      height: 18px;
    }

    /* your row can stay flex without scroll */
    .img-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      width: 100%;
      overflow-x: hidden;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 0.3rem;
    }

    .icon-btn.danger {
      color: #FA5252;
    }

    /* anchor look inside editor */
    /* .rt-editor a {
      color: var(--accent);
      text-decoration: none;
      cursor: pointer;
    }

    .rt-editor a:hover {
      text-decoration: underline;
    } */

    /* link popup */
    .rt-link-pop {
      position: absolute;
      z-index: 10;
      min-width: 280px;
      padding: 10px;
      border-radius: 10px;
      background: var(--card);
      box-shadow: var(--shadow);
      border: 1px solid var(--line);
    }

    .rt-link-pop label {
      /* display: grid; */
      grid-template-columns: 56px 1fr;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .rt-link-pop input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--input-bg);
      color: var(--text);
    }

    .rt-link-pop .row {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: nowrap;
    }

    #rt-embed-pop textarea {
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }


    .clickable-link {
      color: var(--accent);
      text-decoration: underline;
      text-decoration-thickness: 1.5px;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 2px;
    }

    .clickable-link:hover,
    .clickable-link:focus {
      text-decoration: underline;

      text-decoration-thickness: 2px;

    }

    .clickable-link::after {
      content: "↗";
      margin-inline-start: .25em;
    }

    /* Attachment chip */
    a.downloadable-chip {
      display: inline-flex;
      align-items: baseline;
      gap: .5rem;
      padding: .35rem .6rem;
      border-radius: 999px;
      /* line-height: 1; */
      text-decoration: none;
      white-space: nowrap;
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
    }

    a.downloadable-chip .icon {
      font-size: 1em;
      opacity: .85;
    }

    a.downloadable-chip .name {
      max-width: 24ch;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
    }

    a.downloadable-chip .size {
      font-size: .85em;
      opacity: .75;
    }

    a.downloadable-chip:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, .12);
      background: var(--input-bg);
    }

    @media (prefers-reduced-motion: no-preference) {
      a.downloadable-chip {
        transition: transform 120ms ease;
      }
    }

    /* Image lightbox */
    /* .imglb-overlay {
      position: fixed;
      inset: 0;
      background: color-mix(in srgb, var(--bg) 30%, #000 40%);
      display: grid;
      place-items: center;
      opacity: 0;
      transform: scale(0.98);
      transition: opacity 140ms ease, transform 140ms ease;
      z-index: 1000;
    }

    .imglb-overlay.open {
      opacity: 1;
      transform: scale(1);
    } */

    .imglb-panel {
      max-width: 90vw;
      max-height: 90vh;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .3);
      border: 1px solid var(--line);
      background: var(--card);
      border-radius: 12px;
      overflow: hidden;
    }

    .imglb-panel img {
      display: block;
      max-width: 50vw;
      max-height: 50vh;
    }

    /* Visually hidden (for the label) */
    .vh {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Viewer-only: search bar row */
    .vw-search {
      display: flex;
      justify-content: flex-end;
      align-items: baseline;
      gap: .5rem;
      margin: 8px 0 12px;
    }

    /* The field */
    #vwSearchInput {
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: var(--card);
      color: var(--fg);
      font: inherit;
      width: min(100%, 50vw);
      outline: none;

    }

    /* Focus ring that works in light/dark */
    #vwSearchInput:focus-visible {
      /* box-shadow: 0 0 0 2px var(--accent); */
      box-shadow: 0 0 0 1px var(--accent-weak);
      border-color: var(--accent);
    }




    /* @media (prefers-reduced-motion: reduce) {
      .imglb-overlay {
        transition: none;
      }
    } */

    p.search-place {
      color: var(--hl-bg);
      text-align: right;
      font-style: italic;
    }
  </style>



  <link rel="icon" type="image/svg+xml" href='
data:image/svg+xml;utf8,
<svg 
version="1.1" xmlns="http://www.w3.org/2000/svg" width="512" height="512"><path d="M0 0 C1.33241226 -0.01007584 1.33241226 -0.01007584 2.69174194 -0.02035522 C5.62804763 -0.03935224 8.56412496 -0.04326028 11.50048828 -0.04541016 C13.54306126 -0.05183686 15.58563331 -0.05856513 17.62820435 -0.06558228 C21.91036107 -0.07755928 26.19243709 -0.08126266 30.47460938 -0.08007812 C35.95806313 -0.07987491 41.44099879 -0.10717841 46.92432976 -0.14162254 C51.14342621 -0.16387476 55.36239765 -0.16791618 59.58154678 -0.16685867 C61.60293488 -0.1692171 63.6243263 -0.17805423 65.64565659 -0.19352341 C68.47507621 -0.21314933 71.30337429 -0.20735865 74.1328125 -0.1953125 C74.96522461 -0.20655151 75.79763672 -0.21779053 76.65527344 -0.22937012 C81.95825332 -0.1720841 85.00706613 0.74509173 89.19580078 4.29052734 C90.69696012 6.63372965 91.86485333 8.72626895 93.00830078 11.22802734 C93.4965332 12.24920654 93.4965332 12.24920654 93.99462891 13.29101562 C97.68961117 21.12626393 101.12342403 29.09071621 104.50830078 37.06396484 C104.83443359 37.83144043 105.16056641 38.59891602 105.49658203 39.38964844 C106.19580078 41.29052734 106.19580078 41.29052734 106.19580078 43.29052734 C107.45908203 43.52642578 108.72236328 43.76232422 110.02392578 44.00537109 C115.65496148 45.25658987 120.70528585 47.48694606 125.94580078 49.85302734 C127.77191886 50.67132289 129.59998698 51.48528355 131.43017578 52.29443359 C132.62465332 52.8330603 132.62465332 52.8330603 133.84326172 53.38256836 C139.65232431 55.6245675 142.90421461 55.00425251 148.55126953 52.54443359 C149.99325025 51.94854514 151.43531012 51.35284819 152.87744141 50.75732422 C155.12633566 49.81027981 157.37265694 48.85757038 159.61694336 47.8996582 C177.06119054 40.49831058 177.06119054 40.49831058 184.19580078 42.29052734 C188.59384234 44.57087049 191.8897453 47.70027242 195.34716797 51.18310547 C195.94125961 51.77369247 196.53535126 52.36427948 197.14744568 52.97276306 C199.10090189 54.91744869 201.04698914 56.86932045 202.99267578 58.82177734 C204.35047664 60.17823058 205.70857425 61.53438683 207.06695557 62.89025879 C209.90792732 65.72828592 212.74525966 68.56988942 215.58007812 71.4140625 C219.21734312 75.06274332 222.86354179 78.70234346 226.51249313 82.33933258 C229.31615718 85.13577879 232.11505157 87.93695964 234.91251373 90.73960876 C236.25549685 92.08392746 237.59997112 93.42675816 238.94594574 94.76808167 C240.82284418 96.63991385 242.6932333 98.51801496 244.56201172 100.39794922 C245.12095627 100.95284531 245.67990082 101.50774139 246.25578308 102.07945251 C249.84236152 105.70589408 251.34284491 108.35574093 251.66845703 113.42724609 C251.5877321 121.51001286 247.75254139 128.7949781 244.63330078 136.10302734 C243.68676688 138.33474555 242.74583253 140.56813423 241.8205719 142.8087616 C241.24802669 144.19425438 240.66324007 145.57477115 240.06455994 146.94917297 C237.96885611 152.00463336 238.18573915 154.67343839 240.10375977 159.64306641 C240.46284424 160.43938477 240.82192871 161.23570312 241.19189453 162.05615234 C241.58570313 162.94689453 241.97951172 163.83763672 242.38525391 164.75537109 C243.21080192 166.59767386 244.03888779 168.43884169 244.86962891 170.27880859 C246.80982891 174.67828332 248.30743851 178.49133423 248.91845703 183.27490234 C249.27528275 185.47053307 249.27528275 185.47053307 250.19580078 187.29052734 C252.22023734 188.54677198 254.08529098 189.01170983 256.40087891 189.56835938 C262.15901247 191.056179 267.52471839 193.81702591 272.94580078 196.22802734 C274.15107422 196.75332031 275.35634766 197.27861328 276.59814453 197.81982422 C277.75958984 198.33480469 278.92103516 198.84978516 280.11767578 199.38037109 C281.16536133 199.84306396 282.21304687 200.30575684 283.29248047 200.7824707 C287.79166331 203.11945796 291.42924384 205.41850885 293.19580078 210.29052734 C293.39744604 213.25634414 293.48954215 216.12861145 293.48632812 219.09472656 C293.49640396 220.42713882 293.49640396 220.42713882 293.50668335 221.78646851 C293.52568037 224.7227742 293.5295884 227.65885152 293.53173828 230.59521484 C293.53816499 232.63778782 293.54489325 234.68035987 293.5519104 236.72293091 C293.5638874 241.00508763 293.56759078 245.28716365 293.56640625 249.56933594 C293.56620303 255.05278969 293.59350654 260.53572535 293.62795067 266.01905632 C293.65020289 270.23815278 293.6542443 274.45712421 293.6531868 278.67627335 C293.65554523 280.69766145 293.66438236 282.71905286 293.67985153 284.74038315 C293.69947746 287.56980277 293.69368677 290.39810085 293.68164062 293.22753906 C293.69287964 294.05995117 293.70411865 294.89236328 293.71569824 295.75 C293.65841222 301.05297988 292.74123639 304.1017927 289.19580078 308.29052734 C286.85259848 309.79168669 284.76005918 310.95957989 282.25830078 312.10302734 C281.23712158 312.59125977 281.23712158 312.59125977 280.1953125 313.08935547 C272.3600642 316.78433773 264.39561192 320.21815059 256.42236328 323.60302734 C255.6548877 323.92916016 254.88741211 324.25529297 254.09667969 324.59130859 C252.19580078 325.29052734 252.19580078 325.29052734 250.19580078 325.29052734 C249.95990234 326.55380859 249.72400391 327.81708984 249.48095703 329.11865234 C248.22973825 334.74968804 245.99938206 339.80001241 243.63330078 345.04052734 C242.81500523 346.86664542 242.00104457 348.69471354 241.19189453 350.52490234 C240.65326782 351.71937988 240.65326782 351.71937988 240.10375977 352.93798828 C237.86176062 358.74705087 238.48207562 361.99894117 240.94189453 367.64599609 C241.53778298 369.08797681 242.13347994 370.53003668 242.72900391 371.97216797 C243.67604831 374.22106222 244.62875775 376.4673835 245.58666992 378.71166992 C252.98801755 396.15591711 252.98801755 396.15591711 251.19580078 403.29052734 C248.91545764 407.6885689 245.7860557 410.98447186 242.30322266 414.44189453 C241.41734215 415.333032 241.41734215 415.333032 240.51356506 416.24217224 C238.56887943 418.19562845 236.61700767 420.1417157 234.66455078 422.08740234 C233.30809755 423.44520321 231.95194129 424.80330081 230.59606934 426.16168213 C227.75804221 429.00265388 224.9164387 431.83998623 222.07226562 434.67480469 C218.42358481 438.31206968 214.78398467 441.95826835 211.14699554 445.6072197 C208.35054934 448.41088375 205.54936849 451.20977813 202.74671936 454.0072403 C201.40240067 455.35022341 200.05956996 456.69469769 198.71824646 458.0406723 C196.84641427 459.91757075 194.96831316 461.78795986 193.08837891 463.65673828 C192.53348282 464.21568283 191.97858673 464.77462738 191.40687561 465.35050964 C187.78043404 468.93708808 185.13058719 470.43757148 180.05908203 470.76318359 C171.97631526 470.68245867 164.69135002 466.84726795 157.38330078 463.72802734 C155.15158258 462.78149344 152.9181939 461.84055909 150.67756653 460.91529846 C149.29207375 460.34275326 147.91155697 459.75796663 146.53715515 459.1592865 C141.48169476 457.06358267 138.81288974 457.28046572 133.84326172 459.19848633 C133.04694336 459.5575708 132.250625 459.91665527 131.43017578 460.28662109 C130.53943359 460.68042969 129.64869141 461.07423828 128.73095703 461.47998047 C126.88865427 462.30552848 125.04748643 463.13361435 123.20751953 463.96435547 C118.8080448 465.90455547 114.9949939 467.40216508 110.21142578 468.01318359 C108.01579506 468.37000931 108.01579506 468.37000931 106.19580078 469.29052734 C104.93955615 471.31496391 104.47461829 473.18001754 103.91796875 475.49560547 C102.43014912 481.25373903 99.66930221 486.61944496 97.25830078 492.04052734 C96.73300781 493.24580078 96.20771484 494.45107422 95.66650391 495.69287109 C95.15152344 496.85431641 94.63654297 498.01576172 94.10595703 499.21240234 C93.64326416 500.26008789 93.18057129 501.30777344 92.70385742 502.38720703 C90.36687017 506.88638987 88.06781927 510.5239704 83.19580078 512.29052734 C80.22998399 512.4921726 77.35771667 512.58426871 74.39160156 512.58105469 C73.0591893 512.59113052 73.0591893 512.59113052 71.69985962 512.60140991 C68.76355393 512.62040693 65.8274766 512.62431496 62.89111328 512.62646484 C60.8485403 512.63289155 58.80596825 512.63961981 56.76339722 512.64663696 C52.4812405 512.65861397 48.19916448 512.66231734 43.91699219 512.66113281 C38.43353843 512.66092959 32.95060278 512.6882331 27.4672718 512.72267723 C23.24817535 512.74492945 19.02920391 512.74897087 14.81005478 512.74791336 C12.78866668 512.75027179 10.76727526 512.75910892 8.74594498 512.77457809 C5.91652535 512.79420402 3.08822727 512.78841333 0.25878906 512.77636719 C-0.57362305 512.7876062 -1.40603516 512.79884521 -2.26367188 512.8104248 C-7.56665175 512.75313879 -10.61546457 511.83596296 -14.80419922 508.29052734 C-16.30535856 505.94732504 -17.47325177 503.85478574 -18.61669922 501.35302734 C-18.9421875 500.67224121 -19.26767578 499.99145508 -19.60302734 499.29003906 C-23.29800961 491.45479076 -26.73182247 483.49033848 -30.11669922 475.51708984 C-30.44283203 474.74961426 -30.76896484 473.98213867 -31.10498047 473.19140625 C-31.80419922 471.29052734 -31.80419922 471.29052734 -31.80419922 469.29052734 C-33.06748047 469.05462891 -34.33076172 468.81873047 -35.63232422 468.57568359 C-41.26335992 467.32446482 -46.31368428 465.09410862 -51.55419922 462.72802734 C-53.3803173 461.90973179 -55.20838542 461.09577114 -57.03857422 460.28662109 C-58.23305176 459.74799438 -58.23305176 459.74799438 -59.45166016 459.19848633 C-65.26072274 456.95648718 -68.51261305 457.57680218 -74.15966797 460.03662109 C-75.60164869 460.63250955 -77.04370856 461.2282065 -78.48583984 461.82373047 C-80.73473409 462.77077488 -82.98105537 463.72348431 -85.2253418 464.68139648 C-102.66958898 472.08274411 -102.66958898 472.08274411 -109.80419922 470.29052734 C-114.20224078 468.0101842 -117.49814373 464.88078226 -120.95556641 461.39794922 C-121.54965805 460.80736221 -122.14374969 460.21677521 -122.75584412 459.60829163 C-124.70930032 457.66360599 -126.65538757 455.71173424 -128.60107422 453.75927734 C-129.95887508 452.40282411 -131.31697269 451.04666785 -132.675354 449.6907959 C-135.51632576 446.85276877 -138.3536581 444.01116527 -141.18847656 441.16699219 C-144.82574156 437.51831137 -148.47194022 433.87871123 -152.12089157 430.24172211 C-154.92455562 427.4452759 -157.72345 424.64409505 -160.52091217 421.84144592 C-161.86389529 420.49712723 -163.20836956 419.15429653 -164.55434418 417.81297302 C-166.43124262 415.94114083 -168.30163174 414.06303972 -170.17041016 412.18310547 C-170.72935471 411.62820938 -171.28829926 411.07331329 -171.86418152 410.50160217 C-175.45075996 406.8751606 -176.95124335 404.22531376 -177.27685547 399.15380859 C-177.19613054 391.07104183 -173.36093982 383.78607658 -170.24169922 376.47802734 C-169.29516532 374.24630914 -168.35423097 372.01292046 -167.42897034 369.77229309 C-166.85642513 368.38680031 -166.27163851 367.00628353 -165.67295837 365.63188171 C-163.57725455 360.57642133 -163.79413759 357.9076163 -165.7121582 352.93798828 C-166.07124268 352.14166992 -166.43032715 351.34535156 -166.80029297 350.52490234 C-167.19410156 349.63416016 -167.58791016 348.74341797 -167.99365234 347.82568359 C-168.81920036 345.98338083 -169.64728623 344.14221299 -170.47802734 342.30224609 C-172.41822735 337.90277137 -173.91583695 334.08972046 -174.52685547 329.30615234 C-174.88368118 327.11052162 -174.88368118 327.11052162 -175.80419922 325.29052734 C-177.82863578 324.03428271 -179.69368941 323.56934485 -182.00927734 323.01269531 C-187.76741091 321.52487569 -193.13311683 318.76402877 -198.55419922 316.35302734 C-199.75947266 315.82773437 -200.96474609 315.30244141 -202.20654297 314.76123047 C-203.36798828 314.24625 -204.52943359 313.73126953 -205.72607422 313.20068359 C-206.77375977 312.73799072 -207.82144531 312.27529785 -208.90087891 311.79858398 C-213.40006175 309.46159673 -217.03764228 307.16254584 -218.80419922 302.29052734 C-219.00584448 299.32471055 -219.09794059 296.45244324 -219.09472656 293.48632812 C-219.10144379 292.59805328 -219.10816101 291.70977844 -219.11508179 290.79458618 C-219.1340788 287.85828049 -219.13798684 284.92220316 -219.14013672 281.98583984 C-219.14656342 279.94326687 -219.15329169 277.90069481 -219.16030884 275.85812378 C-219.17228584 271.57596706 -219.17598922 267.29389104 -219.17480469 263.01171875 C-219.17460147 257.52826499 -219.20190497 252.04532934 -219.23634911 246.56199837 C-219.25860132 242.34290191 -219.26264274 238.12393047 -219.26158524 233.90478134 C-219.26394367 231.88339324 -219.27278079 229.86200182 -219.28824997 227.84067154 C-219.3078759 225.01125191 -219.30208521 222.18295384 -219.29003906 219.35351562 C-219.30127808 218.52110352 -219.31251709 217.68869141 -219.32409668 216.83105469 C-219.26681066 211.52807481 -218.34963483 208.47926199 -214.80419922 204.29052734 C-212.46099692 202.789368 -210.36845761 201.6214748 -207.86669922 200.47802734 C-207.18591309 200.15253906 -206.50512695 199.82705078 -205.80371094 199.49169922 C-197.96846264 195.79671696 -190.00401035 192.3629041 -182.03076172 188.97802734 C-181.26328613 188.65189453 -180.49581055 188.32576172 -179.70507812 187.98974609 C-177.80419922 187.29052734 -177.80419922 187.29052734 -175.80419922 187.29052734 C-175.56830078 186.02724609 -175.33240234 184.76396484 -175.08935547 183.46240234 C-173.83813669 177.83136665 -171.6077805 172.78104228 -169.24169922 167.54052734 C-168.42340367 165.71440926 -167.60944301 163.88634115 -166.80029297 162.05615234 C-166.26166626 160.8616748 -166.26166626 160.8616748 -165.7121582 159.64306641 C-163.47015906 153.83400382 -164.09047406 150.58211352 -166.55029297 144.93505859 C-167.14618142 143.49307787 -167.74187837 142.05101801 -168.33740234 140.60888672 C-169.28444675 138.35999247 -170.23715619 136.11367119 -171.19506836 133.86938477 C-178.59641598 116.42513758 -178.59641598 116.42513758 -176.80419922 109.29052734 C-174.52385607 104.89248579 -171.39445414 101.59658283 -167.91162109 98.13916016 C-167.32103409 97.54506851 -166.73044708 96.95097687 -166.1219635 96.33888245 C-164.17727787 94.38542624 -162.22540611 92.43933899 -160.27294922 90.49365234 C-158.91649598 89.13585148 -157.56033973 87.77775387 -156.20446777 86.41937256 C-153.36644065 83.57840081 -150.52483714 80.74106846 -147.68066406 77.90625 C-144.03198324 74.26898501 -140.3923831 70.62278634 -136.75539398 66.97383499 C-133.95894778 64.17017094 -131.15776692 61.37127656 -128.3551178 58.57381439 C-127.0107991 57.23083127 -125.6679684 55.886357 -124.3266449 54.54038239 C-122.45481271 52.66348394 -120.5767116 50.79309483 -118.69677734 48.92431641 C-118.14188126 48.36537186 -117.58698517 47.80642731 -117.01527405 47.23054504 C-113.38883248 43.64396661 -110.73898563 42.14348321 -105.66748047 41.81787109 C-97.5847137 41.89859602 -90.29974846 45.73378674 -82.99169922 48.85302734 C-80.75998102 49.79956124 -78.52659233 50.7404956 -76.28596497 51.66575623 C-74.90047218 52.23830143 -73.51995541 52.82308806 -72.14555359 53.42176819 C-67.0900932 55.51747202 -64.42128818 55.30058897 -59.45166016 53.38256836 C-58.6553418 53.02348389 -57.85902344 52.66439941 -57.03857422 52.29443359 C-56.14783203 51.900625 -55.25708984 51.50681641 -54.33935547 51.10107422 C-52.4970527 50.27552621 -50.65588487 49.44744034 -48.81591797 48.61669922 C-44.41644324 46.67649921 -40.60339233 45.17888961 -35.81982422 44.56787109 C-33.62419349 44.21104538 -33.62419349 44.21104538 -31.80419922 43.29052734 C-30.54795459 41.26609078 -30.08301673 39.40103715 -29.52636719 37.08544922 C-28.03854756 31.32731566 -25.27770065 25.96160973 -22.86669922 20.54052734 C-22.34140625 19.33525391 -21.81611328 18.12998047 -21.27490234 16.88818359 C-20.75992188 15.72673828 -20.24494141 14.56529297 -19.71435547 13.36865234 C-19.2516626 12.3209668 -18.78896973 11.27328125 -18.31225586 10.19384766 C-13.74959916 1.40979174 -9.54910642 -0.01034722 0 0 Z " fill="%2393C6EC" transform="translate(218.80419921875,-0.29052734375)"/><path d="M0 0 C46 0 46 0 52 4 C53.50115934 6.3432023 54.66905255 8.4357416 55.8125 10.9375 C56.13798828 11.61828613 56.46347656 12.29907227 56.79882812 13.00048828 C60.49381039 20.83573658 63.92762325 28.80018886 67.3125 36.7734375 C67.63863281 37.54091309 67.96476562 38.30838867 68.30078125 39.09912109 C69 41 69 41 69 43 C70.26328125 43.23589844 71.5265625 43.47179688 72.828125 43.71484375 C78.4591607 44.96606253 83.50948507 47.19641872 88.75 49.5625 C90.57611808 50.38079555 92.4041862 51.19475621 94.234375 52.00390625 C95.03069336 52.36299072 95.82701172 52.7220752 96.64746094 53.09204102 C102.45652352 55.33404016 105.70841383 54.71372516 111.35546875 52.25390625 C112.79744947 51.6580178 114.23950934 51.06232084 115.68164062 50.46679688 C117.93053487 49.51975247 120.17685616 48.56704303 122.42114258 47.60913086 C139.86538976 40.20778323 139.86538976 40.20778323 147 42 C151.39804156 44.28034315 154.69394452 47.40974508 158.15136719 50.89257812 C158.74545883 51.48316513 159.33955048 52.07375214 159.9516449 52.68223572 C161.9051011 54.62692135 163.85118836 56.57879311 165.796875 58.53125 C167.15467586 59.88770323 168.51277347 61.24385949 169.87115479 62.59973145 C172.71212654 65.43775857 175.54945888 68.27936208 178.38427734 71.12353516 C182.02154234 74.77221597 185.667741 78.41181611 189.31669235 82.04880524 C192.1203564 84.84525144 194.91925078 87.64643229 197.71671295 90.44908142 C199.05969607 91.79340011 200.40417034 93.13623082 201.75014496 94.47755432 C203.6270434 96.34938651 205.49743252 98.22748762 207.36621094 100.10742188 C207.92515549 100.66231796 208.48410004 101.21721405 209.0599823 101.78892517 C212.64656074 105.41536674 214.14704413 108.06521359 214.47265625 113.13671875 C214.39193132 121.21948552 210.5567406 128.50445076 207.4375 135.8125 C206.4909661 138.0442182 205.55003175 140.27760689 204.62477112 142.51823425 C204.05222591 143.90372704 203.46743929 145.28424381 202.86875916 146.65864563 C200.77305533 151.71410602 200.98993837 154.38291104 202.90795898 159.35253906 C203.26704346 160.14885742 203.62612793 160.94517578 203.99609375 161.765625 C204.38990234 162.65636719 204.78371094 163.54710937 205.18945312 164.46484375 C206.01500114 166.30714651 206.84308701 168.14831435 207.67382812 169.98828125 C209.61402813 174.38775598 211.11163773 178.20080689 211.72265625 182.984375 C212.07948197 185.18000572 212.07948197 185.18000572 213 187 C215.02443656 188.25624463 216.8894902 188.72118249 219.20507812 189.27783203 C224.96321169 190.76565166 230.32891761 193.52649857 235.75 195.9375 C236.95527344 196.46279297 238.16054688 196.98808594 239.40234375 197.52929688 C240.56378906 198.04427734 241.72523438 198.55925781 242.921875 199.08984375 C243.96956055 199.55253662 245.01724609 200.01522949 246.09667969 200.49194336 C250.59586253 202.82893061 254.23344306 205.12798151 256 210 C256.20164526 212.96581679 256.29374137 215.83808411 256.29052734 218.80419922 C256.29724457 219.69247406 256.30396179 220.5807489 256.31088257 221.49594116 C256.32987959 224.43224685 256.33378762 227.36832418 256.3359375 230.3046875 C256.34236421 232.34726048 256.34909247 234.38983253 256.35610962 236.43240356 C256.36808662 240.71456028 256.37179 244.9966363 256.37060547 249.27880859 C256.37040225 254.76226235 256.39770576 260.245198 256.43214989 265.72852898 C256.4544021 269.94762543 256.45844352 274.16659687 256.45738602 278.385746 C256.45974445 280.4071341 256.46858158 282.42852552 256.48405075 284.4498558 C256.50367668 287.27927543 256.49788599 290.10757351 256.48583984 292.93701172 C256.49707886 293.76942383 256.50831787 294.60183594 256.51989746 295.45947266 C256.46261144 300.76245254 255.54543561 303.81126535 252 308 C249.6567977 309.50115934 247.5642584 310.66905255 245.0625 311.8125 C244.0413208 312.30073242 244.0413208 312.30073242 242.99951172 312.79882812 C235.16426342 316.49381039 227.19981114 319.92762325 219.2265625 323.3125 C218.45908691 323.63863281 217.69161133 323.96476562 216.90087891 324.30078125 C215 325 215 325 213 325 C212.76410156 326.26328125 212.52820313 327.5265625 212.28515625 328.828125 C211.03393747 334.4591607 208.80358128 339.50948507 206.4375 344.75 C205.61920445 346.57611808 204.80524379 348.4041862 203.99609375 350.234375 C203.63700928 351.03069336 203.2779248 351.82701172 202.90795898 352.64746094 C200.66595984 358.45652352 201.28627484 361.70841383 203.74609375 367.35546875 C204.3419822 368.79744947 204.93767916 370.23950934 205.53320312 371.68164062 C206.48024753 373.93053487 207.43295697 376.17685616 208.39086914 378.42114258 C215.79221677 395.86538976 215.79221677 395.86538976 214 403 C211.71965685 407.39804156 208.59025492 410.69394452 205.10742188 414.15136719 C204.51683487 414.74545883 203.92624786 415.33955048 203.31776428 415.9516449 C201.37307865 417.9051011 199.42120689 419.85118836 197.46875 421.796875 C196.11229677 423.15467586 194.75614051 424.51277347 193.40026855 425.87115479 C190.56224143 428.71212654 187.72063792 431.54945888 184.87646484 434.38427734 C181.22778403 438.02154234 177.58818389 441.667741 173.95119476 445.31669235 C171.15474856 448.1203564 168.35356771 450.91925078 165.55091858 453.71671295 C164.20659989 455.05969607 162.86376918 456.40417034 161.52244568 457.75014496 C159.65061349 459.6270434 157.77251238 461.49743252 155.89257812 463.36621094 C155.33768204 463.92515549 154.78278595 464.48410004 154.21107483 465.0599823 C150.58463326 468.64656074 147.93478641 470.14704413 142.86328125 470.47265625 C134.78051448 470.39193132 127.49554924 466.5567406 120.1875 463.4375 C117.9557818 462.4909661 115.72239311 461.55003175 113.48176575 460.62477112 C112.09627296 460.05222591 110.71575619 459.46743929 109.34135437 458.86875916 C104.28589398 456.77305533 101.61708896 456.98993837 96.64746094 458.90795898 C95.85114258 459.26704346 95.05482422 459.62612793 94.234375 459.99609375 C93.34363281 460.38990234 92.45289063 460.78371094 91.53515625 461.18945312 C89.69285349 462.01500114 87.85168565 462.84308701 86.01171875 463.67382812 C81.61224402 465.61402813 77.79919311 467.11163773 73.015625 467.72265625 C70.81999428 468.07948197 70.81999428 468.07948197 69 469 C67.74375537 471.02443656 67.27881751 472.8894902 66.72216797 475.20507812 C65.23434834 480.96321169 62.47350143 486.32891761 60.0625 491.75 C59.53720703 492.95527344 59.01191406 494.16054688 58.47070312 495.40234375 C57.95572266 496.56378906 57.44074219 497.72523438 56.91015625 498.921875 C56.44746338 499.96956055 55.98477051 501.01724609 55.50805664 502.09667969 C52.98235365 506.95917928 50.9448105 509.52759475 46 512 C30.82 512 15.64 512 0 512 C0 448.64 0 385.28 0 320 C7.92 318.02 7.92 318.02 16 316 C28.30382989 310.86344966 37.41221537 303.34392424 43 291 C45.71387386 283.71562465 46.46722701 277.06080585 46.46875 269.32421875 C46.47636353 268.23720169 46.48397705 267.15018463 46.49182129 266.03022766 C46.5025658 263.74356365 46.50549857 261.4568508 46.50097656 259.17016602 C46.50000547 255.706996 46.54167125 252.24605363 46.5859375 248.78320312 C46.66907946 233.38236968 45.69048804 220.96064503 35 209 C34.49984375 208.39671875 33.9996875 207.7934375 33.484375 207.171875 C24.85017755 197.53175164 12.20780239 194.44156048 0 192 C0 128.64 0 65.28 0 0 Z " fill="%2378B7EA" transform="translate(256,0)"/><path d="M0 0 C1.24923156 1.03883466 2.47843653 2.10217863 3.6875 3.1875 C4.36425781 3.76113281 5.04101562 4.33476562 5.73828125 4.92578125 C11.47180273 10.1410183 14.71256073 16.08175333 17.6875 23.1875 C18.03586914 24.00444336 18.38423828 24.82138672 18.74316406 25.66308594 C20.0728523 30.62569694 20.01255919 35.39062748 20.0234375 40.5078125 C20.0334227 42.15038528 20.0334227 42.15038528 20.04360962 43.82614136 C20.05371689 46.14091315 20.05842724 48.45571397 20.05810547 50.77050781 C20.06245943 54.2797975 20.09874825 57.78780915 20.13671875 61.296875 C20.14259141 63.55468324 20.14655779 65.8124974 20.1484375 68.0703125 C20.16280853 69.10511749 20.17717957 70.13992249 20.19198608 71.20608521 C20.10436824 85.45653317 14.43459453 96.08102201 5 106.4375 C-4.26802453 115.36226436 -15.95498516 118.58011673 -28.41821289 118.48071289 C-41.67229978 118.20008234 -51.5613872 113.52393161 -61.5 104.75 C-74.2110325 91.3824059 -74.56715936 75.3503873 -74.66259766 57.99609375 C-74.67909223 55.80457899 -74.70629528 53.61311656 -74.74462891 51.421875 C-75.03618465 34.62826391 -74.61126297 20.00592901 -62.3125 7.1875 C-45.86434926 -9.65883689 -19.8139292 -14.04288186 0 0 Z " fill="%23D7F0FA" transform="translate(283.3125,200.8125)"/><path d="M0 0 C0.81863022 -0.01283524 1.63726044 -0.02567047 2.48069763 -0.03889465 C3.35984329 -0.04628159 4.23898895 -0.05366852 5.14477539 -0.0612793 C6.06271378 -0.06935104 6.98065216 -0.07742279 7.92640686 -0.08573914 C9.87230555 -0.09956221 11.8182283 -0.1102923 13.76416016 -0.11816406 C15.73363461 -0.1296267 17.70307943 -0.14998661 19.67236328 -0.1796875 C37.05882227 -0.44167724 51.52390371 0.99274063 65.05493164 13.20825195 C76.20845315 24.86875172 78.46515007 37.07301655 78.21118164 52.5246582 C77.69601939 63.58040806 72.49115022 73.29578418 64.80493164 81.17700195 C53.44485152 91.34850226 40.67276544 94.70445574 25.67993164 94.36450195 C24.53266602 94.3509668 23.38540039 94.33743164 22.20336914 94.32348633 C19.40338206 94.28848649 16.60441947 94.23939054 13.80493164 94.17700195 C13.85206299 95.1671228 13.85206299 95.1671228 13.90014648 96.17724609 C14.02565433 99.19764272 14.10314731 102.21748994 14.17993164 105.23950195 C14.23020508 106.2778418 14.28047852 107.31618164 14.33227539 108.38598633 C14.4321915 113.63158223 14.39899816 117.20700002 10.93383789 121.33325195 C7.33426994 124.93337206 4.44458414 126.02794264 -0.63256836 126.48950195 C-6.05017001 126.01427374 -9.47352302 124.24773613 -13.00756836 120.17700195 C-15.60726252 116.61170711 -16.31773811 114.24059227 -16.34223938 109.94633484 C-16.34939468 109.08422394 -16.35654999 108.22211304 -16.36392212 107.33387756 C-16.36661102 106.39096359 -16.36929993 105.44804962 -16.37207031 104.4765625 C-16.37864151 103.48114441 -16.38521271 102.48572632 -16.39198303 101.46014404 C-16.4117169 98.16133552 -16.42337821 94.8625725 -16.43334961 91.5637207 C-16.43742514 90.43760691 -16.44150066 89.31149311 -16.44569969 88.15125465 C-16.46655973 82.19214689 -16.48086237 76.23306216 -16.49023438 70.27392578 C-16.50130511 64.11677134 -16.53571321 57.95997767 -16.57540607 51.80295086 C-16.60153876 47.07002587 -16.6099232 42.33718734 -16.61351585 37.60419655 C-16.6183896 35.33439507 -16.63002589 33.06459765 -16.64855385 30.79486656 C-16.67287579 27.61816082 -16.67199276 24.44239515 -16.66503906 21.265625 C-16.67784912 20.32878372 -16.69065918 19.39194244 -16.70385742 18.42671204 C-16.64894711 11.54241673 -14.7144645 8.09005375 -10.19506836 2.86450195 C-7.07373731 0.23087888 -3.98644338 0.05482471 0 0 Z " fill="%23D7F0FA" transform="translate(345.195068359375,192.822998046875)"/><path d="M0 0 C0.77633789 -0.00428513 1.55267578 -0.00857025 2.35253906 -0.01298523 C3.98631825 -0.01870255 5.62012287 -0.01924804 7.25390625 -0.01489258 C9.74263128 -0.01172812 12.23017122 -0.03523846 14.71875 -0.06054688 C16.31249851 -0.06281983 17.9062502 -0.06352338 19.5 -0.0625 C20.23766602 -0.07170975 20.97533203 -0.08091949 21.73535156 -0.09040833 C28.05393474 -0.03425827 31.90796641 1.69901291 36.625 5.80078125 C39.45330724 9.46202039 39.39547658 13.19147235 39.1640625 17.6796875 C38.35464326 22.80346401 36.02759039 25.28281815 32.078125 28.4296875 C26.10154765 31.74550788 18.71466457 30.82969378 12.0625 30.80078125 C9.26624692 30.78871886 6.47186963 30.80242668 3.67578125 30.83203125 C2.44255127 30.82751953 1.20932129 30.82300781 -0.0612793 30.81835938 C-3.81872214 31.38682328 -4.97459187 32.32105534 -7.25 35.30078125 C-7.87222293 37.27813202 -7.87222293 37.27813202 -7.75 39.30078125 C-7.7603125 39.96078125 -7.770625 40.62078125 -7.78125 41.30078125 C-7.00399825 44.2269055 -5.57320822 45.39551628 -3.25 47.30078125 C-0.52367056 47.89091473 -0.52367056 47.89091473 2.4765625 47.8046875 C4.14912109 47.83272461 4.14912109 47.83272461 5.85546875 47.86132812 C7.59763672 47.86229492 7.59763672 47.86229492 9.375 47.86328125 C23.12757567 47.91779316 33.58517941 49.74021634 43.9140625 59.3046875 C52.60343647 68.40086736 55.44696179 76.99666748 55.27832031 89.37133789 C55.01590974 95.62858053 53.94588136 100.83792523 50.75 106.30078125 C50.151875 107.35265625 49.55375 108.40453125 48.9375 109.48828125 C43.43301459 116.56547677 38.01742107 120.75190436 29.75 124.30078125 C29.0475415 124.64536377 28.34508301 124.98994629 27.62133789 125.3449707 C23.8691176 126.59400926 20.2906124 126.62533381 16.37890625 126.63671875 C15.57895737 126.64337555 14.77900848 126.65003235 13.95481873 126.65689087 C12.26799814 126.66698636 10.58113787 126.67170885 8.89428711 126.67138672 C6.32403385 126.67576162 3.75549692 126.71211618 1.18554688 126.75 C-0.4583275 126.75586866 -2.10220998 126.75983772 -3.74609375 126.76171875 C-4.5087706 126.77608978 -5.27144745 126.79046082 -6.05723572 126.80526733 C-12.11633788 126.75378369 -15.45907511 124.70675098 -20.0625 120.73828125 C-23.03610127 117.13865866 -22.64051926 112.45679109 -22.59375 108.03125 C-22.0409117 103.6399549 -20.57711861 102.19392787 -17.25 99.30078125 C-12.6845154 96.56630786 -9.35300475 95.94067624 -4.05859375 95.96484375 C-2.68814624 95.95233882 -1.31770349 95.93930205 0.05273438 95.92578125 C2.18791551 95.92184679 4.32262675 95.9258504 6.45776367 95.94042969 C8.53634532 95.94902183 10.61299492 95.92730032 12.69140625 95.90234375 C14.54294312 95.90741943 14.54294312 95.90741943 16.43188477 95.91259766 C20.66223589 95.13257706 22.16619813 93.68179512 24.75 90.30078125 C24.67607229 86.01297402 24.1333231 83.87576591 21.75 80.30078125 C18.64193594 79.2647599 16.41637757 79.16138068 13.15625 79.125 C12.0425 79.10115234 10.92875 79.07730469 9.78125 79.05273438 C7.45851001 79.01033923 5.13554249 78.97878303 2.8125 78.95898438 C-10.32811209 78.63498993 -19.57990196 74.71406797 -29 65.609375 C-37.59234782 56.35112022 -38.7151002 45.79843195 -38.53515625 33.7421875 C-38.32030161 28.56948112 -37.06645888 24.64728872 -34.25 20.30078125 C-33.651875 19.26953125 -33.05375 18.23828125 -32.4375 17.17578125 C-24.14360607 6.27523495 -13.93979968 -0.01722302 0 0 Z " fill="%23EFF4FE" transform="translate(135.25,192.69921875)"/><path d="M0 0 C0 9.57 0 19.14 0 29 C-2.97 30.32 -5.94 31.64 -9 33 C-12.64697327 36.10380704 -15.60893184 39.09914267 -16.26742554 43.98370361 C-16.27504913 44.67905212 -16.28267273 45.37440063 -16.29052734 46.09082031 C-16.30328705 46.88554749 -16.31604675 47.68027466 -16.32919312 48.49908447 C-16.33141876 49.35016785 -16.33364441 50.20125122 -16.3359375 51.078125 C-16.3425943 51.96352966 -16.3492511 52.84893433 -16.35610962 53.76116943 C-16.36622542 55.63389005 -16.37092697 57.50664663 -16.37060547 59.37939453 C-16.37496357 62.22620119 -16.41125186 65.07143781 -16.44921875 67.91796875 C-16.45509038 69.74218223 -16.45905746 71.56640304 -16.4609375 73.390625 C-16.47530853 74.23361145 -16.48967957 75.0765979 -16.50448608 75.94512939 C-16.45793188 82.05325485 -15.61788688 85.98182925 -12 91 C-8.04 92.98 -4.08 94.96 0 97 C0 106.57 0 116.14 0 126 C-13.9264616 126 -23.74142553 121.78442512 -34.1875 112.5625 C-46.8985325 99.1949059 -47.25465936 83.1628873 -47.35009766 65.80859375 C-47.36659223 63.61707899 -47.39379528 61.42561656 -47.43212891 59.234375 C-47.72368465 42.44076391 -47.29876297 27.81842901 -35 15 C-24.96063991 4.71760139 -14.36028125 0 0 0 Z " fill="%23EFF4FE" transform="translate(256,193)"/><path d="M0 0 C4.8215804 3.17785981 8.05470361 6.2444623 9.75 11.8125 C10.04307499 14.73818151 10.05410704 17.64729873 10.05078125 20.5859375 C10.05506638 21.4279068 10.0593515 22.2698761 10.06376648 23.13735962 C10.06949516 24.9141551 10.07002084 26.69097404 10.06567383 28.46777344 C10.06251851 31.17163575 10.08597453 33.87439814 10.11132812 36.578125 C10.11360189 38.30989446 10.11430425 40.04166685 10.11328125 41.7734375 C10.122491 42.57470062 10.13170074 43.37596375 10.14118958 44.20150757 C10.09233891 50.19446118 9.11185276 55.11784071 5.03125 59.7734375 C4.4434375 60.24007812 3.855625 60.70671875 3.25 61.1875 C2.6621875 61.66960937 2.074375 62.15171875 1.46875 62.6484375 C-2.70227637 65.47335991 -7.41429884 65.48542929 -12.25 64.8125 C-18.03859472 62.63923812 -20.73613995 59.56100048 -23.38587952 54.11352539 C-24.84846487 50.21887633 -24.84102133 46.46508949 -24.81640625 42.34375 C-24.82260483 41.46400513 -24.82880341 40.58426025 -24.83518982 39.67785645 C-24.84225259 37.82903136 -24.83917635 35.9801422 -24.82641602 34.13134766 C-24.81253425 31.31943726 -24.84669094 28.51084978 -24.88476562 25.69921875 C-24.88571688 23.89322836 -24.88385763 22.08723385 -24.87890625 20.28125 C-24.89879356 19.03559265 -24.89879356 19.03559265 -24.91908264 17.76477051 C-24.82316817 11.68512631 -23.16622062 7.49625358 -19.25 2.8125 C-13.4562053 -2.07887497 -7.02734612 -2.56768416 0 0 Z " fill="%2393C6EC" transform="translate(263.25,224.1875)"/><path d="M0 0 C5.506875 -0.12375 5.506875 -0.12375 11.125 -0.25 C12.2711377 -0.28641602 13.41727539 -0.32283203 14.59814453 -0.36035156 C20.74920075 -0.42722259 24.35258666 -0.15622331 29 4 C33.82911404 9.48169702 34.36430815 12.80787083 34.26953125 20.01953125 C33.83319993 24.84447032 32.05918658 27.27347071 28.41015625 30.33300781 C22.52272736 34.49963957 17.54448575 34.61059275 10.5 34.3125 C7.035 34.209375 3.57 34.10625 0 34 C0 22.78 0 11.56 0 0 Z " fill="%2379B7EA" transform="translate(359,223)"/><path d="M0 0 C8.65789474 1.23684211 8.65789474 1.23684211 13 5 C16.73905298 10.51271084 17.58914417 15.52430677 17.49609375 22.06640625 C17.49754898 22.90413071 17.49900421 23.74185516 17.50050354 24.60496521 C17.49885406 26.36387637 17.48740027 28.12280341 17.46655273 29.8815918 C17.43753728 32.55905991 17.44597579 35.23455058 17.45898438 37.91210938 C17.45274727 39.63021786 17.44435654 41.34832016 17.43359375 43.06640625 C17.43652939 43.85825821 17.43946503 44.65011017 17.44248962 45.46595764 C17.34246376 51.41553125 16.2512826 56.2026142 12.421875 60.9609375 C11.87015625 61.42757812 11.3184375 61.89421875 10.75 62.375 C10.20859375 62.85710937 9.6671875 63.33921875 9.109375 63.8359375 C7 65 7 65 0 66 C0 44.22 0 22.44 0 0 Z " fill="%2378B7EA" transform="translate(256,223)"/>
</svg>
' />


</head>

<body>

  <!-- Put in <head> -->



  <!-- <script type="text/plain" id="jsonEmbedded">


  </script> -->

  <script id="jsonEmbedded" type="application/json"></script>


  <header>

    <div class="wrap">
      <div class="row">
        <div class="grow">
          <h1 id="sop-run-mode-title" onclick="goHome()" class="grow"></h1>
          <input id="sop-run-mode-title-input" class="grow" style="width: 33.33%; padding: 8px 12px;" type="text"
            value="New SOP" placeholder="SOP Title" />
        </div>

        <div class="controls">
          <button id="btnHome" data-hide="guide" class="vw-home" title="Home" onclick="goHome()">
            🏠 Home
          </button>



          <input id="importHtmlInput" type="file" accept=".html,text/html" hidden>
          <span id="importHtmlNote" class="small"></span>



          <button id="globalSaveBtn" disabled>Save</button>



          <div class="seg" id="modeSeg" data-hide="guide">
            <button id="modeView" class="seg-btn">Preview</button>
            <button id="modeEdit" class="seg-btn">Edit</button>
          </div>
          <button id="settingsBtn" class="btn">⚙️</button>

        </div>
      </div>
    </div>
  </header>

  <main>
    <section id="starter" class="wrap">
      <div id="vwWizard">
        <div class="vw-crumbs">
          <button id="vwBackHome" onclick="goHome()" class="btn">◀ Back</button>
          <span class="title" id="vwStarterTitle"></span>
          <a id="vwOpenMap" href="#" class="link">Show Map</a>
        </div>

        <!-- Movable Map Dialog -->
        <!-- Mini-Map dialog (hidden by default) -->
        <div id="vwMapDlg" class="dlg" hidden>
          <div id="vwMapDrag" class="dlg-head">
            <strong>Map</strong>
            <button id="vwMapClose" class="dlg-x" type="button" aria-label="Close">×</button>
          </div>
          <div class="dlg-body">
            <div class="mini-viewport">
              <div id="vwMiniGraph"></div>
            </div>
          </div>
        </div>




        <div id="vwStep"></div>
        <div class="vw-nav">
          <button id="vwPrev" class="btn">Previous</button>
          <button id="vwNext" class="btn-accent">Next</button>
        </div>
      </div>
      <div id="editStarter" class="layout">

        <!-- Center: Graph -->
        <div class="panel graph-panel" id="graphPanel">
          <div class="graph-header">
            <div class="rowflex">
              <strong>Map</strong>
              <span id="graph-starter-title" class="badge">Top→Bottom</span>
            </div>
            <div class="graph-zoom">
              <button id="zoomOutBtn">−</button>
              <button id="zoomInBtn">+</button>
              <button id="zoomResetBtn">Reset position</button>
              <button id="formatBtn" class="graph-action" title="Auto format">Format graph</button>
              <!-- <button id="fullscreenBtn">Full screen</button> -->
            </div>
          </div>
          <div class="graph-canvas" id="graphCanvas">
            <svg id="graphSvg" class="graph-svg" role="img">
              <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8"
                  orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#98a2b3"></path>
                </marker>
              </defs>
            </svg>
            <div class="graph-fabs graph-fabs--top" id="graphFabsTop">
              <!-- <button id="addAfterBtn" class="graph-action graph-action--accent" title="Add step after">+After</button> -->
              <button id="addFreeBtn" class="graph-action" title="Add step (free)">+ Add Step</button>
              <!-- <button id="addBeforeBtn" class="graph-action graph-action--accent"
                title="Add step before">+Before</button>
              <button id="dupStepBtn" class="graph-action" title="Delete step">Duplicate</button> -->
              <button id="delStepBtn" class="graph-action warn" title="Delete step">- Delete Step</button>
            </div>
          </div>
          <!-- <div class="small">
            Click a node to edit. Edges come from <b>step.next</b> (instruction/input/multi-select) and from
            <b>option.next</b> (single-select). Edge labels show <i>option.value</i>.
          </div> -->
          <div class="small">
            Click a node to edit and drag to arrange. Arrows show flow: <b>step.next</b> for
            instruction/input/multi-select, and <b>option.next</b> for single-select (edge label = <i>option.value</i>).
            The flow starts at the first step and ends at <b>done</b>. Use <b>+ After</b> to insert after the selected
            step; <b>Delete</b> removes it.
          </div>

        </div>

        <div id="splitter" class="splitter" role="separator" aria-orientation="vertical" aria-label="Resize panels"
          tabindex="-1">• • •</div>


        <!-- Right: Inspector -->
        <div class="panel" id="rightPanel">
          <h2>Properties</h2>
          <div id="propBox" class="small">Select a step from the list or the map.</div>

          <div id="toolMsg" class="small"></div>
        </div>
      </div>
    </section>
    <section id="landing">
      <div class="wrap">
        <div id="vwLanding"></div>

      </div>
    </section>


    <div id="dlgNewStarter" class="vw-dialog hidden">
      <div class="vw-dialog__panel" role="dialog">
        <h3 id="nsHeading">Create starter</h3>

        <div class="vw-field">
          <label for="nsLabel">Label</label>
          <input maxlength="50" id="nsLabel" type="text" placeholder="Starter X" required>
          <p id="nsLabelErr" class="vw-error"></p>

        </div>

        <div class="vw-field">
          <label for="nsSummary">Summary</label>
          <textarea maxlength="200" id="nsSummary" rows="3" placeholder="Optional"></textarea>
        </div>

        <div class="vw-actions">
          <button type="button" class="btn" id="nsCancel">Cancel</button>
          <button type="button" class="btn-accent" id="nsCreate">Create</button>
        </div>

      </div>
    </div>

    <!-- Import Dialog (same shell as New) -->
    <div id="dlgImport" class="vw-dialog hidden">
      <div class="vw-dialog__panel" role="dialog" aria-labelledby="imHeading">
        <h3 id="imHeading">Import SOP</h3>

        <div class="vw-field">
          <div id="imDrop" class="drop-zone" tabindex="0" aria-label="Drop .html here">
            <svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="32.000000pt" height="32.000000pt"
              viewBox="0 0 512.000000 512.000000" preserveAspectRatio="xMidYMid meet">

              <g transform="translate(0.000000,512.000000) scale(0.100000,-0.100000)" fill="var(--accent)"
                stroke="none">
                <path d="M2380 4954 c-160 -18 -230 -29 -330 -51 -900 -197 -1601 -880 -1820
                  -1775 -52 -213 -64 -322 -64 -568 0 -246 13 -358 64 -568 92 -375 262 -706
                  515 -1000 382 -445 916 -731 1515 -814 123 -17 478 -16 600 1 697 96 1288 457
                  1678 1024 206 299 339 639 398 1019 25 157 25 518 1 675 -82 521 -313 985
                  -671 1347 -369 374 -830 607 -1363 691 -93 15 -448 28 -523 19z m243 -968 c18
                  -8 172 -155 349 -332 306 -308 316 -321 323 -365 17 -118 -91 -214 -202 -179
                  -28 9 -82 56 -205 178 l-168 166 -2 -731 c-3 -724 -3 -732 -24 -760 -73 -98
                  -195 -98 -268 0 -21 28 -21 36 -24 760 l-2 731 -168 -166 c-135 -135 -175
                  -168 -210 -179 -114 -33 -226 79 -193 194 11 36 60 90 324 356 172 172 326
                  319 342 327 39 17 88 17 128 0z m-1003 -1798 c80 -41 85 -55 88 -254 l3 -174
                  850 0 849 0 0 160 c0 181 8 212 62 254 79 60 188 35 235 -54 22 -42 23 -51 23
                  -294 0 -282 -6 -311 -71 -357 l-34 -24 -1055 -2 -1055 -3 -40 23 c-26 14 -48
                  37 -62 67 -22 42 -23 55 -23 295 0 240 1 253 23 295 24 48 88 90 137 90 14 0
                  46 -10 70 -22z" />
              </g>
            </svg>
            <div class="row">

              <span class="dz-text">Drop .html file here — or</span>
              <a href="#" id="imBrowse" class="link">browse</a>
              <span class="dz-text">to upload.</span>
            </div>
          </div>
          <input id="imFile" type="file" accept=".html,text/html" hidden>
          <p id="imErrFile" class="vw-error"></p>
        </div>

        <div class="vw-sep"><span>or</span></div>


        <div class="vw-field">
          <div class="row" style="gap:8px; align-items:center;">
            <input id="imUrl" type="url" placeholder="https://example.com/sop.html" style="flex:1;">
            <button id="imFetch" type="button" class="btn-accent">Import</button>
          </div>
          <p id="imErrUrl" class="vw-error"></p>
        </div>
      </div>
    </div>







  </main>

  <script>






    function openDB(name, version = 1, onUpgrade) {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(name, version);
        req.onerror = () => reject(req.error);
        req.onupgradeneeded = (e) => {
          const db = req.result;
          if (onUpgrade) onUpgrade(db, e.oldVersion, e.newVersion);
        };
        req.onsuccess = () => resolve(req.result);
      });
    }

    async function idbPut(dbName, storeName, value) {
      const db = await openDB(dbName, 1, (db) => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id' });
        }
      });
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).put(value);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }


    async function idbGet(dbName, storeName, key) {
      const db = await openDB(dbName, 1, (db) => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id' });
        }
      });
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readonly');
        const req = tx.objectStore(storeName).get(key);
        req.onsuccess = () => resolve(req.result ? req.result.sop : null);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbDel(dbName, storeName, key) {
      const db = await openDB(dbName, 1);
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Any input/change inside header editor or starter editor toggles dirty
    document.addEventListener('input', (e) => {
      if (isInEditableArea(e.target)) {
        setDirty(true);
        renderViewStep();
      }
    }, true);

    // Only mark dirty on change if the value actually differs from SOP
    document.addEventListener('change', (e) => {

      const t = e.target;
      if (!t) return;
      if (!isInEditableArea(t)) return;

      // if (t.id === 'vwTitleInput') {
      //   const v = (t.value || '').trim();
      //   if ((sop.title || '') !== v) { sop.title = v; setDirty(true); }
      //   return;
      // }
      // if (t.id === 'vwDescInput') {
      //   const v = (t.value || '').trim();
      //   if ((sop.description || '') !== v) { sop.description = v; setDirty(true); }
      //   return;
      // }

      setDirty(true);
    }, true);


    let sop = makeBlankSOP();
    let savedSop = null; // last saved snapshot

    const viewState = { starterIdx: 0, answers: {}, selectedStepId: 0, prev: {} };


    // ---- Save button state ----
    let isDirty = false;
    function setDirty(v = true) { isDirty = !!v; updateSaveBtn(); }
    function clearDirty() { setDirty(false); }

    function updateSaveBtn() {
      const btn = document.getElementById('globalSaveBtn');
      if (!btn) return;
      btn.disabled = !isDirty;
      btn.classList.toggle('btn-accent', isDirty);
      btn.classList.toggle('btn', !isDirty);
    }

    function isInEditableArea(el) {
      // const hdr = document.getElementById('vwHeaderEditor');
      const edt = document.getElementById('editStarter');
      return (edt && edt.contains(el));
    }

    // is inside the graph area (to avoid trapping Del key when typing in inputs)
    function isInGraphArea(el) {
      const gp = document.getElementById('graphSvg');
      return (gp && gp.contains(el));
    }

    async function performSave() {
      if (!isDirty) return false;
      try {
        // if (typeof syncHeaderInputsIntoSop === 'function') syncHeaderInputsIntoSop();
        const payload = JSON.parse(JSON.stringify(sop));
        await idbPut('opsPathDB', 'sops', {
          id: 'current',
          sop: payload,
          updatedAt: new Date().toISOString()
        });
        savedSop = structuredClone(sop);
        clearDirty();
        return true;
      } catch (err) {
        console.error('Save failed', err);
        alert('Save failed: ' + (err?.message || err));
        return false;
      }
    }

    document.getElementById('globalSaveBtn')?.addEventListener('click', saveSop);


    async function saveSop() {
      const ok = await performSave();
      if (!ok) return;
      const btnSave = document.getElementById('globalSaveBtn');
      const old = btnSave.textContent; btnSave.textContent = 'Saved ✓';
      setTimeout(() => btnSave.textContent = old, 800);
    }


    let hotkeysWired = false;
    function wireHotkeys() {
      if (hotkeysWired) return; hotkeysWired = true;

      document.addEventListener('keydown', async (e) => {
        // const currentMode = document.documentElement.getAttribute('data-mode');
        const activeEl = document.activeElement;
        // if is dirty anywhere in the doc, Ctrl+S / Cmd+S triggers save
        const isSave = (e.ctrlKey || e.metaKey) && (e.key === 's' || e.key === 'S');

        // if (!) return;
        if (
          isSave &&
          isDirty &&
          isEditMode()) {

          e.preventDefault();
          // if (isDirty) {
          saveSop();
          // }
        }

        // if in edit mode and on the graph and a step is selected, Del triggers delete
        if (
          e.key === 'Delete' &&
          isEditMode() &&
          viewState.selectedStepId
          && !isInEditableArea(activeEl)
        ) {
          e.preventDefault();
          delStep();
        }
      });
    }


    /*** Elements ***/
    const starterSelect = document.getElementById('starterSelect');
    const stepsList = document.getElementById('stepsList');
    const graphSvg = document.getElementById('graphSvg');
    const graphPanel = document.getElementById('graphPanel');
    const graphStarterTitle = document.getElementById('graph-starter-title');

    function getCurrentRunMode() {
      return document.documentElement.getAttribute('run-mode') || 'studio';
    }



    document.addEventListener('DOMContentLoaded', () => {


      (async () => {
        // 1) Try embedded JSON
        // check run mode studio or guide
        const currentRunMode = getCurrentRunMode();
        if (currentRunMode === 'guide') {
          const embedded = document.getElementById('jsonEmbedded');
          if (embedded && embedded.textContent) {
            try {
              const parsed = JSON.parse(embedded.textContent);
              if (parsed && Array.isArray(parsed.starters)) {
                sop = parsed;
                // savedSop = structuredClone(sop);
              }
            } catch (err) {
              console.warn('Failed to parse embedded SOP JSON', err);
            }
          }

        }
        // 2) if not found, load it from db
        else {
          try {
            const restored = await idbGet('opsPathDB', 'sops', 'current');
            if (restored) {
              sop = restored;
              // savedSop = structuredClone(sop);

            }
          } catch (_) { }
        }
        // 1) if not found load create a new one
        if (!sop || !Array.isArray(sop.starters) || sop.starters.length === 0) {
          sop = makeBlankSOP();
        }




        viewState.starterIdx = 0;
        // viewState.selectedStepId = sop.starters[0]?.steps?.[0]?.id || null;
        setSelectedStepById(getStarterStartId(sop.starters[0]));

        ensureSop();
        renderViewAndEditLanding();
        renderSopTitle();


        wireGlobal();
        wireHotkeys();

        savedSop = structuredClone(sop);


        if (typeof updateSaveBtn === 'function') updateSaveBtn();

        // Warn on tab close / refresh / navigate away when there are unsaved changes
        window.addEventListener('beforeunload', (e) => {
          if (!isDirty) return;   // only if something is unsaved
          e.preventDefault();                   // required by some browsers
          e.returnValue = '';                   // shows the built-in confirmation dialog
        });


        // --- deep link: ?starter=<id> or ?starterId=<id>
        const sp = new URLSearchParams(location.search);
        const starterId = sp.get('starter_id');
        if (starterId) {
          console.log('deep link starterId:', starterId);
          // only switch if it exists in sop
          const ok = Array.isArray(sop?.starters) && sop.starters.some(st => String(st?.id) === String(starterId));
          if (ok && typeof enterViewOrEditStarter === 'function') {
            enterViewOrEditStarter(starterId);
          }
        }


      })();
    });


    // Force-blur active input when interacting with the map (so Enter/blur commits fire)
    ['pointerdown', 'mousedown', 'touchstart'].forEach(evt => {
      graphSvg.addEventListener(evt, () => {
        const a = document.activeElement;
        if (a && (a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.tagName === 'SELECT')) a.blur();
      }, true); // capture=true to catch drags too
    });

    function cssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }
    function syncArrowColor() {
      const arrowPath = document.querySelector('#arrow path');
      if (arrowPath) arrowPath.setAttribute('fill', cssVar('--muted'));
    }
    syncArrowColor();




    (function themeInit() {
      // const btn = document.getElementById('themeToggle');
      const saved = localStorage.getItem('theme');
      const prefersDark = matchMedia && matchMedia('(prefers-color-scheme: dark)').matches;
      setTheme(saved || (prefersDark ? 'dark' : 'light'));

      // btn?.addEventListener('click', () => {

      // });


    })();

    (function studioOrGuideInit() {
      // get current run mode from HTML attribute
      const currentRunMode = getCurrentRunMode();
      if (!currentRunMode) {
        document.documentElement.setAttribute('run-mode', 'studio');
      }
    })();

    (function modeInit() {
      let btnPreview = document.getElementById('modeView');
      let btnEdit = document.getElementById('modeEdit');

      changeDataMode('view');

      btnPreview?.addEventListener('click', async () => {
        if (isDirty) {
          const ok = await confirmDialog({
            title: 'Unsaved changes',
            message: 'Preview now will discard edits.',
            confirmText: 'Discard & Preview',
            cancelText: 'Stay in Edit',
            variant: 'subtleDanger'   // ← small “danger” cue, not aggressive
          });
          if (!ok) return;                 // Stay in Edit
          else if (savedSop) {
            // if discarding, restore last saved and re-render
            sop = structuredClone(savedSop);
            renderInspector();
            renderGraph();
            renderViewStep();
            // renderAll();
          }
          clearDirty();
        }

        changeDataMode('view');



        // renderStarterMeta();
      });




      btnEdit?.addEventListener('click', () => {
        changeDataMode('edit');
      });

    })();

    // function showCurrent() {
    // }


    // function goHome() {
    //   // resetStarterValues();
    //   changeScreen('landing');
    // }

    // function goHome() {
    //   changeScreen('landing');
    //   viewState.starterIdx = -1;
    //   viewState.selectedStepId = null;

    //   try {
    //     // remove starter id
    //     const url = new URL(location.href);
    //     url.searchParams.delete('starter_id');
    //     history.replaceState({}, document.title, url.pathname + (url.search ? '?' + url.searchParams.toString() : '') + url.hash);
    //   } catch (_) {
    //     // silent no-op if URL API isn't available
    //   }
    // }



    (function screenInit() {
      // this is to initialize the data-screen="landing" or "starter" state in the top HTML


      // const saved = localStorage.getItem('screen');
      changeScreen('landing');
    })();

    (() => {
      const STORAGE_KEY = 'split:rightPanelWidth';

      const root = document.documentElement;
      const wrap = document.getElementById('editStarter');
      const split = document.getElementById('splitter');
      const right = document.getElementById('rightPanel');

      const leftMin = 260;   // must match #graphPanel min-width
      const rightMin = 180;

      let drag = false, startX = 0, startW = 0;

      const applyWidth = (px) => {
        const w = Math.max(rightMin, Math.floor(px));
        right.style.flexBasis = w + 'px';
        right.style.width = w + 'px';
        root.style.setProperty('--right-w', w + 'px');
      };

      const readSaved = () => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return null;
        const n = parseFloat(saved);
        return Number.isFinite(n) && n >= rightMin ? n : null;
      };

      const saveWidth = () => {
        if (!right) return;
        const w = right.getBoundingClientRect().width;
        if (Number.isFinite(w) && w >= rightMin) {
          localStorage.setItem(STORAGE_KEY, Math.floor(w) + 'px');
        }
      };

      // Initial restore (normal load)
      document.addEventListener('DOMContentLoaded', () => {
        const n = readSaved();
        if (n) applyWidth(n);
      });

      // Restore on back/forward cache
      window.addEventListener('pageshow', (e) => {
        // If coming from bfcache, some layouts/vars may need re-apply
        if (e.persisted) {
          const n = readSaved();
          if (n) applyWidth(n);
        }
      });

      // Save on real navigation (bfcache-friendly)
      window.addEventListener('pagehide', () => saveWidth());
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') saveWidth();
      });

      // Drag to resize
      split.addEventListener('mousedown', (e) => {
        drag = true;
        startX = e.clientX;
        startW = right.getBoundingClientRect().width;
        document.body.style.userSelect = 'none';
      });

      window.addEventListener('mousemove', (e) => {
        if (!drag) return;
        const dx = e.clientX - startX;        // left = -, right = +
        const total = wrap.clientWidth;
        let w = startW - dx;                  // dragging left grows right
        w = Math.max(rightMin, Math.min(w, total - leftMin));
        applyWidth(w);
      });

      window.addEventListener('mouseup', () => {
        if (!drag) return;
        drag = false;
        document.body.style.userSelect = '';
        saveWidth(); // persist immediately, not only on unload
      });
    })();

    // Auto-resize any embed iframe that posts its height
    (function installEmbedResizeOnce() {
      if (window.__sopEmbedResizeInstalled) return;
      window.__sopEmbedResizeInstalled = true;
      window.addEventListener('message', (e) => {
        const d = e.data;
        if (!d || !d.__sop_embed_resize) return;
        document.querySelectorAll('iframe').forEach(ifr => {
          try { if (ifr.contentWindow === e.source) ifr.style.height = Math.max(240, d.h | 0) + 'px'; } catch { }
        });
      });
    })();

    // Uses your existing: getStarter(), buildGraph(), layoutVertical(), setSelectedStepById(), navigateToStepId()

    // choose the canonical selector: your code defines navigateToStepId(nextId) later



    function changeDataMode(newDataMode) {
      if (newDataMode !== 'view' && newDataMode !== 'edit') {
        throw new Error("Invalid mode: must be 'view' or 'edit'");
      }
      document.documentElement.setAttribute('data-mode', newDataMode);
      localStorage.setItem('data-mode', newDataMode);

      // renderStarters();
      renderViewAndEditLanding()
    }

    function changeScreen(screen) {
      if (screen !== 'landing' && screen !== 'starter') {
        throw new Error("Invalid screen: must be 'landing' or 'starter'");
      }
      document.documentElement.setAttribute('screen', screen);
      localStorage.setItem('screen', screen);
    }

    function changeRunMode(runMode) {
      if (runMode !== 'studio' && runMode !== 'guide') {
        throw new Error("Invalid Run Mode: must be 'studio' or 'guide'");
      }
      document.documentElement.setAttribute('run-mode', runMode);
    }



    function on(id, ev, fn) { const el = document.getElementById(id); if (el) el.addEventListener(ev, fn); }



    function wireGlobal() {


      // document.getElementById('addBeforeBtn').addEventListener('click', () => addStepRelative('before'));
      // document.getElementById('addAfterBtn').addEventListener('click', () => addStepRelative('after'));
      // document.getElementById('dupStepBtn').addEventListener('click', dupStep);
      document.getElementById('delStepBtn').addEventListener('click', delStep);

      document.getElementById('addFreeBtn').addEventListener('click', () => {
        placingFree = true;
        ghostPos = null;
        ensureStarterStartId(getStarter());
        renderGraph();
      });




      document.getElementById('zoomInBtn').addEventListener('click', () => zoomAroundCenter(1.2));
      document.getElementById('zoomOutBtn').addEventListener('click', () => zoomAroundCenter(1 / 1.2));
      document.getElementById('zoomResetBtn').addEventListener('click', () => { resetGraphZoom(); renderGraph(); });

      document.getElementById('formatBtn').addEventListener('click', formatGraph);

      // Zoom around the viewport center (uses the same vw/vh you use in renderGraph)




      // const fsBtn = document.getElementById('fullscreenBtn');
      // fsBtn.addEventListener('click', () => {
      //   if (document.fullscreenElement === graphPanel) document.exitFullscreen();
      //   else graphPanel.requestFullscreen?.();
      // });



    }
    /*** Renderers ***/
    function renderAll() {
      renderViewAndEditLanding();
      renderViewStep();
      renderInspector();
      renderGraph();
    }


    function renderInspector() {
      const box = document.getElementById('propBox');
      const st = getStarter();
      if (!st) { box.innerHTML = '<span class="small">No starter.</span>'; return; }

      const step = st.steps.find(x => x.id === viewState.selectedStepId);
      if (!step) { box.innerHTML = '<span class="small">Select a step.</span>'; return; }

      const isInstr = step.type === 'instruction';
      const isInput = step.type === 'input';
      const isSelect = step.type === 'select';
      const isMulti = isSelect && step.mode === 'multi';
      const isSingle = isSelect && !isMulti;

      // normalize missing fields we depend on
      if (typeof step.title !== 'string') step.title = '';
      if (isSelect && !Array.isArray(step.options)) step.options = [];

      let html = `
                  <label>ID</label>
                  <input id="f_id" type="text" value="${escapeAttr(step.id)}"/>
                  <div id="f_id_err" class="error" style="display:none"></div>

                  <label>Title</label>
                  <input id="f_title" type="text" value="${escapeAttr(step.title)}"/>    
                `;

      // REPLACE your existing <div class="kv"> that contains Type with:
      html += `
              <div class="kv">
                <div>
                  <label>Type</label>
                  <select id="f_type">
                    ${['instruction', 'input', 'select'].map(t => `<option ${t === step.type ? 'selected' : ''} value="${t}">${t}</option>`).join('')}
                  </select>
                </div>
                <div>
                  ${isInput
          ? `<label>Placeholder</label>
                        <input id="f_ph" type="text" value="${escapeAttr(step.placeholder || '')}"/>`
          : isSelect
            ? `<label>Mode</label>
                          <select id="f_mode">
                            <option ${isSingle ? 'selected' : ''} value="single">single</option>
                            <option ${isMulti ? 'selected' : ''} value="multi">multi</option>
                          </select>`
            : ``
        }
                </div>
              </div>
            `;


      if (isInstr) {


        html += `
          <label>Body</label>
          <div class="rt-wrap">
            <div class="rt-toolbar">
                <button type="button" class="rt-btn" data-cmd="bold" title="Bold"><strong>B</strong></button>
                <button type="button" class="rt-btn" data-cmd="italic" title="Italic"><em>I</em></button>
                <select id="fontSizeSelect" class="rt-fs" title="Font size (pt)">
                  <option value="12" default>12 pt</option>
                  <option value="14">14 pt</option>
                  <option value="16">16 pt</option>
                  <option value="20">20 pt</option>
                  <option value="24">24 pt</option>
                  <option value="32">32 pt</option>
                </select>
                <button type="button" class="rt-btn" data-cmd="indent" title="Indent">↦</button>
                <button type="button" class="rt-btn" data-cmd="outdent" title="Outdent">↤</button>

              <button type="button" class="rt-btn" data-cmd="insertUnorderedList" title="Bulleted list">• • •</button>
              <button type="button" class="rt-btn" data-cmd="insertOrderedList" title="Numbered list">1.</button>
              <button type="button" class="rt-btn" id="rt-hl-btn" title="Highlight">HL ▾</button>

              <button type="button" class="rt-btn" id="rt-link-btn" title="Insert/edit link">🔗</button>

              <button type="button" class="rt-btn" data-cmd="attach" title="Attach file">📎</button>
              <input id="rt_attach" type="file" style="display:none">

              <button type="button" class="rt-btn" data-align="left"   title="Align left">⟸</button>
              <button type="button" class="rt-btn" data-align="center" title="Align center">⟺</button>
              <button type="button" class="rt-btn" data-align="right"  title="Align right">⟹</button>
              <!-- after the link/attach buttons -->
              <button type="button" class="rt-btn" id="rt-embed-btn" title="Embed runnable HTML">&lt;HTML/&gt;</button>




              <button id="variables-select" disabled title="No variables found" class="rt-btn">{{x}}</button>

              <button id="starters-share-select" title="Share starter link" class="rt-btn">Starters ↗</button>



              <button type="button" id="clearFmt" class="push-right rt-btn" title="Clear formatting">✖︎</button>
              </div>
              <div id="f_body" class="rt-editor" contenteditable="true">${step.body || ''}</div>
              <div class="rt-link-pop" id="rt-link-pop" hidden>
                <div class="row">
                  <input id="rt-link-url" type="text" placeholder="https://example.com">
                  <button type="button" id="rt-link-insert" class="rt-btn">Insert</button>
                </div>
              </div>
              <!-- put this sibling to #rt-link-pop -->
              <div class="rt-link-pop" id="rt-embed-pop" hidden>
                <div class="col">
                  <label class="small">Full HTML (runs in viewer)</label>
                  <textarea id="rt-embed-html" rows="8" style="width: 420px; max-width: 70vw;"></textarea>
                </div>
                <div class="row" style="gap:8px; margin-top:8px;">
                  <button type="button" id="rt-embed-insert" class="rt-btn">Insert</button>
                  <button type="button" id="rt-embed-cancel" class="rt-btn">Cancel</button>
                </div>

              </div>

            </div>
        </div>

          `;


        // upload img
        html += `
    <div class="layout">
  <div style="flex-grow:1">
    <div>
    <label>Image</label>
    <div class="img-row">
      <button id="f_img_pick" type="button" class="icon-btn ${step.img_b64 ? `hidden` : ''}" title="Upload image" aria-label="Upload image">
        <!-- upload icon -->
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3l4 4h-3v6h-2V7H8l4-4zM5 18h14v2H5z" fill="currentColor"/></svg>
      </button>

      <input id="f_img_file" type="file" accept="image/*" hidden>

      <input id="f_img" type="text" hidden class="mono small" placeholder="paste base64 data URI here" value="${escapeAttr(step.img_b64 || '')}" />

      <img id="f_img_preview" class="thumb mini ${step.img_b64 ? `` : 'hidden'}" ${step.img_b64 ? `src="${escapeAttr(step.img_b64)}"` : 'hidden'} alt="preview">

      <span id="f_img_name" class="file-name">${escapeHtml(step.img_name || '')}</span>

      <button id="f_img_clear" type="button" class="icon-btn danger ${step.img_b64 ? `` : `hidden`}" style="margin-left: auto;" title="Remove image" aria-label="Remove image" ${step.img_b64 ? '' : 'disabled'}>
        <!-- trash icon -->
      <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="100" height="100" viewBox="0 0 128 128"
      style="fill:#FA5252;">
      <path d="M 49 1 C 47.34 1 46 2.34 46 4 C 46 5.66 47.34 7 49 7 L 79 7 C 80.66 7 82 5.66 82 4 C 82 2.34 80.66 1 79 1 L 49 1 z M 24 15 C 16.83 15 11 20.83 11 28 C 11 35.17 16.83 41 24 41 L 101 41 L 101 104 C 101 113.37 93.37 121 84 121 L 44 121 C 34.63 121 27 113.37 27 104 L 27 52 C 27 50.34 25.66 49 24 49 C 22.34 49 21 50.34 21 52 L 21 104 C 21 116.68 31.32 127 44 127 L 84 127 C 96.68 127 107 116.68 107 104 L 107 40.640625 C 112.72 39.280625 117 34.14 117 28 C 117 20.83 111.17 15 104 15 L 24 15 z M 24 21 L 104 21 C 107.86 21 111 24.14 111 28 C 111 31.86 107.86 35 104 35 L 24 35 C 20.14 35 17 31.86 17 28 C 17 24.14 20.14 21 24 21 z M 50 55 C 48.34 55 47 56.34 47 58 L 47 104 C 47 105.66 48.34 107 50 107 C 51.66 107 53 105.66 53 104 L 53 58 C 53 56.34 51.66 55 50 55 z M 78 55 C 76.34 55 75 56.34 75 58 L 75 104 C 75 105.66 76.34 107 78 107 C 79.66 107 81 105.66 81 104 L 81 58 C 81 56.34 79.66 55 78 55 z"></path>
      </svg>
      </button>
    </div>
  </div>
  </div>
</div>

  `;


      }

      if (isInput) {
        html += `
      <div class="kv">
        <div>
          <label>Regex</label>
          <input id="f_regex" type="text" value="${escapeAttr(step.regex || '')}" placeholder="e.g. ^[1-9][0-9]{5}$"/>
        </div>
        <div>
          <label>Error message</label>
          <input id="f_err" type="text" value="${escapeAttr(step.error || '')}"/>
        </div>
      </div>

     
    `;
      }

      // Select specifics
      if (isSelect) {
        html += `
      <label>Options</label>
      <table class="table" id="optTable">
        <thead>
          <tr>
            <th style="width:18%">value</th>
            <th style="width:18%">label</th>
            <th>hint</th>
            ${isSingle ? '<th style="width:20%">next</th>' : ''}
            <th class="center">del</th>
          </tr>
        </thead>
        <tbody>
          ${(step.options || []).map((o, i) => optionRowHtml(o, i, st.steps, isSingle, step.id)).join('')}
        </tbody>
      </table>
      <div class="rowflex">
        <button id="addOptBtn" class="iconbtn">+ Option</button>
      </div>
    `;
      }

      // Step-level Next (instruction, input, select+multi)
      if (isInstr || isInput || isMulti) {
        html += `
    <label>${isMulti ? 'After (step.next, used for multi)' : 'Next (step.id)'}</label>
    ${nextSelectHtml(st.steps, step.next, step.id, /*withId=*/true)}
  `;
      }




      box.innerHTML = html;
      // populateVariableDropdown(st, step);


      // === Listeners ===

      // ID
      const fId = document.getElementById('f_id');
      const fIdErr = document.getElementById('f_id_err');
      fId?.addEventListener('input', () => {
        const newId = (fId.value || '').trim();
        const oldId = step.id;
        const ok = newId && !st.steps.some(s => s !== step && s.id === newId);
        fIdErr.style.display = ok ? 'none' : '';
        fIdErr.textContent = ok ? '' : (newId ? 'ID already exists.' : 'ID is required.');
        if (ok) {
          // rewriteRefs(oldId, newId);
          // step.id = newId;
          // viewState.selectedStepId = newId;
          // renderGraph();


          rewriteRefs(oldId, newId);
          step.id = newId;
          setSelectedStepById(newId);          // <-- sync id + idx
          renderGraph();


          // navigateToStepId(step.id, { record: false });


        }
      });

      // Type
      const fType = document.getElementById('f_type');
      fType?.addEventListener('change', () => {
        const t = fType.value;
        if (t !== step.type) {
          step.type = t;
          if (t === 'select'
          ) {

            step.mode = getSelectMode();
            step.options = step.options ?? [
              getDefaultOption(step)
            ];
          }
          setDirty?.(true);
          renderInspector(); // re-render to show correct controls
          renderGraph();
          renderViewStep();
        }
      });

      // Required
      const fReq = document.getElementById('f_req');
      fReq?.addEventListener('change', () => {
        step.required = !!fReq.checked;

        setDirty?.(true);
        renderViewStep();
      });

      // Title (unified)
      const fTitle = document.getElementById('f_title');
      fTitle?.addEventListener('input', () => {
        step.title = fTitle.value || '';
        setDirty?.(true);
        renderViewStep();
      });



      const bodyEl = document.getElementById('f_body');
      bodyEl?.addEventListener('input', () => {
        step.body = bodyEl.innerHTML; // save only; no re-render here
        setDirty(true);
        renderViewStep();
      });

      document.getElementById('rt-insert-embed')?.addEventListener('click', () => {
        const html = prompt('Paste FULL HTML (will run in viewer sandbox):');
        if (!html) return;

        // store raw html off-DOM
        const embId = addEmbed(step, html);

        // insert a placeholder chip in the editor content
        const label = (html.match(/<title>([^<]+)<\/title>/i)?.[1] || 'Embedded page');
        const safeLabel = label.replace(/[<>&]/g, s => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;' }[s]));
        bodyEl.focus();
        // document.execCommand('insertHTML', false,
        //   `<span class="embed-chip" contenteditable="false" data-embed-id="${embId}" title="Will render in viewer">&lt;${safeLabel}&gt;</span>`
        // );
        // inside your insert-embed click handler (editor toolbar)
        // document.execCommand(
        //   'insertHTML',
        //   false,
        //   `<span class="embed-chip" contenteditable="false" data-embed-id="${embId}">
        //               <span class="label">&lt;${safeLabel}&gt;</span>
        //               <button class="embed-del" type="button" title="Remove">×</button>
        //             </span>`
        // );

        document.execCommand(
          'insertHTML',
          false,
          `<span class="embed-chip" contenteditable="false" data-embed-id="${embId}" title="Not rendered here — will show in Preview">
     <span class="label">&lt;${safeLabel}&gt;</span>
     <button class="embed-del" type="button" title="Remove">×</button>
   </span>`
        );



        step.body = bodyEl.innerHTML;
        setDirty(true);
        renderViewStep();
      });



      // Insert raw HTML at the caret (minimal sanitize)
      // Fully replace your old insertHtmlAtCaret(html)
      function insertHtmlAtCaret(html) {
        if (!html) return;

        // 0) light sanitize: strip <script>/<style> and inline event handlers
        html = String(html)
          .replace(/<\s*(script|style)\b[^>]*>[\s\S]*?<\s*\/\s*\1\s*>/gi, '')
          .replace(/\s(on\w+)\s*=\s*(["']).*?\2/gi, ''); // onclick=...

        const editor = bodyEl || document.querySelector('.rt-editor');
        if (!editor) return;

        editor.focus();
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        let range = sel.getRangeAt(0);

        // 1) Parse HTML relative to current context (better than template for nested tags)
        let frag;
        if (range.createContextualFragment) {
          frag = range.createContextualFragment(html);
        } else {
          const t = document.createElement('template');
          t.innerHTML = html.trim();
          frag = document.createDocumentFragment();
          while (t.content.firstChild) frag.appendChild(t.content.firstChild);
        }

        // 2) If selection is inside a <p> and fragment starts with a block, split the block
        const BLOCK = /^(ADDRESS|ARTICLE|ASIDE|BLOCKQUOTE|DIV|DL|FIELDSET|FIGURE|FOOTER|FORM|H1|H2|H3|H4|H5|H6|HEADER|HR|MAIN|NAV|OL|P|PRE|SECTION|TABLE|UL)$/;
        const startEl = (range.startContainer.nodeType === 1 ? range.startContainer : range.startContainer.parentElement);
        const hostBlock = startEl?.closest('p,div,li,blockquote,pre,section,article');

        const firstNode = frag.firstChild;
        const startsWithBlock = firstNode && firstNode.nodeType === 1 && BLOCK.test(firstNode.nodeName);

        if (hostBlock && startsWithBlock) {
          // Split the host block at the caret
          const before = document.createRange();
          before.setStartBefore(hostBlock);
          before.setEnd(range.startContainer, range.startOffset);
          const beforeFrag = before.extractContents();

          const after = document.createRange();
          after.setStart(range.endContainer, range.endOffset);
          after.setEndAfter(hostBlock);
          const afterFrag = after.extractContents();

          // Rebuild: [beforeFrag][frag][afterFrag]
          const parent = hostBlock.parentNode;
          parent.insertBefore(beforeFrag, hostBlock);
          parent.insertBefore(frag, hostBlock);
          parent.insertBefore(afterFrag, hostBlock);
          hostBlock.remove();

          // place caret after the inserted content
          const last = parent.childNodes[parent.childNodes.length - 1];
          const place = frag.lastChild || parent;
          const r = document.createRange();
          r.setStartAfter(place);
          r.collapse(true);
          sel.removeAllRanges();
          sel.addRange(r);
        } else {
          // 3) Normal path: replace selection with fragment
          range.deleteContents();
          const lastNode = frag.lastChild;
          range.insertNode(frag);

          // 4) Move caret after inserted content
          range = document.createRange();
          if (lastNode && lastNode.parentNode) {
            range.setStartAfter(lastNode);
          } else {
            // fallback: after editor
            range.setStartAfter(editor.lastChild || editor);
          }
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }

        // 5) Persist + your preview
        step.body = editor.innerHTML;
        setDirty?.(true);
        renderViewStep?.();
      }

      // —— EMBED DIALOG ——
      const embedBtn = document.getElementById('rt-embed-btn');
      const embedPop = document.getElementById('rt-embed-pop');
      const embedHtmlEl = document.getElementById('rt-embed-html');
      const embedInsBtn = document.getElementById('rt-embed-insert');
      const embedCanBtn = document.getElementById('rt-embed-cancel');

      // small store helpers (no-ops if already present elsewhere)
      function ensureEmbeds(step) { if (!Array.isArray(step.embeds)) step.embeds = []; return step.embeds; }
      function addEmbed(step, html) {
        const id = 'emb_' + Math.random().toString(36).slice(2, 8);
        ensureEmbeds(step).push({ id, html }); // no baseUrl
        return id;
      }


      function closeEmbedPop() { embedPop.hidden = true; }

      embedBtn?.addEventListener('mousedown', e => e.preventDefault());
      embedBtn?.addEventListener('click', () => {
        bodyEl.focus();
        saveSelection();
        // clear last values
        embedHtmlEl.value = '';
        // open near caret
        showPopupNearSelection(embedPop, wrap, bodyEl);
        embedPop.hidden = false;
        embedHtmlEl.focus();
      });

      embedCanBtn?.addEventListener('click', closeEmbedPop);

      // Insert the embed chip at caret and store raw HTML in step.embeds
      embedInsBtn?.addEventListener('click', () => {
        const raw = (embedHtmlEl.value || '').trim();
        if (!raw) { embedHtmlEl.focus(); return; }

        // store full HTML off-DOM (no baseUrl anymore)
        const embId = addEmbed(step, raw);

        const label = (raw.match(/<title>([^<]+)<\/title>/i)?.[1] || 'Embedded page')
          .replace(/[<>&]/g, s => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;' }[s]));

        restoreSelectionOrFocus();
        document.execCommand('insertHTML', false,
          `<span class="embed-chip" contenteditable="false" data-embed-id="${embId}">
       <span class="label">&lt;${label}&gt;</span>
       <button class="embed-del" type="button" title="Remove">×</button>
     </span>`
        );

        step.body = bodyEl.innerHTML;
        setDirty?.(true);
        renderViewStep?.();
        embedPop.hidden = true;
      });


      // click-outside closes popup (mirrors your link popup behavior)
      document.addEventListener('mousedown', (e) => {
        if (!embedPop) return;
        if (!embedPop.hidden && !embedPop.contains(e.target) && e.target !== embedBtn) {
          closeEmbedPop();
        }
      });


      // Build an iframe srcdoc that runs the embed + fixes relative URLs + auto-resizes







      document.execCommand('defaultParagraphSeparator', false, 'p');

      const wrap = bodyEl?.closest('.rt-wrap');
      const toolbar = wrap ? wrap.querySelector('.rt-toolbar') : null;
      const attachInput = wrap ? wrap.querySelector('#rt_attach') : null;


      document.getElementById('clearFmt')?.addEventListener('click', () => {
        bodyEl.focus();

        // 1) strip inline formatting
        document.execCommand('selectAll');
        document.execCommand('removeFormat');

        // 2) unwrap links
        bodyEl.querySelectorAll('a').forEach(a => a.replaceWith(document.createTextNode(a.textContent)));

        // 3) remove lists → turn each <li> into a <p>
        bodyEl.querySelectorAll('ul,ol').forEach(list => {
          const frag = document.createDocumentFragment();
          list.querySelectorAll('li').forEach(li => {
            const p = document.createElement('p');
            p.textContent = li.textContent; // plain text
            frag.appendChild(p);
          });
          list.replaceWith(frag);
        });

        // 4) convert blockquote to plain paragraphs (blockquote adds indent)
        bodyEl.querySelectorAll('blockquote').forEach(bq => {
          const p = document.createElement('p');
          p.innerHTML = bq.innerHTML;
          bq.replaceWith(p);
        });

        // 5) clear block-level indent/alignment
        bodyEl.querySelectorAll('p, div, li, blockquote').forEach(el => {
          el.style.marginLeft = '';
          el.style.paddingLeft = '';
          el.style.textIndent = '';
          el.style.textAlign = '';
        });

        // 6) normalize root (ensures only <p> at root + default size)
        normalizeEditorRoot(); // uses your existing function
        const defaultPx = (typeof getDefaultPx === 'function') ? getDefaultPx() : 16;
        bodyEl.querySelectorAll('p').forEach(p => p.style.fontSize = defaultPx + 'px');

        // 7) persist
        step.body = bodyEl.innerHTML;
        setDirty(true);
        renderViewStep();
      });

      // Font size dropdown: applies inline <span style="font-size:...">
      document.getElementById('fontSizeSelect')?.addEventListener('change', (e) => {
        bodyEl.focus();

        const pt = e.target.value;
        if (!pt) return;
        const px = Math.round(pt * 96 / 72); // pt to px

        const blocks = getBlocksInSelection();
        blocks.forEach(el => {
          el.style.fontSize = px + 'px';                 // apply to the whole line
          el.querySelectorAll('[style*="font-size"]').forEach(n => n.style.fontSize = ''); // clear inline leftovers
        });
        step.body = bodyEl.innerHTML;
        renderViewStep();

      });



      //   function openVariablesMenu(anchorBtn) {
      //     // prevent duplicates (reuse the same overlay id you're using elsewhere)
      //     if (document.getElementById('settingsOverlay')) return;

      //     // Get the current starter/step + candidates (from expando or recompute)
      //     const starter = getStarter?.();
      //     const curStep = starter?.steps.find(s => s.id === viewState?.selectedStepId);
      //     const list = anchorBtn._varsCandidates || getVariableCandidates(starter, curStep);

      //     // overlay (click outside to close)
      //     const overlay = document.createElement('div');
      //     overlay.id = 'settingsOverlay';
      //     overlay.className = 'settings-overlay';

      //     // panel
      //     const panel = document.createElement('div');
      //     panel.className = 'settings-panel';
      //     panel.style.minWidth = '220px';   // was ~auto; gives IDs some breathing room


      //     // ---- content: VARIABLES ONLY (read-only) ----
      //     let bodyHtml = '';
      //     if (!list || list.length === 0) {
      //       bodyHtml = `<div class="settings-empty" style="padding:8px 10px;opacity:.7">— No inputs/selects available —</div>`;
      //     } else {
      //       //   bodyHtml = list.map(s => {
      //       //     // visual: left = raw id (no {{ }}), right = (input) or (select)
      //       //     return `
      //       // <div class="settings-item" data-var="${s.id}"
      //       //      style="display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 10px;">
      //       //   <span class="mono" style="user-select:text">${s.id}</span>
      //       //   <span class="small" style="opacity:.7">(${s.type})</span>
      //       // </div>`;
      //       //   }).join('');
      //       bodyHtml = list.map(s => {
      //         return `
      // <div class="settings-item" data-var="${s.id}">
      //   <span class="mono var-id">${s.id}</span>
      //   <span class="small var-type">(${s.type})</span>
      // </div>`;
      //       }).join('');
      //     }

      //     panel.innerHTML = bodyHtml; // no "Variables" title, just the list

      //     // place panel near the anchor button
      //     document.body.appendChild(overlay);
      //     document.body.appendChild(panel);
      //     const rect = anchorBtn.getBoundingClientRect();
      //     const top = rect.bottom + 6 + window.scrollY;
      //     const left = Math.min(
      //       rect.left + window.scrollX,
      //       window.scrollX + document.documentElement.clientWidth - panel.offsetWidth - 12
      //     );
      //     panel.style.top = `${top}px`;
      //     panel.style.left = `${left}px`;

      //     // handlers (no item action for now; just close on outside/esc)
      //     const onOutside = (e) => { if (e.target === overlay) cleanup(); };
      //     const onEsc = (e) => { if (e.key === 'Escape') cleanup(); };

      //     overlay.addEventListener('click', onOutside);
      //     document.addEventListener('keydown', onEsc);

      //     function cleanup() {
      //       overlay.removeEventListener('click', onOutside);
      //       document.removeEventListener('keydown', onEsc);
      //       panel.remove();
      //       overlay.remove();
      //     }
      //   }

      function openVariablesMenu(anchorBtn) {
        // prevent duplicates (reuse your settings overlay id)
        if (document.getElementById('settingsOverlay')) return;

        // --- capture caret BEFORE opening (so we can restore later) ---
        const editor = getBodyEditorEl();          // your rich-text body
        let savedRange = null;
        if (editor) {
          const sel = window.getSelection();
          if (sel && sel.rangeCount && editor.contains(sel.anchorNode)) {
            savedRange = sel.getRangeAt(0).cloneRange(); // snapshot current caret/selection
          }
        }

        // pull cached candidates from the button (set in renderInspector), or recompute
        const starter = getStarter?.();
        const curStep = starter?.steps.find(s => s.id === viewState?.selectedStepId);
        const list = anchorBtn._varsCandidates || getVariableCandidates(starter, curStep);

        // overlay (click outside to close)
        const overlay = document.createElement('div');
        overlay.id = 'settingsOverlay';
        overlay.className = 'settings-overlay';

        // panel
        const panel = document.createElement('div');
        panel.className = 'settings-panel';
        panel.style.minWidth = '320px';

        // list UI (no header, no braces)
        let bodyHtml = '';
        if (!list || list.length === 0) {
          bodyHtml = `<div class="settings-empty" style="padding:8px 10px;opacity:.7">— No inputs/selects available —</div>`;
        } else {
          bodyHtml = list.map(s => `
      <div class="settings-item" data-var="${s.id}"
           style="display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px 10px;">
        <span class="mono var-id" style="min-width:0;overflow-wrap:anywhere;word-break:break-word;">${s.id}</span>
        <span class="small var-type" style="white-space:nowrap;opacity:.7">(${s.type})</span>
      </div>
    `).join('');
        }
        panel.innerHTML = bodyHtml;

        // place panel near the anchor button
        document.body.appendChild(overlay);
        document.body.appendChild(panel);
        const rect = anchorBtn.getBoundingClientRect();
        const top = rect.bottom + 6 + window.scrollY;
        const left = Math.min(
          rect.left + window.scrollX,
          window.scrollX + document.documentElement.clientWidth - panel.offsetWidth - 12
        );
        panel.style.top = `${top}px`;
        panel.style.left = `${left}px`;

        // --- handlers ---
        const onItemClick = (e) => {
          const row = e.target.closest('.settings-item');
          if (!row) return;

          const id = row.getAttribute('data-var') || '';
          if (!id) return;

          const token = `{{${id}}}`;

          if (editor) {
            editor.focus();
            const sel = window.getSelection();
            sel.removeAllRanges();

            // restore saved range if it's still inside the editor; else move to end
            if (savedRange && editor.contains(savedRange.commonAncestorContainer)) {
              sel.addRange(savedRange);
            } else {
              const r = document.createRange();
              r.selectNodeContents(editor);
              r.collapse(false);
              sel.addRange(r);
            }

            // insert at caret (replace selection if any)
            const r = sel.getRangeAt(0);
            r.deleteContents();
            const node = document.createTextNode(token);
            r.insertNode(node);
            // place caret right after inserted token
            r.setStartAfter(node);
            r.collapse(true);
            sel.removeAllRanges();
            sel.addRange(r);
          }

          cleanup();
          setDirty?.(true);
        };

        const onOutside = (e) => { if (e.target === overlay) cleanup(); };
        const onEsc = (e) => { if (e.key === 'Escape') cleanup(); };

        panel.addEventListener('click', onItemClick);
        overlay.addEventListener('click', onOutside);
        document.addEventListener('keydown', onEsc);

        function cleanup() {
          panel.removeEventListener('click', onItemClick);
          overlay.removeEventListener('click', onOutside);
          document.removeEventListener('keydown', onEsc);
          panel.remove();
          overlay.remove();
        }

        // --- tiny local helpers (kept here for clarity) ---
        function getBodyEditorEl() {
          return document.getElementById('f_body')
            || document.querySelector('[data-field="body"]')
            || document.querySelector('.rt-body')
            || document.querySelector('[contenteditable][data-rich="body"]');
        }
      }

      function openStartersMenu(anchorBtn) {
        // prevent duplicates
        if (document.getElementById('settingsOverlay')) return;

        // capture caret before menu opens
        const editor = getBodyEditorEl();
        let savedRange = null;
        if (editor) {
          const sel = window.getSelection();
          if (sel && sel.rangeCount && editor.contains(sel.anchorNode)) {
            savedRange = sel.getRangeAt(0).cloneRange();
          }
        }

        // build starter list excluding current
        const all = Array.isArray(sop?.starters) ? sop.starters : [];
        const cur = getStarter?.();
        const curId = cur?.id;
        const list = all.filter(s => s?.id && s.id !== curId);

        // overlay + panel
        const overlay = document.createElement('div');
        overlay.id = 'settingsOverlay';
        overlay.className = 'settings-overlay';

        const panel = document.createElement('div');
        panel.className = 'settings-panel';
        panel.style.minWidth = '320px';

        panel.innerHTML = (list.length
          ? list.map(s => `
        <div class="settings-item" data-starter-id="${s.id}">
          <span class="mono" style="min-width:0;overflow-wrap:anywhere;">${s.label || s.id}</span>
          <span class="small" style="opacity:.7">(${s.id})</span>
        </div>
      `).join('')
          : `<div class="settings-empty" style="padding:8px 10px;opacity:.7">— No other starters —</div>`
        );

        document.body.appendChild(overlay);
        document.body.appendChild(panel);

        // position near button
        const rect = anchorBtn.getBoundingClientRect();
        const top = rect.bottom + 6 + window.scrollY;
        const left = Math.min(
          rect.left + window.scrollX,
          window.scrollX + document.documentElement.clientWidth - panel.offsetWidth - 12
        );
        panel.style.top = `${top}px`;
        panel.style.left = `${left}px`;

        // item click → insert link
        panel.addEventListener('click', (e) => {
          const row = e.target.closest('.settings-item');
          if (!row) return;

          const sid = row.getAttribute('data-starter-id');
          if (!sid) return;

          // build full link ?starter_id=<sid>
          const url = new URL(location.href);
          url.searchParams.set('starter_id', sid);
          const full = url.origin + url.pathname + '?' + url.searchParams.toString() + url.hash;

          if (editor) {
            editor.focus();
            const sel = window.getSelection();
            sel.removeAllRanges();

            // restore caret if still valid; else move to end
            if (savedRange && editor.contains(savedRange.commonAncestorContainer)) {
              sel.addRange(savedRange);
            } else {
              const r = document.createRange();
              r.selectNodeContents(editor);
              r.collapse(false);
              sel.addRange(r);
            }

            // insert <a> with title showing full URL
            // const a = document.createElement('a');
            // a.href = full;
            // a.className = 'clickable-link';
            // a.title = full;
            // a.target = '_blank';
            // a.rel = 'noopener noreferrer';

            // // label fallback to id
            // const label = list.find(s => s.id === sid)?.label || sid;
            // a.textContent = label;

            const a = document.createElement('a');
            a.className = 'clickable-link';
            a.dataset.starterId = sid;                  // the dynamic bit you care about
            a.href = `?starter_id=${encodeURIComponent(sid)}`; // relative, portable
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            a.title = a.href; // will show "?starter_id=…"
            const label = list.find(s => s.id === sid)?.label || sid;

            a.textContent = label; // whatever label you want


            const r = sel.getRangeAt(0);
            r.deleteContents();
            r.insertNode(a);
            r.setStartAfter(a);
            r.collapse(true);
            sel.removeAllRanges();
            sel.addRange(r);

            persistEditor?.();
            // setDirty?.(true);
          }

          cleanup();
          setDirty?.(true);
        });

        const onOutside = (e) => { if (e.target === overlay) cleanup(); };
        const onEsc = (e) => { if (e.key === 'Escape') cleanup(); };
        overlay.addEventListener('click', onOutside);
        document.addEventListener('keydown', onEsc);

        function cleanup() {
          overlay.removeEventListener('click', onOutside);
          document.removeEventListener('keydown', onEsc);
          panel.remove();
          overlay.remove();
        }

        function getBodyEditorEl() {
          return document.getElementById('f_body')
            || document.querySelector('[data-field="body"]')
            || document.querySelector('.rt-body')
            || document.querySelector('[contenteditable][data-rich="body"]');
        }
      }


      // Return earlier steps (ancestors) that are input/select
      function getVariableCandidates(starter, currentStep) {
        if (!starter || !currentStep) return [];
        const pred = buildPredecessors(starter);
        const seen = new Set([currentStep.id]);
        const stack = [currentStep.id];
        const out = [];
        while (stack.length) {
          const id = stack.pop();
          const ps = pred[id]; if (!ps) continue;
          for (const p of ps) if (!seen.has(p)) {
            seen.add(p);
            out.push(p);
            stack.push(p);
          }
        }
        // map to step objects and filter input/select
        const byId = Object.fromEntries(starter.steps.map(s => [s.id, s]));
        return out.map(id => byId[id]).filter(s => s && (s.type === 'input' || s.type === 'select'));
      }





      // Small palette (includes your current #F7B733)
      // const HL_COLORS = ['#F7B733', '#FFE066', '#7FDBFF', '#B5E48C', '#CDB4DB', '#FFADAD'];

      // const HL_COLORS = ['#FACC15', '#EF4444', '#3B82F6', '#22C55E'];
      // const HL_COLORS = ['#E9B949', '#E24A3A', '#2F5FE3', '#17A773'];
      // const HL_COLORS = ['#f1ba40', '#5ecd8c', '#4191dd', '#c03c37'];

      // const HL_COLORS = ['#cc9e36', '#4fae77', '#377bbb', '#a3332e'];

      // this is good
      // const HL_COLORS = ['#f1ba40', '#4fae77', '#377bbb', '#c03c37'];
      // const HL_COLORS = ['#f1ba40', '#f6d283', '#4fae77', '#8dcaa7', '#377bbb', '#7da9d3', '#c03c37', '#d6807d'];
      const HL_COLORS = ['#F6D283', '#8DCAA7', '#7DA9D3', '#D6807D'];



      function openHighlightMenu(anchorBtn, bodyEl) {
        // avoid duplicate panels
        if (document.getElementById('settingsOverlay')) return;

        // figure out which command this browser supports
        const HL_CMD = document.queryCommandSupported('hiliteColor') ? 'hiliteColor' : 'backColor';

        // snapshot selection BEFORE opening (clicking the menu will steal focus)
        let savedRange = null;
        if (bodyEl?.isContentEditable) {
          const sel = window.getSelection();
          if (sel && sel.rangeCount && bodyEl.contains(sel.anchorNode)) {
            savedRange = sel.getRangeAt(0).cloneRange();
          }
        }

        // overlay + panel (reuse your settings styles)
        const overlay = document.createElement('div');
        overlay.id = 'settingsOverlay';
        overlay.className = 'settings-overlay';

        const panel = document.createElement('div');
        panel.className = 'settings-panel';
        // pandel.style.minWidth = '160px';
        // display: flex; flex-direction: column; gap: 3px

        // build items using your .settings-item
        const colorItems = HL_COLORS.map(c => `
    <button class="settings-item" data-color="${c}">
      <span style="
        width:18px;height:18px;border-radius:4px;border:1px solid rgba(0,0,0,.2);
        background:${c}; display:inline-block; margin-right:8px; vertical-align:middle;"></span>
      <span>${c}</span>
    </button>
  `).join('');

        const clearItem = `
    <button class="settings-item" data-clear>
      Remove highlight
    </button>
  `;

        panel.innerHTML = colorItems + clearItem;

        document.body.appendChild(overlay);
        document.body.appendChild(panel);

        // position under the button (like your other menu)
        const rect = anchorBtn.getBoundingClientRect();
        const top = rect.bottom + 6 + window.scrollY;
        const left = Math.min(
          rect.left + window.scrollX,
          window.scrollX + document.documentElement.clientWidth - panel.offsetWidth - 12
        );
        panel.style.top = `${top}px`;
        panel.style.left = `${left}px`;

        // --- helpers ---
        function restoreSelection() {
          if (!bodyEl) return false;
          bodyEl.focus();
          const sel = window.getSelection();
          sel.removeAllRanges();

          if (savedRange && bodyEl.contains(savedRange.commonAncestorContainer)) {
            sel.addRange(savedRange);
          } else {
            // fallback to end of editor (but will be collapsed → we’ll no-op)
            const r = document.createRange();
            r.selectNodeContents(bodyEl);
            r.collapse(false);
            sel.addRange(r);
          }
          return !sel.isCollapsed;
        }

        function applyColor(color) {
          if (!restoreSelection()) { cleanup(); return; }

          const fg = cssVar('--hl-fg') || '#0B1220';  // fallback if var missing

          document.execCommand('styleWithCSS', false, true);
          document.execCommand(HL_CMD, false, color); // background
          document.execCommand('foreColor', false, fg); // text color from :root
          // document.execCommand('foreColor', false, cssVar('--hl-fg')); // fg via var
          // tagSelectionWithClass('hl-fg');

          if (typeof step !== 'undefined') {
            step.body = bodyEl.innerHTML;
            setDirty?.(true);
            renderViewStep?.();
          }
          cleanup();
        }

        function applyHighlightFg() {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0 || sel.isCollapsed) return;
          const range = sel.getRangeAt(0);

          const span = document.createElement('span');
          span.className = 'hl-fg';

          try {
            range.surroundContents(span);     // clean split at boundaries
          } catch {
            // fallback for mixed/partial selections
            const frag = range.extractContents();
            span.appendChild(frag);
            range.insertNode(span);
            // place caret after
            sel.removeAllRanges();
            const r = document.createRange();
            r.setStartAfter(span); r.collapse(true);
            sel.addRange(r);
          }
        }


        function tagSelectionWithClass(cls) {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0) return;
          const range = sel.getRangeAt(0);
          if (range.collapsed) return;

          const wrapper = document.createElement('span');
          wrapper.className = cls;

          try {
            // cleanly splits wrappers at boundaries
            range.surroundContents(wrapper);
          } catch {
            // robust fallback for partially-selectable ranges
            const frag = range.extractContents();
            wrapper.appendChild(frag);
            range.insertNode(wrapper);
            // place caret after wrapper
            sel.removeAllRanges();
            const after = document.createRange();
            after.setStartAfter(wrapper); after.collapse(true); sel.addRange(after);
          }
        }




        // Choose black/white text that reads on a given hex/bg (handles #RGB/#RRGGBB)
        function readableTextOn(bg) {
          const hex = String(bg).replace('#', '').trim();
          const h = hex.length === 3
            ? hex.split('').map(ch => ch + ch).join('')
            : hex.padEnd(6, '0').slice(0, 6);
          const r = parseInt(h.slice(0, 2), 16) / 255;
          const g = parseInt(h.slice(2, 4), 16) / 255;
          const b = parseInt(h.slice(4, 6), 16) / 255;
          // WCAG-ish relative luminance
          const L = 0.2126 * Math.pow(r, 2.2) + 0.7152 * Math.pow(g, 2.2) + 0.0722 * Math.pow(b, 2.2);
          return (L > 0.55) ? '#0F172A' : '#FFFFFF'; // dark slate on light bg, white on dark bg
        }



        // function clearHighlight() {

        function clearHighlight() {
          if (!restoreSelection()) { cleanup(); return; }

          // clear background
          document.execCommand(HL_CMD, false, 'transparent');
          const editor = bodyEl || getBodyEditorEl();
          const def = getComputedStyle(editor).color;   // theme default
          document.execCommand('styleWithCSS', false, true);
          document.execCommand('foreColor', false, def);
          // scrubBgInSelection?.();

          // clear any forced foreground color (in-range + ancestor chain)
          // const editor = bodyEl || getBodyEditorEl();
          // clearInlineFgInRange(editor);
          // clearColorUpwardsFromRangeEdges(editor);
          // normalizeInlineColorArtifacts(editor);

          if (typeof step !== 'undefined') {
            step.body = editor.innerHTML;
            setDirty?.(true);
            renderViewStep?.();
          }
          cleanup();
        }


        // Walk elements intersecting the selection and clear inline color
        function clearInlineFgInRange(editor) {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0) return;
          const range = sel.getRangeAt(0);

          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                (editor.contains(el) && range.intersectsNode(el))
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );

          const hits = [];
          while (walker.nextNode()) {
            const el = walker.currentNode;
            if (!el) continue;
            if (el.style && el.style.color) hits.push(el);
            if (el.tagName === 'FONT' && el.hasAttribute('color')) hits.push(el);
          }
          hits.forEach(el => {
            if (el.style) el.style.color = '';
            if (el.tagName === 'FONT') el.removeAttribute('color');
          });
        }

        // If a parent (outside the range) holds the color, clear it going upward from both ends
        function clearColorUpwardsFromRangeEdges(editor) {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0) return;
          const range = sel.getRangeAt(0);

          clearUp(range.startContainer);
          clearUp(range.endContainer);

          function clearUp(node) {
            let el = node.nodeType === 1 ? node : node.parentElement;
            while (el && el !== editor && el !== document.body) {
              // break if we hit a block (don’t blast layout-wide styles)
              const disp = getComputedStyle(el).display;
              const isBlockish = disp === 'block' || disp === 'list-item' || disp === 'table';
              if (isBlockish) break;

              if (el.style && el.style.color) {
                el.style.color = '';
                // if style attr is empty now, remove it
                if (!el.getAttribute('style')) el.removeAttribute('style');
              }
              if (el.tagName === 'FONT' && el.hasAttribute('color')) {
                el.removeAttribute('color');
              }
              el = el.parentElement;
            }
          }
        }

        // Clean up spans/fonts that no longer do anything
        function normalizeInlineColorArtifacts(editor) {
          // unwrap <font> without attributes
          editor.querySelectorAll('font').forEach(f => {
            if (f.attributes.length === 0) {
              while (f.firstChild) f.parentNode.insertBefore(f.firstChild, f);
              f.remove();
            }
          });
          // drop empty style="" attrs
          editor.querySelectorAll('[style]').forEach(el => {
            if (el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          });
        }

        function cssVar(name, el = document.documentElement) {
          return getComputedStyle(el).getPropertyValue(name).trim();
        }


        // helper: visit elements intersecting current range within root
        function walkElementsIntersecting(root, range, fn) {
          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                root.contains(el) && range.intersectsNode(el)
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );
          while (walker.nextNode()) fn(walker.currentNode);
        }


        // ---- tiny utilities ----
        function walkElementsIntersecting(root, range, fn) {
          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                root.contains(el) && range.intersectsNode(el)
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );
          while (walker.nextNode()) fn(walker.currentNode);
        }

        function cssVar(name, el = document.documentElement) {
          return getComputedStyle(el).getPropertyValue(name).trim();
        }

        function normalizeColor(val) {
          if (!val) return '';
          const probe = document.createElement('span');
          probe.style.color = val;
          document.body.appendChild(probe);
          const out = getComputedStyle(probe).color || '';
          document.body.removeChild(probe);
          return out;
        }


        // function clearHighlight() {
        //   if (!restoreSelection()) return;

        //   const editor = bodyEl || getBodyEditorEl();
        //   if (!editor) return;

        //   const sel = window.getSelection();
        //   if (!sel || sel.rangeCount === 0) return;
        //   const range = sel.getRangeAt(0);

        //   // collapsed: clear inline on nearest inline wrapper only
        //   if (range.collapsed) {
        //     // clearPropsUpwards(editor, range.startContainer, ['backgroundColor', 'color']);
        //   } else {

        //     // 1) nuke execCommand bg if present (harmless if none)
        //     document.execCommand(HL_CMD, false, 'transparent');

        //     // 2) extract selected HTML
        //     const frag = range.extractContents();

        //     // 3) scrub only the selected part
        //     scrubFragmentStyles(frag);     // remove bg/fg inside the selection
        //     unwrapTrivialSpans(frag);      // drop empty wrappers

        //     // 4) insert a container so we can lift it out of colored parents
        //     const holder = document.createElement('span');
        //     holder.appendChild(frag);
        //     range.insertNode(holder);

        //     // 5) move holder out of any ancestor that forces color/bg
        //     liftOutOfColoredAncestors(editor, holder);

        //     // 6) replace holder with its children
        //     while (holder.firstChild) holder.parentNode.insertBefore(holder.firstChild, holder);
        //     holder.remove();
        //   }

        //   // tidy + persist
        //   cleanupInlineArtifacts(editor);
        //   if (typeof step !== 'undefined') {
        //     step.body = editor.innerHTML;
        //     setDirty?.(true);
        //     renderViewStep?.();
        //   }
        // }

        // remove inline bg/fg (and <font color>) within a detached fragment
        function scrubFragmentStyles(rootFragment) {
          const walker = document.createTreeWalker(rootFragment, NodeFilter.SHOW_ELEMENT);
          const nodes = [];
          while (walker.nextNode()) nodes.push(walker.currentNode);

          nodes.forEach(el => {
            if (el.style) {
              if (el.style.backgroundColor) el.style.backgroundColor = '';
              if (el.style.color) el.style.color = '';
              if (el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
            }
            if (el.tagName === 'FONT') el.removeAttribute('color');
          });
        }

        // unwrap spans/fonts that became inert inside the fragment
        function unwrapTrivialSpans(rootFragment) {
          const candidates = rootFragment.querySelectorAll('span,font');
          candidates.forEach(el => {
            if (!el.attributes || el.attributes.length === 0) {
              const parent = el.parentNode;
              while (el.firstChild) parent.insertBefore(el.firstChild, el);
              parent.removeChild(el);
            }
          });
        }


        function clearPropsInRange(root, range, props) {
          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                root.contains(el) && range.intersectsNode(el)
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );
          while (walker.nextNode()) {
            const el = walker.currentNode;
            if (el.style) props.forEach(p => { if (el.style[p]) el.style[p] = ''; });
            if (el.tagName === 'FONT') el.removeAttribute('color');
            if (el.getAttribute && el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          }
        }

        function liftOutOfColoredAncestors(root, node) {
          let cur = node;
          while (cur && cur.parentElement && cur.parentElement !== root && cur.parentElement !== document.body) {
            const p = cur.parentElement;
            const styled = (p.style && (p.style.color || p.style.backgroundColor)) || (p.tagName === 'FONT' && p.hasAttribute('color'));
            if (!styled) break;
            p.parentNode.insertBefore(cur, p.nextSibling);         // move node after the colored parent
            if (!p.firstChild) p.remove();                         // drop empty wrappers
          }
        }

        // walk up from a boundary and clear inline styles on inline wrappers only
        function clearPropsUpwards(root, fromNode, props) {
          let el = fromNode && (fromNode.nodeType === 1 ? fromNode : fromNode.parentElement);
          while (el && el !== root && el !== document.body) {
            const disp = getComputedStyle(el).display;
            if (disp === 'block' || disp === 'list-item' || disp === 'table') break; // stop at blocks
            if (el.style) {
              props.forEach(p => { if (el.style[p]) el.style[p] = ''; });
              if (el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
            }
            if (el.tagName === 'FONT') el.removeAttribute('color');
            el = el.parentElement;
          }
        }

        function cleanupInlineArtifacts(root) {
          // unwrap empty <font> tags
          root.querySelectorAll('font').forEach(f => {
            if (f.attributes.length === 0) {
              while (f.firstChild) f.parentNode.insertBefore(f.firstChild, f);
              f.remove();
            }
          });
          // drop empty style=""
          root.querySelectorAll('[style]').forEach(el => {
            if (el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          });
        }


        function sameColorInline(inlineValue, targetCssColor) {
          if (!inlineValue) return false;
          // normalize both to rgb() via a test element
          const probe = document.createElement('div');
          document.body.appendChild(probe);
          probe.style.color = targetCssColor;
          const want = getComputedStyle(probe).color; // rgb(...)
          probe.style.color = '';
          probe.style.color = inlineValue;
          const got = getComputedStyle(probe).color;  // rgb(...)
          document.body.removeChild(probe);
          return got === want;
        }

        function scrubInlineStyles(editor, range, hlBg, hlFg) {
          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                editor.contains(el) && range.intersectsNode(el)
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );
          const toClear = [];
          while (walker.nextNode()) toClear.push(walker.currentNode);

          toClear.forEach(el => {
            // clear highlight bg if it matches our applied one
            if (sameColorInline(el.style.backgroundColor, hlBg)) el.style.backgroundColor = '';
            // clear fg if it matches our applied highlight fg (dark mode-safe)
            if (sameColorInline(el.style.color, hlFg)) el.style.color = '';
            if (el.tagName === 'FONT') el.removeAttribute('color');
            if (el.getAttribute && el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          });
        }

        function clearAncestorHighlight(editor, node, hlBg, hlFg) {
          let el = node && (node.nodeType === 1 ? node : node.parentElement);
          while (el && el !== editor && el !== document.body) {
            // stop at blocks—highlight is inline decoration
            const disp = getComputedStyle(el).display;
            if (disp === 'block' || disp === 'list-item' || disp === 'table') break;

            let changed = false;
            if (sameColorInline(el.style.backgroundColor, hlBg)) {
              el.style.backgroundColor = ''; changed = true;
            }
            if (sameColorInline(el.style.color, hlFg)) {
              el.style.color = ''; changed = true;
            }
            if (changed && el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
            el = el.parentElement;
          }
        }


        function scrubInlineStylesInSelection(root, styleProps) {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0 || !root) return;
          const range = sel.getRangeAt(0);

          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                root.contains(el) && range.intersectsNode(el)
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );

          const toClear = [];
          while (walker.nextNode()) {
            toClear.push(walker.currentNode);
          }

          toClear.forEach(el => {
            // strip inline bg/fg so theme defaults take over (dark mode-safe)
            styleProps.forEach(p => { if (el.style && el.style[p]) el.style[p] = ''; });
            if (el.tagName === 'FONT') el.removeAttribute('color');
            if (el.getAttribute && el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          });
        }

        // Walk elements intersecting the selection and clear inline color
        function clearInlineFgInRange(editor) {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0) return;
          const range = sel.getRangeAt(0);

          // helper: is the whole node inside the range?
          const fullyCovers = (node) => {
            const r = document.createRange();
            try { r.selectNodeContents(node); } catch { return false; }
            return (
              range.compareBoundaryPoints(Range.START_TO_START, r) <= 0 &&
              range.compareBoundaryPoints(Range.END_TO_END, r) >= 0
            );
          };

          const walker = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_ELEMENT,
            {
              acceptNode: (el) =>
                (editor.contains(el) && range.intersectsNode(el) && fullyCovers(el))
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_SKIP
            }
          );

          const hits = [];
          while (walker.nextNode()) {
            const el = walker.currentNode;
            if (!el) continue;
            if ((el.style && el.style.color) || (el.tagName === 'FONT' && el.hasAttribute('color'))) {
              hits.push(el);
            }
          }

          hits.forEach(el => {
            if (el.style) el.style.color = '';
            if (el.tagName === 'FONT') el.removeAttribute('color');
            if (el.getAttribute && el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          });
        }


        // If a parent (outside the range) holds the color, clear it going upward from both ends
        function clearColorUpwardsFromRangeEdges(editor) {
          const sel = window.getSelection();
          if (!sel || sel.rangeCount === 0) return;
          const range = sel.getRangeAt(0);

          const fullyCovers = (node) => {
            const r = document.createRange();
            try { r.selectNodeContents(node); } catch { return false; }
            return (
              range.compareBoundaryPoints(Range.START_TO_START, r) <= 0 &&
              range.compareBoundaryPoints(Range.END_TO_END, r) >= 0
            );
          };

          // Only clear an ancestor if the selection fully covers that element.
          [range.startContainer, range.endContainer].forEach(startNode => {
            let el = startNode && (startNode.nodeType === 1 ? startNode : startNode.parentElement);
            while (el && el !== editor && el !== document.body) {
              const disp = getComputedStyle(el).display;
              const isBlockish = disp === 'block' || disp === 'list-item' || disp === 'table';
              if (isBlockish) break;

              if (fullyCovers(el)) {
                if (el.style && el.style.color) {
                  el.style.color = '';
                  if (!el.getAttribute('style')) el.removeAttribute('style');
                }
                if (el.tagName === 'FONT' && el.hasAttribute('color')) {
                  el.removeAttribute('color');
                }
                // continue walking up in case higher inline wrappers are fully covered too
                el = el.parentElement;
              } else {
                // stop at the first partially covered ancestor to avoid stripping neighbors
                break;
              }
            }
          });
        }


        // Clean up spans/fonts that no longer do anything
        function normalizeInlineColorArtifacts(editor) {
          // unwrap <font> without attributes
          editor.querySelectorAll('font').forEach(f => {
            if (f.attributes.length === 0) {
              while (f.firstChild) f.parentNode.insertBefore(f.firstChild, f);
              f.remove();
            }
          });
          // drop empty style="" attrs
          editor.querySelectorAll('[style]').forEach(el => {
            if (el.getAttribute('style')?.trim() === '') el.removeAttribute('style');
          });
        }

        function cssVar(name, el = document.documentElement) {
          return getComputedStyle(el).getPropertyValue(name).trim();
        }





        // --- events ---
        panel.addEventListener('click', (e) => {
          const btn = e.target.closest('.settings-item');
          if (!btn) return;
          const clr = btn.getAttribute('data-color');
          if (clr) { applyColor(clr); return; }
          if (btn.hasAttribute('data-clear')) { clearHighlight(); return; }
        });

        overlay.addEventListener('click', cleanup);
        document.addEventListener('keydown', onEsc);

        function onEsc(e) { if (e.key === 'Escape') cleanup(); }
        function cleanup() {
          overlay.removeEventListener('click', cleanup);
          document.removeEventListener('keydown', onEsc);
          panel.remove();
          overlay.remove();
        }
      }




      function getBlocksInSelection() {
        const BLOCKS = 'p, div, blockquote, li';
        const sel = window.getSelection();

        // If no selection/range OR selection is outside the editor → stay in f_body
        if (!sel || !sel.rangeCount || !bodyEl.contains(sel.anchorNode)) {
          // pick the nearest block inside the editor (first block), ensure one exists
          const firstBlock = bodyEl.querySelector(BLOCKS) || ensureOneParagraph();
          return [firstBlock];
        }

        const range = sel.getRangeAt(0);

        // Collect only blocks INSIDE the editor that intersect the range
        const found = [];
        const walker = document.createTreeWalker(bodyEl, NodeFilter.SHOW_ELEMENT, {
          acceptNode: node => node.matches(BLOCKS) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        });
        while (walker.nextNode()) {
          if (range.intersectsNode(walker.currentNode)) found.push(walker.currentNode);
        }

        // If nothing matched, return the closest block **inside the editor**, not global
        if (found.length === 0) {
          return [closestBlockInEditor(sel.anchorNode)];
        }
        return found;

        function closestBlockInEditor(node) {
          const el = (node && node.nodeType === 1 ? node : node && node.parentElement) || bodyEl;
          const within = el.closest(BLOCKS);
          if (within && bodyEl.contains(within)) return within;
          const fb = bodyEl.querySelector(BLOCKS) || ensureOneParagraph();
          return fb;
        }

        function ensureOneParagraph() {
          const p = document.createElement('p');
          p.innerHTML = '<br>';
          bodyEl.appendChild(p);
          return p;
        }


        // ensure the select shows the default
        (() => {
          const sel = document.getElementById('fontSizeSelect');
          const def = sel.querySelector('option[default]') || sel.options[0];
          if (def) sel.value = def.value;
        })();

      }


      function closestBlock(node) {
        return (node.nodeType === 1 ? node : node.parentElement).closest(BLOCKS) || editor;
      }

      const HL_CMD = document.queryCommandSupported('hiliteColor') ? 'hiliteColor' : 'backColor';

      // document.querySelector('.rt-toolbar [data-cmd="highlight"]')?.addEventListener('mousedown', e => e.preventDefault());
      // document.querySelector('.rt-toolbar [data-cmd="highlight"]')?.addEventListener('click', () => {
      //   bodyEl.focus();
      //   const sel = window.getSelection();
      //   if (!sel || sel.isCollapsed) return; // nothing selected

      //   const current = (document.queryCommandValue(HL_CMD) || '').toLowerCase();
      //   const isOn = current.includes('rgb') || current.includes('#'); // any bg set at caret

      //   if (isOn) {
      //     document.execCommand(HL_CMD, false, 'transparent'); // remove bg
      //     scrubBgInSelection();                                // you already have this
      //     scrubFgInSelection();                                // NEW: clear inline color in range
      //   } else {

      //     const hlBg = getComputedStyle(document.documentElement)
      //       .getPropertyValue('--hl-bg')
      //       .trim() || '#000000';

      //     const hlFg = getComputedStyle(document.documentElement)
      //       .getPropertyValue('--hl-fg')
      //       .trim() || '#000000';


      //     document.execCommand(HL_CMD, false, hlBg);       // keep your bg
      //     document.execCommand('styleWithCSS', false, true);
      //     document.execCommand('foreColor', false, hlFg);        // set opposite text color
      //   }


      //   step.body = bodyEl.innerHTML;
      //   setDirty(true);
      //   renderViewStep();
      // });

      // document.querySelector('.rt-toolbar [data-cmd="highlight"]')?.addEventListener('mousedown', e => e.preventDefault());
      // document.querySelector('.rt-toolbar [data-cmd="highlight"]')?.addEventListener('click', () => {
      //   bodyEl.focus();
      //   const sel = window.getSelection();
      //   if (!sel || sel.isCollapsed) return; // nothing selected

      //   // your theme colors
      //   const hlBg = getComputedStyle(document.documentElement).getPropertyValue('--hl-bg').trim() || '#000000';
      //   const hlFg = getComputedStyle(document.documentElement).getPropertyValue('--hl-fg').trim() || '#000000';

      //   // Look across the whole selection, not just the caret
      //   const isOn = hasBgInSelection();

      //   if (isOn) {
      //     // try native clear, then scrub inline styles in the range
      //     document.execCommand(HL_CMD, false, 'transparent');
      //     scrubBgInSelection();
      //     scrubFgInSelection?.(); // if you added this earlier
      //   } else {
      //     // apply highlight with inline CSS so we can reliably detect/scrub later
      //     document.execCommand('styleWithCSS', false, true);
      //     document.execCommand(HL_CMD, false, hlBg);
      //     document.execCommand('foreColor', false, hlFg);
      //   }

      //   step.body = bodyEl.innerHTML;
      //   setDirty(true);
      //   renderViewStep();
      // });

      const hlBtn = document.getElementById('rt-hl-btn'); // <button id="rt-hl-btn">HL ▾</button>
      hlBtn?.addEventListener('mousedown', e => e.preventDefault()); // keep caret from blurring
      hlBtn?.addEventListener('click', () => openHighlightMenu(hlBtn, bodyEl));


      // Elements
      // const rtWrap = document.querySelector('.rt-wrap');     // wrapper that contains toolbar + editor + popup
      const linkBtn = document.getElementById('rt-link-btn');
      const pop = document.getElementById('rt-link-pop');
      const urlInput = document.getElementById('rt-link-url');
      const insertBtn = document.getElementById('rt-link-insert');
      const variablesSelect = document.getElementById('variables-select');
      const startersSelect = document.getElementById('starters-share-select');


      let savedRange = null;
      let selectedText = '';

      // Keep focus in editor normally
      linkBtn?.addEventListener('mousedown', e => e.preventDefault());

      // Open popup
      linkBtn?.addEventListener('click', () => {
        bodyEl.focus();
        saveSelection();

        // preload fields
        const sel = window.getSelection();
        selectedText = (sel && !sel.isCollapsed) ? sel.toString() : '';
        const linkNode = getLinkAtSelection();

        // txtInput.value = selectedText || (linkNode ? linkNode.textContent : '');
        urlInput.value = linkNode ? linkNode.getAttribute('href') || '' : '';

        // show near caret (or top of bodyEl as fallback)
        showPopupNearSelection(pop, wrap, bodyEl);

        // UX: suggest better text than “here”

        pop.hidden = false;
        // Focus first empty field
        // (txtInput.value ? urlInput : txtInput).focus();
      });

      insertBtn?.addEventListener('click', () => {
        let url = (urlInput.value || '').trim();
        if (!url) { urlInput.focus(); return; }
        if (!/^https?:\/\//i.test(url)) url = 'https://' + url;

        const text = (selectedText || '').trim() || url;
        const a = document.createElement('a');
        // add class clickable-link for styling
        a.className = 'clickable-link';
        a.href = url;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.textContent = text;
        a.title = url;

        // restore and check selection context
        restoreSelectionOrFocus();
        const sel = window.getSelection();
        const hasRange = sel && sel.rangeCount && bodyEl.contains(sel.anchorNode);

        if (hasRange && !sel.isCollapsed) {
          // Replace selection with <a>
          const r = sel.getRangeAt(0);
          r.deleteContents();
          r.insertNode(a);
          // place caret after link
          r.setStartAfter(a);
          r.collapse(true);
          sel.removeAllRanges(); sel.addRange(r);

        } else if (hasRange && sel.isCollapsed) {
          // Insert at caret
          const r = sel.getRangeAt(0);
          r.insertNode(a);
          r.setStartAfter(a);
          r.collapse(true);
          sel.removeAllRanges();
          sel.addRange(r);

        } else {
          // No caret inside editor → append at end
          // ensure trailing paragraph exists
          if (!bodyEl.lastElementChild || bodyEl.lastElementChild.tagName !== 'P') {
            const p = document.createElement('p'); p.innerHTML = '<br>'; bodyEl.appendChild(p);
          }
          bodyEl.lastElementChild.appendChild(a);
        }

        closeInsertLinkPopup();
        persistEditor();
      });

      // variablesSelect?.removeAttribute('disabled');
      // variables icon state (enable/disable + tooltip)
      // const variablesSelect = document.getElementById('variables-select');
      if (variablesSelect) {
        const candidates = getVariableCandidates(st, step);
        if (candidates.length > 0) {
          variablesSelect.removeAttribute('disabled');
          variablesSelect.title = 'Insert variable';
          // stash for the click handler if you want to reuse
          variablesSelect._varsCandidates = candidates;
        } else {
          variablesSelect.setAttribute('disabled', '');
          variablesSelect.title = 'No variables found';
          variablesSelect._varsCandidates = [];
        }
      }

      if (startersSelect) {
        const otherStartersIds = getOtherStarterIds();
        // console.log(`otherStartersIds`, otherStartersIds);
        if (otherStartersIds.length > 0) {
          startersSelect.title = 'Insert other starter reference link';
          // stash for the click handler if you want to reuse
          startersSelect._StartersIds = otherStartersIds;
        } else {
          startersSelect.title = 'No starters in the current SOP found';
          startersSelect._StartersIds = [];
        }
      }


      variablesSelect?.addEventListener('click', (e) => {
        if (variablesSelect.hasAttribute('disabled')) return;
        // optional: pass the precomputed list to your menu if you want
        openVariablesMenu(variablesSelect /*, variablesSelect._varsCandidates */);
      });

      startersSelect?.addEventListener('click', (e) => {
        // optional: pass the precomputed list to your menu if you want
        openStartersMenu(variablesSelect /*, variablesSelect._varsCandidates */);
      });


      document.addEventListener('mousedown', (e) => {
        if (!pop) return;
        if (!pop.hidden && !pop.contains(e.target) && e.target !== linkBtn) closeInsertLinkPopup();
      });

      // ——— helpers ———
      function saveSelection() {
        const sel = window.getSelection();
        if (sel && sel.rangeCount) savedRange = sel.getRangeAt(0).cloneRange();
      }

      function restoreSelectionOrFocus() {
        bodyEl.focus();
        const sel = window.getSelection();
        sel.removeAllRanges();
        if (savedRange) sel.addRange(savedRange);
      }

      function getLinkAtSelection() {
        const sel = window.getSelection();
        if (!sel || !sel.rangeCount) return null;
        const node = sel.anchorNode && (sel.anchorNode.nodeType === 1 ? sel.anchorNode : sel.anchorNode.parentElement);
        if (!node) return null;
        return node.closest && bodyEl.contains(node) ? node.closest('a[href]') : null;
      }

      function showPopupNearSelection(pop, container, bodyEl) {
        const sel = window.getSelection();
        const wrapRect = container.getBoundingClientRect();

        // make sure we can measure the popup
        const wasHidden = pop.hidden;
        pop.hidden = false;
        const prevVis = pop.style.visibility;
        pop.style.visibility = 'hidden';     // show but invisible to measure
        const popW = pop.offsetWidth || 300;
        const popH = pop.offsetHeight || 120;

        // default anchor = top-left of editor
        let caretRect = bodyEl.getBoundingClientRect();

        // if selection is inside the editor, use the selection/caret box
        if (sel && sel.rangeCount && bodyEl.contains(sel.anchorNode)) {
          const r = sel.getRangeAt(0);
          const rBox = r.getBoundingClientRect();
          // if collapsed ranges sometimes return 0-size, fall back to last client rect
          if (rBox.width || rBox.height) {
            caretRect = rBox;
          } else {
            const rects = r.getClientRects();
            if (rects.length) caretRect = rects[rects.length - 1];
          }
        }

        // position relative to wrapper
        let x = caretRect.left - wrapRect.left;
        let y = caretRect.bottom - wrapRect.top + 6;

        // clamp horizontally inside wrapper
        x = Math.max(8, Math.min(x, wrapRect.width - popW - 8));

        // if it would overflow bottom, flip above the caret
        if (y + popH > wrapRect.height - 8) {
          y = Math.max(8, caretRect.top - wrapRect.top - popH - 6);
        }

        pop.style.left = `${Math.round(x)}px`;
        pop.style.top = `${Math.round(y)}px`;

        // restore visibility
        pop.style.visibility = prevVis || '';
        if (wasHidden) pop.hidden = false;   // keep it open
      }


      function normalizeLinksInSelection() {
        const sel = window.getSelection();
        if (!sel || !sel.rangeCount) return;
        const r = sel.getRangeAt(0);
        const container = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentElement;
        container.querySelectorAll('a[href]').forEach(a => {
          if (!bodyEl.contains(a)) return;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          // ensure visual (color handled by CSS)
          if (!a.textContent.trim()) a.textContent = a.getAttribute('href');
        });
      }

      function needsBetterText(t) {
        const s = (t || '').trim().toLowerCase();
        return s === 'here' || s === 'click here' || s === 'link';
      }

      function closeInsertLinkPopup() {
        pop.hidden = true;
        savedRange = null;
      }

      function persistEditor() {
        step.body = bodyEl.innerHTML;
        setDirty(true);
        renderViewStep();
      }


      // function scrubFgInSelection() {
      //   const sel = window.getSelection();
      //   if (!sel || !sel.rangeCount) return;
      //   const range = sel.getRangeAt(0);

      //   const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_ELEMENT, {
      //     acceptNode: (el) => (bodyEl.contains(el) && range.intersectsNode(el)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      //   });

      //   const toClear = [];
      //   while (walker.nextNode()) {
      //     const el = walker.currentNode;
      //     if (el.style && el.style.color) toClear.push(el);
      //   }
      //   toClear.forEach(el => el.style.color = '');
      // }

      // function scrubFgInSelection() {
      //   const sel = window.getSelection();
      //   if (!sel || sel.rangeCount === 0) return;
      //   const range = sel.getRangeAt(0);

      //   const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_ELEMENT, {
      //     acceptNode: (el) => (bodyEl.contains(el) && range.intersectsNode(el))
      //       ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      //   });

      //   const toClear = [];
      //   while (walker.nextNode()) {
      //     const el = walker.currentNode;
      //     if (el.style && el.style.color) toClear.push(el);
      //   }
      //   toClear.forEach(el => el.style.color = '');
      // }

      function scrubFgInSelection() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return;
        const range = sel.getRangeAt(0);

        const walker = document.createTreeWalker(
          range.commonAncestorContainer,
          NodeFilter.SHOW_ELEMENT,
          {
            acceptNode: (el) =>
              (bodyEl.contains(el) && range.intersectsNode(el))
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_SKIP
          }
        );

        const toClear = [];
        const toUnwrap = [];
        while (walker.nextNode()) {
          const el = walker.currentNode;
          if (!el) continue;

          // inline color via CSS
          if (el.style && el.style.color) toClear.push(el);

          // legacy <font color="..."> from some engines
          if (el.tagName === 'FONT' && el.hasAttribute('color')) {
            el.removeAttribute('color');       // drop the color attr
            // if <font> has no other attrs, unwrap it to keep DOM clean
            if (!el.attributes.length) toUnwrap.push(el);
          }
        }

        toClear.forEach(el => { el.style.color = ''; if (!el.getAttribute('style')) el.removeAttribute('style'); });
        toUnwrap.forEach(el => { while (el.firstChild) el.parentNode.insertBefore(el.firstChild, el); el.remove(); });
      }




      // remove background-color only within the current selection (keeps links/bold/etc.)
      // function scrubBgInSelection() {
      //   const sel = window.getSelection();
      //   if (!sel || sel.rangeCount === 0) return;
      //   const range = sel.getRangeAt(0);

      //   const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_ELEMENT, {
      //     acceptNode: (el) => (bodyEl.contains(el) && range.intersectsNode(el)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      //   });

      //   while (walker.nextNode()) {
      //     const el = walker.currentNode;
      //     if (el.style && el.style.backgroundColor) el.style.backgroundColor = '';
      //   }
      // }

      function hasBgInSelection() {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) return false;
        const range = sel.getRangeAt(0);

        const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (el) => (bodyEl.contains(el) && range.intersectsNode(el))
            ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        });

        while (walker.nextNode()) {
          const el = walker.currentNode;
          // detect inline highlight (what execCommand writes)
          if (el.style && el.style.backgroundColor && el.style.backgroundColor !== '' && el.style.backgroundColor !== 'transparent') {
            return true;
          }
        }
        return false;
      }



      toolbar?.querySelectorAll('[data-cmd]').forEach(btn => {
        btn.addEventListener('mousedown', e => e.preventDefault());
        btn.addEventListener('click', () => {
          bodyEl.focus();

          // map custom cmds to execCommand names
          const cmd = btn.dataset.cmd;
          if (cmd === 'attach') { attachInput.click(); return; }

          document.execCommand(cmd, false, null);

          step.body = bodyEl.innerHTML;
          setDirty(true);
          renderViewStep();
        });
      });

      // Align buttons (left/center/right) applied to block elements in selection
      toolbar?.querySelectorAll('[data-align]').forEach(btn => {
        btn.addEventListener('mousedown', e => e.preventDefault());
        btn.addEventListener('click', () => {
          bodyEl.focus();
          const dir = btn.dataset.align;  // 'left' | 'center' | 'right'
          const blocks = getBlocksInSelection(); // you already have this helper

          // Toggle: if all selected blocks already have this alignment, clear it; else apply it
          const allSame = blocks.length && blocks.every(el => (el.style.textAlign || '') === dir);
          blocks.forEach(el => el.style.textAlign = allSame ? '' : dir);

          // persist + refresh preview
          step.body = bodyEl.innerHTML;
          setDirty(true);
          renderViewStep();
        });
      });


      attachInput?.addEventListener('change', () => {
        const f = attachInput.files?.[0];
        if (!f) return;

        const r = new FileReader();
        r.onload = () => {
          const href = String(r.result);                // data:…;base64,…
          bodyEl.focus();

          // use selected text as label, else the file name
          const sel = window.getSelection();
          const selectedText = sel && sel.rangeCount ? sel.toString() : '';
          const label = selectedText || f.name;
          const safeLabel = label.replace(/[<>&]/g, s => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;' }[s]));


          const sizeStr = bytesToHuman(f.size);
          document.execCommand(
            'insertHTML',
            false,
            `<a href="${href}" download="${encodeURIComponent(f.name)}"
                class="downloadable-chip" data-bytes="${f.size}" title="Download ${f.name}">
              <span class="icon" aria-hidden="true">⭳</span>
              <span class="name">${safeLabel}</span>
              <span class="size">${sizeStr}</span>
            </a>`
          );


          step.body = bodyEl.innerHTML;                 // persist editor HTML
          normalizeAnchors(bodyEl);   // normalize links/attachments
          setDirty(true);
          renderViewStep();                             // keep Preview in sync

          attachInput.value = '';                       // allow re-selecting same file
        };
        r.readAsDataURL(f);
      });




      function bytesToHuman(n) {
        if (n >= 1024 * 1024) return (n / 1048576).toFixed(1).replace(/\.0$/, '') + ' MB';
        return Math.max(1, Math.round(n / 1024)) + ' KB';
      }

      // --- link/attachment normalizer ---
      function bytesToHuman(n) {
        if (n >= 1048576) return (n / 1048576).toFixed(1).replace(/\.0$/, '') + ' MB';
        return Math.max(1, Math.round(n / 1024)) + ' KB';
      }

      function normalizeAnchors(root) {
        if (!root) return;
        root.querySelectorAll('a').forEach(a => {
          const href = a.getAttribute('href') || '';
          const isAttachment = a.hasAttribute('download') || href.startsWith('data:');

          a.classList.toggle('downloadable-chip', isAttachment);
          a.classList.toggle('clickable-link', !isAttachment);

          if (isAttachment) {
            // ensure chip structure
            if (!a.querySelector('.icon')) {
              const i = document.createElement('span');
              i.className = 'icon'; i.textContent = '⭳'; i.setAttribute('aria-hidden', 'true');
              a.prepend(i);
            }
            if (!a.querySelector('.name')) {
              const t = a.textContent.trim();
              a.textContent = '';
              const name = document.createElement('span');
              name.className = 'name'; name.textContent = t || (a.getAttribute('download') || 'file');
              a.appendChild(name);
            }
            if (!a.querySelector('.size')) {
              const s = document.createElement('span');
              s.className = 'size';
              const bytesAttr = a.getAttribute('data-bytes');
              if (bytesAttr) s.textContent = bytesToHuman(+bytesAttr);
              a.appendChild(s);
            }
          } else {
            // nice default for external links
            if (/^https?:\/\//i.test(href)) { a.target = "_blank"; a.rel = "noopener noreferrer"; }
          }
        });
      }



      function normalizeEditorRoot() {
        if (!bodyEl) return;
        const defaultPx = getDefaultPx(); // from earlier helper

        // 1) Convert stray nodes to <p> and size them
        [...bodyEl.childNodes].forEach(n => {
          if (n.nodeType === 3 && n.nodeValue.trim() !== '') {
            const p = document.createElement('p');
            p.textContent = n.nodeValue;
            p.style.fontSize = defaultPx + 'px';
            n.replaceWith(p);
          } else if (n.nodeType === 1 && n.tagName === 'DIV') {
            const p = document.createElement('p');
            p.innerHTML = n.innerHTML;
            p.style.fontSize = defaultPx + 'px';
            n.replaceWith(p);
          }
        });

        // 2) Ensure at least one paragraph exists
        if (!bodyEl.firstElementChild) {
          const p = document.createElement('p');
          p.innerHTML = '<br>';
          p.style.fontSize = defaultPx + 'px';
          bodyEl.appendChild(p);
        }

        // 3) Apply default size to any existing/new blocks missing it
        bodyEl.querySelectorAll('p, blockquote, li').forEach(el => {
          if (!el.style.fontSize) el.style.fontSize = defaultPx + 'px';
        });
      }


      function getDefaultPx() {
        const sel = document.getElementById('fontSizeSelect');
        const def = sel.querySelector('option[default]') || sel.options[0];
        const pt = parseInt(def.value, 10) || 12;
        // pt -> px @96dpi
        return Math.round(pt * 96 / 72);
      }


      bodyEl?.addEventListener('input', normalizeEditorRoot);
      bodyEl?.addEventListener('paste', () => setTimeout(normalizeEditorRoot, 0));
      // Click the small × on a chip to remove it and its stored embed
      bodyEl?.addEventListener('click', (e) => {
        const del = e.target.closest('.embed-del');
        if (!del) return;
        const chip = del.closest('.embed-chip');
        if (!chip) return;

        chip.remove();                         // remove visual
        reconcileEmbeds(step, bodyEl);         // drop from step.embeds
        step.body = bodyEl.innerHTML;          // persist
        setDirty?.(true);
        renderViewStep?.();
      });

      // Anytime the body changes (typing/backspace etc.), keep embeds in sync
      bodyEl?.addEventListener('input', () => {
        step.body = bodyEl.innerHTML;
        reconcileEmbeds(step, bodyEl);
        setDirty?.(true);
        renderViewStep?.();
      });

      normalizeEditorRoot(); // once on load


      // Input specifics
      const fPh = document.getElementById('f_ph');
      fPh?.addEventListener('input', () => { step.placeholder = fPh.value || ''; setDirty?.(true); renderViewStep(); });
      const fRegex = document.getElementById('f_regex');
      fRegex?.addEventListener('input', () => { step.regex = fRegex.value || ''; setDirty?.(true); renderViewStep(); });
      const fErr = document.getElementById('f_err');
      fErr?.addEventListener('input', () => { step.error = fErr.value || ''; setDirty?.(true); renderViewStep(); });
      const fReqMsg = document.getElementById('f_reqmsg');
      fReqMsg?.addEventListener('input', () => { step.requiredMessage = fReqMsg.value || ''; setDirty?.(true); renderViewStep(); });


      const fMode = document.getElementById('f_mode');
      fMode?.addEventListener('change', () => {
        step.mode = getSelectMode();

        setDirty?.(true);

        renderInspector();
        renderGraph();
      });

      function getSelectMode() {
        const sel = document.getElementById('f_mode');
        return sel?.value || 'single';
      }


      const pickBtn = document.getElementById('f_img_pick');
      const fileInp = document.getElementById('f_img_file');
      const txtInp = document.getElementById('f_img');
      const prevImg = document.getElementById('f_img_preview');
      const nameEl = document.getElementById('f_img_name');
      const clrBtn = document.getElementById('f_img_clear');

      prevImg?.addEventListener('click', () => {
        const src = prevImg.getAttribute('src') || prevImg.value || '';
        if (src) openImgLightbox(src);
      });

      function openImgLightbox(src) {
        // remove any existing
        document.querySelector('.cfm-overlay')?.remove();

        const ov = document.createElement('div');
        ov.className = 'cfm-overlay';
        ov.innerHTML = `<div class="imglb-panel"><img alt="" loading="eager"></div>`;
        const img = ov.querySelector('img');
        img.src = src;

        const close = () => {
          ov.classList.remove('open');
          const onEnd = () => ov.remove();
          ov.addEventListener('transitionend', onEnd, { once: true });
          // if no transition support, fallback remove
          setTimeout(() => { try { ov.remove(); } catch { } }, 180);
          document.removeEventListener('keydown', onKey);
        };
        const onKey = (e) => { if (e.key === 'Escape') close(); };

        ov.addEventListener('click', (e) => { if (e.target === ov) close(); });
        document.addEventListener('keydown', onKey);

        document.body.appendChild(ov);
        requestAnimationFrame(() => ov.classList.add('open'));
      }


      function setImage(uri, name = '') {
        step.img_b64 = uri || '';
        step.img_name = name || '';
        if (txtInp) txtInp.value = step.img_b64;
        if (prevImg) {
          if (step.img_b64) {
            prevImg.src = step.img_b64;
            // prevImg.hidden = false;
            prevImg.classList.remove('hidden');
          } else {
            prevImg.removeAttribute('src');
            // prevImg.hidden = true;
            prevImg.classList.add('hidden');
          }
        }
        if (nameEl) nameEl.textContent = step.img_name;
        if (clrBtn) {
          clrBtn.disabled = !step.img_b64;
          if (step.img_b64) clrBtn.classList.remove('hidden');
          else clrBtn.classList.add('hidden');

        }

        if (pickBtn) {
          if (step.img_b64) pickBtn.classList.add('hidden');
          else pickBtn.classList.remove('hidden');
        }
        setDirty?.(true);
        // update live preview area if you show image there
        renderViewStep?.();
      }

      function fileToBase64(file) {
        return new Promise((res, rej) => {
          const r = new FileReader();
          r.onload = () => res(String(r.result));
          r.onerror = rej;
          r.readAsDataURL(file);
        });
      }

      pickBtn?.addEventListener('click', () => fileInp?.click());

      fileInp?.addEventListener('change', async (e) => {
        const f = e.target.files?.[0]; if (!f) return;
        const uri = await fileToBase64(f);
        setImage(uri, f.name);
        // allow re-selecting same file
        e.target.value = '';
      });

      // When user pastes a data URI manually
      txtInp?.addEventListener('input', () => {
        const v = txtInp.value.trim();
        // accept data:image/*;base64,.... or empty
        if (v === '' || /^data:image\//i.test(v)) setImage(v, v ? '(pasted image)' : '');
      });

      clrBtn?.addEventListener('click', () => setImage('', ''));



      const addOptBtn = document.getElementById('addOptBtn');
      addOptBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if (!Array.isArray(step.options)) step.options = [];

        const opt = getDefaultOption(step);


        step.options.push(opt);
        setDirty?.(true);
        renderInspector();
        renderViewStep();
        renderGraph();
      });


      // maybe not present in case select-single 
      const f_next = document.getElementById('f_next');
      f_next?.addEventListener('change', () => {
        step.next = f_next.value || undefined;
        renderGraph();
        ensureStarterStartId(getStarter());
      });


      // Delegate option row events
      const optTable = document.getElementById('optTable');
      optTable?.addEventListener('input', (e) => {
        const tr = e.target.closest('tr[data-opt-idx]');

        if (!tr) return;
        const i = parseInt(tr.dataset.optIdx, 10);


        const opt = step.options[i];

        if (!opt) return;


        if (e.target.classList.contains('opt-value')) opt.value = e.target.value;
        if (e.target.classList.contains('opt-label')) opt.label = e.target.value;
        if (e.target.classList.contains('opt-hint')) opt.hint = e.target.value;
        if (e.target.classList.contains('opt-next')) opt.next = e.target.value || '';
        // renderViewStep();
        // }

        setDirty?.(true);
        renderGraph();
        renderViewStep();

      });
      optTable?.addEventListener('click', (e) => {
        if (!e.target.classList.contains('opt-del')) return;
        e.preventDefault();
        const tr = e.target.closest('tr[data-opt-idx]');
        if (!tr) return;
        const i = parseInt(tr.dataset.idx, 10);
        step.options.splice(i, 1);
        setDirty?.(true);
        renderInspector();
        renderViewStep();
        renderGraph();
      });
    }

    function getOtherStarters() {
      // const starters = Array.isArray(sop?.starters) ? sop.starters : [];
      // const curIdx = Number.isInteger(viewState?.starterIdx) ? viewState.starterIdx : -1;
      const curId = sop?.starters[viewState?.starterIdx]?.id;
      return curId ? sop?.starters.filter(st => st?.id !== curId) : starters;
    }

    // ids only (if you need them)
    function getOtherStarterIds() {
      return getOtherStarters().map(st => st.id).filter(Boolean);
    }



    /*** Graph ***/
    let mapZoom = 0;
    let mapPan = { x: 0, y: 0 };
    let drag = { active: false, start: { x: 0, y: 0 }, pan0: { x: 0, y: -8 }, vw: 0, vh: 0, wpp: 1 };
    let lastGraphSize = { width: 900, height: 600 };

    let placingFree = false;
    let ghostPos = null; // {x, y} in world coords

    let draggingStepId = null;
    let dragOffset = null;

    // store each node’s x/y under its ID so the graph doesn’t shuffle every time you re-render
    let lastPositions = {}; // stepId -> {x,y} snapshot from last render


    (function initGraphZoom() {
      resetGraphZoom();
    })();

    function resetGraphZoom() {
      mapZoom = 2.4;
      mapPan = { x: 0, y: -20 }
    };



    // function clientToWorld(e) {
    //   const bb = graphSvg.getBoundingClientRect();
    //   const vw = 1000, vh = 1000; // must match renderGraph() viewBox world size
    //   const x = mapPan.x + (e.clientX - bb.left) * (vw / mapZoom) / bb.width;
    //   const y = mapPan.y + (e.clientY - bb.top) * (vh / mapZoom) / bb.height;
    //   return { x, y };
    // }

    function clientToWorld(e) {
      const svg = graphSvg;

      // Preferred: use SVG's screen CTM (handles viewBox, pan, zoom, CSS scale)
      const pt = svg.createSVGPoint();
      pt.x = e.clientX; pt.y = e.clientY;
      const ctm = svg.getScreenCTM();
      if (ctm) {
        const p = pt.matrixTransform(ctm.inverse());
        return { x: p.x, y: p.y };
      }

      // Fallback: derive from current viewBox (no hard-coded 1000s)
      const bb = svg.getBoundingClientRect();
      const vb = svg.viewBox.baseVal;
      const sx = vb.width / bb.width;
      const sy = vb.height / bb.height;
      return {
        x: vb.x + (e.clientX - bb.left) * sx,
        y: vb.y + (e.clientY - bb.top) * sy
      };
    }


    function formatGraph() {
      const st = getStarter(); if (!st) return;
      (st.steps || []).forEach(s => { s.pos = null; }); // drop manual positions
      ensureSopPositions();

      // renderAll(); // layoutVertical will place everything
      renderGraph();
    }

    function getStepPos(id) {
      const st = getStarter();
      const step = st?.steps?.find(s => s.id === id);
      if (step?.pos) return { ...step.pos };            // stored pos
      if (lastPositions?.[id]) return { ...lastPositions[id] }; // computed pos
      return null;
    }

    function persistMissingPositionsFromLayout() {
      const st = getStarter(); if (!st) return false;
      let changed = false;
      (st.steps || []).forEach(s => {
        if (!s.pos && lastPositions?.[s.id]) {
          s.pos = { ...lastPositions[s.id] };
          changed = true;
        }
      });
      if (changed) setDirty(true);
      return changed;
    }

    graphSvg.addEventListener('mousemove', (e) => {
      if (!placingFree) return;
      ghostPos = clientToWorld(e);
      renderGraph();
    }, true);


    graphSvg.addEventListener('mousedown', (e) => {
      // A) PLACE NEW STEP if we're in Add (ghost) mode
      if (placingFree) {
        const pt = clientToWorld(e);
        const st = getStarter(); if (!st) return;
        const step = makeStep('instruction');
        step.pos = { x: pt.x, y: pt.y };
        st.steps.push(step);
        // viewState.selectedStepId = step.id;
        setSelectedStepById(step.id);

        placingFree = false; ghostPos = null;
        setDirty(true);

        renderGraph();
        renderInspector();
        renderViewStep();

        // focus the editor instead of leaving focus on the Add button
        queueMicrotask(() => {
          document.activeElement?.blur();
          const first = document.querySelector('#inspector input, #inspector textarea, .inspector input, .inspector textarea');
          first?.focus();
        });

        e.preventDefault();
        e.stopPropagation();
        return; // don't fall through to drag
      }

      // B) DRAG EXISTING NODE
      const rect = e.target.closest('rect');
      if (!rect) return;
      const id = rect.getAttribute('step-id');
      if (!id || !lastPositions[id]) return;

      const p0 = clientToWorld(e);
      const p = lastPositions[id];
      draggingStepId = id;
      dragOffset = { dx: p.x - p0.x, dy: p.y - p0.y };
      e.preventDefault();
      e.stopPropagation();
    }, true);


    addEventListener('mousemove', (e) => {
      if (!draggingStepId) return;
      const st = getStarter(); if (!st) return;
      const step = (st.steps || []).find(s => s.id === draggingStepId);
      if (!step) return;

      const pt = clientToWorld(e);
      step.pos = { x: pt.x + dragOffset.dx, y: pt.y + dragOffset.dy };
      renderGraph(); // live move
    }, true);

    addEventListener('mouseup', () => {
      if (!draggingStepId) return;
      draggingStepId = null;
      dragOffset = null;
      // we have to check here, as if it's already dirty, we should not save it, 
      // we're only going to save only if it's not dirty which means we are only saving the position when changed

      if (!isDirty) {
        isDirty = true;
        performSave();
      }

      queueMicrotask(() => {
        const first = document.querySelector('#inspector input, #inspector textarea, .inspector input, .inspector textarea');
        first?.focus();
      });
      // setDirty(true); // enable Save button
    }, true);

    // Attach (ensure passive:false so preventDefault works)
    try { if (graphSvg._wheelBound) graphSvg.removeEventListener('wheel', graphSvg._wheelBound); } catch { }
    graphSvg._wheelBound = onGraphWheel;
    graphSvg.addEventListener('wheel', onGraphWheel, { passive: false });

    function onGraphWheel(e) {
      // Ctrl/Cmd + wheel → zoom at mouse position (keeps the point under cursor pinned)
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const step = Math.pow(1.0018, -e.deltaY); // wheel up => zoom in
        zoomAtMouse(e, step);
        return;
      }

      // PAN (Shift = horizontal, up→left)
      e.preventDefault();
      const unit = (e.deltaMode === 1 ? 16 : e.deltaMode === 2 ? 256 : 1);
      const k = unit / mapZoom;
      const dx = e.shiftKey ? (-e.deltaY) : e.deltaX;
      const dy = e.shiftKey ? 0 : e.deltaY;
      mapPan.x += dx * k;
      mapPan.y += dy * k;
      renderGraph();
    }

    // Zoom around the mouse position using current SVG viewBox (no magic constants)
    function zoomAtMouse(e, factor) {
      const rect = graphSvg.getBoundingClientRect();
      const sx = e.clientX - rect.left;   // mouse in SVG viewport pixels
      const sy = e.clientY - rect.top;

      // Read current viewBox; fall back to mapPan/mapZoom if missing
      let vx, vy, vw, vh;
      const vb = (graphSvg.getAttribute('viewBox') || '').trim().split(/\s+/).map(Number);
      if (vb.length === 4 && vb.every(n => Number.isFinite(n))) {
        [vx, vy, vw, vh] = vb;
      } else {
        // fallback to your renderGraph convention (world=1000x1000)
        const WORLD = 1000;
        vx = mapPan.x; vy = mapPan.y; vw = WORLD / mapZoom; vh = WORLD / mapZoom;
      }

      // World coords under the cursor BEFORE zoom:
      // world = vmin + screen * (viewSize / pixelSize)
      const wx = vx + sx * (vw / rect.width);
      const wy = vy + sy * (vh / rect.height);

      // Apply zoom with clamps
      const minZ = 0.1, maxZ = 8;
      const oldZ = mapZoom;
      const newZ = clamp(oldZ * factor, minZ, maxZ);
      const eff = newZ / oldZ;                // effective factor after clamping
      if (eff === 1) return;

      // New viewBox size after zoom
      const vw2 = vw / eff;
      const vh2 = vh / eff;

      // Choose new pan so (wx,wy) stays at (sx,sy)
      // sx = (wx - vx2) * (rect.width / vw2)  => vx2 = wx - sx * (vw2 / rect.width)
      const vx2 = wx - sx * (vw2 / rect.width);
      const vy2 = wy - sy * (vh2 / rect.height);

      mapZoom = newZ;
      mapPan.x = vx2;
      mapPan.y = vy2;

      renderGraph();
    }

    function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }





    function zoomAroundCenter(factor) {
      const vw = 1000, vh = 1000;             // same world size used in renderGraph
      const viewW = vw / mapZoom;
      const viewH = vh / mapZoom;
      const cx = mapPan.x + viewW / 2;        // world center before zoom
      const cy = mapPan.y + viewH / 2;

      // apply zoom (with optional clamps if you use them)
      mapZoom = mapZoom * factor;

      // recompute top-left so the same center stays in the middle
      const newViewW = vw / mapZoom;
      const newViewH = vh / mapZoom;
      mapPan.x = cx - newViewW / 2;
      mapPan.y = cy - newViewH / 2;

      renderGraph();
    }


    // function renderGraph() {

    //   const st = getStarter();
    //   graphStarterTitle.textContent = st ? (st.label || '(no title)') : '(no starter)';

    //   const steps = st?.steps || [];
    //   if (!steps.length) {
    //     graphSvg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#98a2b3" font-size="14">No steps in this starter</text>';
    //     return;
    //   }
    //   const { nodes, edges } = buildGraph(st);
    //   const layout = layoutVertical(nodes, edges);
    //   lastPositions = layout;
    //   const svg = graphSvg;
    //   svg.innerHTML = `
    //                   <defs>
    //                     <marker id="arrow" viewBox="0 0 12 12" refX="12" refY="6"
    //                             markerWidth="10" markerHeight="10" markerUnits="userSpaceOnUse"
    //                             orient="auto">
    //                       <path d="M0 0 L12 6 L0 12 Z" fill="#98a2b3"></path>
    //                     </marker>
    //                   </defs>
    //                 `;


    //   const g = svg; // root
    //   const vw = 1000, vh = 1000; // world units used by layout
    //   const viewBox = `${mapPan.x} ${mapPan.y} ${vw / mapZoom} ${vh / mapZoom}`;
    //   svg.setAttribute('viewBox', viewBox);


    //   // edges (orthogonal: down then across)
    //   edges.forEach(e => {
    //     const s = layout[e.from], t = layout[e.to];
    //     if (!s || !t) return;
    //     const midY = (s.y + t.y) / 2;
    //     const d = `M ${s.x} ${s.y + 28} L ${s.x} ${midY} L ${t.x} ${midY} L ${t.x} ${t.y - 28}`;
    //     const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    //     path.setAttribute('d', d);
    //     path.setAttribute('class', 'edge');
    //     path.setAttribute('marker-end', 'url(#arrow)');
    //     g.appendChild(path);

    //     if (e.label) {
    //       const tx = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    //       tx.setAttribute('class', 'edge-label');
    //       tx.setAttribute('x', (s.x + t.x) / 2);
    //       tx.setAttribute('y', midY - 4);
    //       tx.setAttribute('text-anchor', 'middle');
    //       tx.textContent = e.label;
    //       g.appendChild(tx);
    //     }
    //   });

    //   // nodes
    //   nodes.forEach(n => {
    //     const grp = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    //     grp.setAttribute('transform', `translate(${layout[n.id].x}, ${layout[n.id].y})`);
    //     const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    //     rect.setAttribute('class', 'node-rect' + (n.id === viewState.selectedStepId ? ' current' : ''));
    //     rect.setAttribute('x', -80); rect.setAttribute('y', -28); rect.setAttribute('width', 160); rect.setAttribute('height', 56);
    //     rect.setAttribute('step-id', n.id);
    //     rect.style.cursor = 'move';


    //     grp.appendChild(rect);

    //     // HTML label via foreignObject so long ids wrap
    //     const svgNS = 'http://www.w3.org/2000/svg';
    //     const htmlNS = 'http://www.w3.org/1999/xhtml';
    //     const pad = 8;  // inner padding

    //     const fo = document.createElementNS(svgNS, 'foreignObject');
    //     fo.classList.add('node-fo');
    //     fo.setAttribute('x', -80 + pad);
    //     fo.setAttribute('y', -28 + pad);
    //     fo.setAttribute('width', 160 - pad * 2);
    //     fo.setAttribute('height', 56 - pad * 2);

    //     const div = document.createElementNS(htmlNS, 'div');
    //     div.className = 'label mono';          // keep your mono look
    //     div.textContent = n.label ?? '';
    //     fo.appendChild(div);

    //     grp.appendChild(fo);


    //     // grp.addEventListener('click', () => {
    //     //   // viewState.selectedStepId = n.id;
    //     //   setSelectedStepById(n.id);

    //     //   renderInspector();
    //     //   renderGraph();
    //     //   renderViewStep();
    //     //   // updateAddAfterState(); // disable Add After when 'done' is selected
    //     // });

    //     grp.addEventListener('click', () => {
    //       // navigateToStepId(n.id, { record: false });
    //       navigateToStepId(n.id);
    //       // setSelectedStepById(n.id);
    //     });

    //     g.appendChild(grp);
    //   });

    //   if (placingFree && ghostPos) {
    //     const grp = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    //     grp.setAttribute('transform', `translate(${ghostPos.x}, ${ghostPos.y})`);
    //     grp.setAttribute('opacity', '0.35');
    //     grp.setAttribute('pointer-events', 'none');

    //     const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    //     rect.setAttribute('x', -80); rect.setAttribute('y', -28);
    //     rect.setAttribute('width', 160); rect.setAttribute('height', 56);
    //     rect.setAttribute('rx', 8);
    //     rect.setAttribute('class', 'node-rect');
    //     rect.setAttribute('stroke-dasharray', '6,6');
    //     grp.appendChild(rect);

    //     const svgNS = 'http://www.w3.org/2000/svg';
    //     const htmlNS = 'http://www.w3.org/1999/xhtml';
    //     const pad = 8;

    //     const fo = document.createElementNS(svgNS, 'foreignObject');
    //     fo.classList.add('node-fo');
    //     fo.setAttribute('x', -80 + pad);
    //     fo.setAttribute('y', -28 + pad);
    //     fo.setAttribute('width', 160 - pad * 2);
    //     fo.setAttribute('height', 56 - pad * 2);

    //     const div = document.createElementNS(htmlNS, 'div');
    //     div.className = 'label mono';
    //     div.textContent = 'New step';
    //     fo.appendChild(div);

    //     grp.appendChild(fo);


    //     g.appendChild(grp);
    //   }


    function renderGraph() {
      const st = getStarter();
      graphStarterTitle.textContent = st ? (st.label || '(no title)') : '(no starter)';

      const steps = st?.steps || [];
      if (!steps.length) {
        graphSvg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#98a2b3" font-size="14">No steps in this starter</text>';
        return;
      }
      const { nodes, edges } = buildGraph(st);
      const layout = layoutVertical(nodes, edges);
      lastPositions = layout;

      const svg = graphSvg;
      svg.innerHTML = `
    <defs>
      <marker id="arrow" viewBox="0 0 12 12" refX="12" refY="6"
              markerWidth="10" markerHeight="10" markerUnits="userSpaceOnUse"
              orient="auto">
        <path d="M0 0 L12 6 L0 12 Z" fill="#98a2b3"></path>
      </marker>
    </defs>
  `;

      const g = svg; // root
      const vw = 1000, vh = 1000;
      const viewBox = `${mapPan.x} ${mapPan.y} ${vw / mapZoom} ${vh / mapZoom}`;
      svg.setAttribute('viewBox', viewBox);

      // ===== edges (CURVED) =====
      edges.forEach(e => {
        const s = layout[e.from], t = layout[e.to];
        if (!s || !t) return;

        const startX = s.x, startY = s.y + 28;   // exit source just below node
        const endX = t.x, endY = t.y - 28;   // enter target just above node
        const midY = (s.y + t.y) / 2;

        // smooth cubic: up from source, glide along midY, down into target
        const d = `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', d);
        path.setAttribute('class', 'edge');
        path.setAttribute('marker-end', 'url(#arrow)');
        path.setAttribute('fill', 'none');                 // ensure stroke-only
        path.setAttribute('stroke-linecap', 'round');      // nicer joins
        path.setAttribute('stroke-linejoin', 'round');
        g.appendChild(path);

        if (e.label) {
          const tx = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          tx.setAttribute('class', 'edge-label');
          tx.setAttribute('x', (startX + endX) / 2);
          tx.setAttribute('y', midY - 4);
          tx.setAttribute('text-anchor', 'middle');
          tx.textContent = e.label;
          g.appendChild(tx);
        }
      });

      // nodes
      nodes.forEach(n => {
        const grp = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        grp.setAttribute('transform', `translate(${layout[n.id].x}, ${layout[n.id].y})`);

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('class', 'node-rect' + (n.id === viewState.selectedStepId ? ' current' : ''));
        rect.setAttribute('x', -80); rect.setAttribute('y', -28);
        rect.setAttribute('width', 160); rect.setAttribute('height', 56);
        rect.setAttribute('step-id', n.id);
        rect.style.cursor = 'move';
        grp.appendChild(rect);

        // HTML label via foreignObject
        const svgNS = 'http://www.w3.org/2000/svg';
        const htmlNS = 'http://www.w3.org/1999/xhtml';
        const pad = 8;

        const fo = document.createElementNS(svgNS, 'foreignObject');
        fo.classList.add('node-fo');
        fo.setAttribute('x', -80 + pad);
        fo.setAttribute('y', -28 + pad);
        fo.setAttribute('width', 160 - pad * 2);
        fo.setAttribute('height', 56 - pad * 2);

        const div = document.createElementNS(htmlNS, 'div');
        div.className = 'label mono';
        div.textContent = n.label ?? '';
        fo.appendChild(div);

        grp.appendChild(fo);

        grp.addEventListener('click', () => {
          navigateToStepId(n.id);
        });

        g.appendChild(grp);
      });

      if (placingFree && ghostPos) {
        const grp = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        grp.setAttribute('transform', `translate(${ghostPos.x}, ${ghostPos.y})`);
        grp.setAttribute('opacity', '0.35');
        grp.setAttribute('pointer-events', 'none');

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', -80); rect.setAttribute('y', -28);
        rect.setAttribute('width', 160); rect.setAttribute('height', 56);
        rect.setAttribute('rx', 8);
        rect.setAttribute('class', 'node-rect');
        rect.setAttribute('stroke-dasharray', '6,6');
        grp.appendChild(rect);

        const svgNS = 'http://www.w3.org/2000/svg';
        const htmlNS = 'http://www.w3.org/1999/xhtml';
        const pad = 8;

        const fo = document.createElementNS(svgNS, 'foreignObject');
        fo.classList.add('node-fo');
        fo.setAttribute('x', -80 + pad);
        fo.setAttribute('y', -28 + pad);
        fo.setAttribute('width', 160 - pad * 2);
        fo.setAttribute('height', 56 - pad * 2);

        const div = document.createElementNS(htmlNS, 'div');
        div.className = 'label mono';
        div.textContent = 'New step';
        fo.appendChild(div);

        grp.appendChild(fo);
        g.appendChild(grp);
      }
    }



    //   // setSelectedStepById(viewState.selectedStepId);
    //   // navigateToStepId(viewState.selectedStepId);
    // }

    // Shared graph renderer used by editor graph and mini-map dialog.
    // Clone the existing editor graph into `mount`.
    // opts: { readonly = true, compact = true, fit = true, onNodeClick?: (id) => void }
    function renderGraphInto(mount, opts = {}) {
      const { readonly = true, compact = true, fit = true, onNodeClick } = opts;
      // if (id && typeof onNodeClick === 'function') onNodeClick(id);

      if (!mount) return;

      // 1) Find the source graph in Studio (ordered by specificity)
      const src =
        document.querySelector('#graphSvg') ||                        // your main SVG id (common)
        document.querySelector('.graph-canvas svg') ||                // SVG inside canvas
        document.querySelector('#graph svg') ||                       // legacy container + svg
        document.querySelector('svg[data-graph-root]') ||             // explicit marker
        document.querySelector('.graph svg');                         // last resort

      mount.innerHTML = '';

      if (!src) {
        // Nothing to copy → show a small hint (won't throw)
        const msg = document.createElement('div');
        msg.textContent = 'Graph not found in editor.';
        msg.style.opacity = '0.7';
        msg.style.font = '12px system-ui, Arial';
        mount.appendChild(msg);
        return;
      }

      // If user selected a container instead of the <svg>, find its svg
      const srcSvg = src.tagName.toLowerCase() === 'svg' ? src : src.querySelector('svg');
      if (!srcSvg) {
        const msg = document.createElement('div');
        msg.textContent = 'No SVG in graph container.';
        msg.style.opacity = '0.7';
        msg.style.font = '12px system-ui, Arial';
        mount.appendChild(msg);
        return;
      }

      // 2) Deep-clone the SVG
      const clone = srcSvg.cloneNode(true);

      // 3) Rewrite any <defs> ids and their url(#...) references to avoid collisions
      rewriteSvgIds(clone, 'mini_');

      // 4) Make it responsive (fit to container)
      if (fit) {
        if (!clone.getAttribute('viewBox')) {
          const w = parseFloat(clone.getAttribute('width')) || 1000;
          const h = parseFloat(clone.getAttribute('height')) || 600;
          clone.setAttribute('viewBox', `0 0 ${w} ${h}`);
        }
        clone.removeAttribute('width');
        clone.removeAttribute('height');
        clone.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        clone.style.width = '100%';
        clone.style.height = '100%';
      }

      // 5) Compact look (optional class your CSS already styles)
      clone.classList.add('graph-svg');
      if (compact) clone.classList.add('is-mini');

      // 6) Read-only: disable drag/handles/edges pointer capture; keep nodes clickable
      if (readonly) {
        // Common editor affordances to disable:
        const inertSel = [
          '.handle', '.connector', '.drag-handle', '.edge-hit', '.wheel',
          '.port', '.ghost', '.bbox', '.selection-rect'
        ].join(',');
        clone.querySelectorAll(inertSel).forEach(el => { el.style.pointerEvents = 'none'; });

        // Edges themselves shouldn’t swallow clicks in the mini
        clone.querySelectorAll('.edge, path.edge').forEach(el => { el.style.pointerEvents = 'none'; });

        // Nodes should feel clickable
        clone.querySelectorAll('g.node, .node').forEach(g => { g.style.cursor = 'pointer'; });
      }

      // 7) Mount it
      mount.appendChild(clone);

      // 8) Click → select step id (robust attribute probing)
      if (readonly) {
        mount.addEventListener('click', (ev) => {
          const n = ev.target.closest('[step-id], g.node, .node');
          if (!n) return;

          // Try a few places for the id
          const id =
            n.getAttribute?.('step-id');
          // ||
          // n.dataset?.stepId ||
          // n.getAttribute?.('data-id') ||
          // n.id ||
          // // sometimes the group stores on parent <g>
          // n.closest('[data-step-id]')?.getAttribute('data-step-id');

          if (id && typeof onNodeClick === 'function') onNodeClick(id);
        }, { passive: true });
      }

      // Helper: rewrite ids/urls to be unique inside the document
      function rewriteSvgIds(svg, prefix) {
        const idMap = new Map();

        // 1) Collect all elements with id
        const withId = svg.querySelectorAll('[id]');
        withId.forEach(el => {
          const oldId = el.id;
          const newId = prefix + oldId;
          idMap.set(oldId, newId);
          el.id = newId;
        });

        if (idMap.size === 0) return;

        // 2) Update all url(#...) references and xlink:href/href fragments
        const ATTRS = [
          'fill', 'stroke', 'filter', 'clip-path', 'mask', 'marker-start', 'marker-mid', 'marker-end',
          'xlink:href', 'href'
        ];

        const all = svg.querySelectorAll('*');
        all.forEach(el => {
          ATTRS.forEach(attr => {
            const val = el.getAttribute(attr);
            if (!val) return;

            // url(#id) form
            const next = val.replace(/url\(#([^)]+)\)/g, (m, id) => {
              return idMap.has(id) ? `url(#${idMap.get(id)})` : m;
            });

            // plain fragment href="#id"
            const next2 = next.replace(/^#(.+)$/, (m, id) => {
              return idMap.has(id) ? `#${idMap.get(id)}` : m;
            });

            if (next2 !== val) el.setAttribute(attr, next2);
          });
        });
      }
    }




    function buildGraph(starter) {
      const steps = starter?.steps || [];

      // nodes = all steps with their stored pos (renderer will use pos as-is)
      const nodes = steps.map(s => ({
        id: s.id,
        label: s.id || s.title || s.label,
        pos: s.pos || null
      }));

      // edges = connections based on rule:
      // - instruction/input: one edge from step.next (if set)
      // - select (multi):   one edge from step.next (if set) → "after"
      // - select (single):  edges from each option.next (ignore step.next)
      const edges = [];
      const seen = new Set(); // avoid duplicates

      const pushEdge = (from, to, label) => {
        if (!from || !to) return;
        const k = `${from}→${to}#${label || ''}`;
        if (seen.has(k)) return;
        seen.add(k);
        edges.push({ from, to, ...(label ? { label } : {}) });
      };

      for (const s of steps) {
        if (s.type === 'instruction' || s.type === 'input') {
          // single next
          if (s.next) pushEdge(s.id, s.next);
          continue;
        }

        if (s.type === 'select') {
          if (s.mode === 'multi') {
            // multi-select → use step.next only (after all selections)
            if (s.next) pushEdge(s.id, s.next, 'after');
          } else {
            // single-select → use per-option next only
            if (Array.isArray(s.options)) {
              for (const o of s.options) {
                if (o?.next) pushEdge(s.id, o.next, (o.value || o.label || ''));
              }
            }
          }
          continue;
        }

        // any other/unknown types: be conservative, only step.next if present
        if (s.next) pushEdge(s.id, s.next);
      }

      return { nodes, edges };
    }





    function layoutVertical(nodes, edges) {
      if (!nodes.length) return {};

      const nodeById = Object.fromEntries(nodes.map(n => [n.id, n]));


      // adjacency for forward edges
      const adj = {};
      nodes.forEach(n => adj[n.id] = []);
      edges.forEach(e => { (adj[e.from] ||= []).push(e.to); });
      // console.log(`edges`, edges);

      // start from the first node (treat as root)
      const depth = {};
      const start = nodes[0].id;
      depth[start] = 0;

      // initial BFS
      const q = [start];
      while (q.length) {
        const u = q.shift();
        for (const v of adj[u] || []) {
          if (depth[v] == null) {
            depth[v] = depth[u] + 1;
            q.push(v);
          }
        }
      }
      // assign depth 0 for any isolated/unreached nodes
      nodes.forEach(n => { if (depth[n.id] == null) depth[n.id] = 0; });

      // relax depths so every edge goes strictly downward
      // if depth[to] <= depth[from], push it down
      let changed = true, guard = 0;
      while (changed && guard < 50) {
        changed = false; guard++;
        for (const e of edges) {
          const a = depth[e.from], b = depth[e.to];
          if (a != null && b != null && b <= a) {
            depth[e.to] = a + 1;
            changed = true;
          }
        }
      }

      // group nodes by depth (rows)
      const rows = {};
      nodes.forEach(n => {
        const d = depth[n.id] || 0;
        (rows[d] ||= []).push(n.id);
      });

      // order within each row (stable by original order)
      const colIndex = {};
      Object.keys(rows).sort((a, b) => a - b).forEach(d => {
        rows[d].forEach((id, i) => colIndex[id] = i);
      });


      const pos = {};
      nodes.forEach(n => {

        pos[n.id] = { x: n.pos.x, y: n.pos.y }
      });


      return pos;
    }




    // function dupStep() {
    //   const st = getStarter(); const s = st.steps.find(x => x.id === viewState.selectedStepId); if (!s) return;
    //   const c = JSON.parse(JSON.stringify(s));
    //   c.id = uniqueId(s.id + '_copy');
    //   st.steps.splice(st.steps.findIndex(x => x.id === s.id) + 1, 0, c);
    //   viewState.selectedStepId = c.id;
    //   // renderAll();
    //   // renderGraph();
    //   // renderInspector();
    //   setDirty(true);

    //   // if (studioMode === 'view') renderViewAndEditLanding();

    // }
    function delStep() {
      const st = getStarter();
      const i = st.steps.findIndex(x => x.id === viewState.selectedStepId); if (i < 0) return;
      const delId = st.steps[i].id;
      st.steps.splice(i, 1);
      // remove refs
      for (const step of st.steps) {
        if ((step.type === 'instruction' || step.type === 'input') && step.next === delId) {
          delete step.next;
          ensureStarterStartId(st);
        }
        if (step.type === 'select') {
          (step.options || []).forEach(o => {
            if (o.next === delId) {
              delete o.next;
              ensureStarterStartId(st);
            }
          });
          if (step.next === delId) {
            delete step.next;
            ensureStarterStartId(st);
          }
        }
      }
      // viewState.selectedStepId = st.steps[Math.max(0, i - 1)]?.id || null;
      setSelectedStepById(st.steps[Math.max(0, i - 1)]?.id);

      setDirty(true);

      ensureSopMandatory();

      renderGraph();
      renderInspector();
      renderViewStep();
      queueMicrotask(() => {
        document.activeElement?.blur();
        const first = document.querySelector('#inspector input, #inspector textarea, .inspector input, .inspector textarea');
        first?.focus();
      });
    }
    function replaceStep(id, repl) {
      const st = getStarter();
      const i = st.steps.findIndex(x => x.id === id);
      if (i >= 0) st.steps[i] = repl;
    }

    function rewriteRefs(oldId, newId) {
      if (oldId === newId) return;
      const st = getStarter();
      if (st.startId === oldId) st.startId = newId;
      for (const step of st.steps) {
        if ((step.type === 'instruction' || step.type === 'input') && step.next === oldId) step.next = newId;
        if (step.type === 'select') {
          (step.options || []).forEach(o => { if (o.next === oldId) o.next = newId; });
          if (step.next === oldId) step.next = newId;
        }
      }
    }

    function resetListenersByClone(el) {
      if (!el) return null;
      const clone = el.cloneNode(true);
      el.parentNode.replaceChild(clone, el);
      return clone;
    }


    // Custom confirm dialog (uses CSS classes + your vars)
    function confirmDialog({ title = 'Confirm', message = '', confirmText = 'OK', cancelText = 'Cancel', variant = 'primary', one = false } = {}) {
      const okClass =
        variant === 'neutral' ? 'cfm-btn cfm-btn--neutral' :
          variant === 'subtleDanger' ? 'cfm-btn cfm-btn--subtleDanger' :
            variant === 'danger' ? 'cfm-btn cfm-btn--ok cfm-btn--danger' :
              'cfm-btn cfm-btn--ok';


      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'cfm-overlay';

        const panel = document.createElement('div');
        panel.className = 'cfm-panel';

        const actionsHtml = one
          ? `<div class="cfm-actions">
                <button id="cfmOk" class="${okClass}">${confirmText}</button>
              </div>`
          : `<div class="cfm-actions">
                <button id="cfmCancel" class="cfm-btn cfm-btn--cancel">${cancelText}</button>
                <button id="cfmOk" class="${okClass}">${confirmText}</button>
              </div>`;

        panel.innerHTML = `
            <div class="cfm-title">${title}</div>
            <div class="cfm-msg">${message}</div>
            ${actionsHtml}
          `;


        overlay.appendChild(panel);
        document.body.appendChild(overlay);

        const done = (val) => {
          document.removeEventListener('keydown', onKey);
          overlay.remove();
          resolve(val);
        };
        const onKey = (e) => {
          if (e.key === 'Escape') done(false);
          if (e.key === 'Enter') done(true);
        };

        const btnCancel = panel.querySelector('#cfmCancel');
        const btnOk = panel.querySelector('#cfmOk');

        btnCancel?.addEventListener('click', () => done(false));
        btnOk.addEventListener('click', () => done(true));
        overlay.addEventListener('click', (e) => { if (e.target === overlay) done(false); });
        document.addEventListener('keydown', onKey);

      });
    }

    function viewEscape(s) { return String(s ?? '').replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }

    function viewBodyHtml(body) {
      if (!body) return '';
      if (Array.isArray(body)) {
        return `<ul>${body.map(li => `<li>${viewSafeInterpolate(String(li))}</li>`).join('')}</ul>`;
      }
      return `<p>${viewSafeInterpolate(String(body))}</p>`;
    }

    function renderBody(body) {
      if (!body) return '';
      // interpolate {{vars}} but preserve HTML if present
      const html = viewSafeInterpolate(String(body));
      // if it already contains tags, inject as-is; else wrap as a paragraph
      return /<[a-z][\s\S]*>/i.test(html) ? html : `<p>${html}</p>`;
    }

    // --- helpers for {{var}} interpolation in Studio Preview ---
    function viewSafeInterpolate(str) {
      // supports {{var}}, {{var.label}}, and multi-select join
      return String(str).replace(/\{\{\s*([\w.]+)\s*\}\}/g, (_, path) => viewEscape(viewReadAnswerPath(path)));
    }

    function viewReadAnswerPath(path) {
      const [head, ...rest] = String(path).split('.');
      const base = (viewState && viewState.answers) ? viewState.answers[head] : undefined;
      return viewFormatAnswerPath(base, rest);
    }

    function viewFormatAnswerPath(base, props) {
      if (base == null) return '';
      if (Array.isArray(base)) {
        if (props && props.length) {
          return base.map(x => viewPickPath(x, props)).filter(v => v != null && v !== '').join(', ');
        }
        return base.map(x => (x && (x.value || x.label)) || String(x)).join(', ');
      }
      if (typeof base === 'object') {
        if (props && props.length) return viewPickPath(base, props) ?? '';
        return base.value || base.label || '';
      }
      return String(base);
    }

    function viewPickPath(obj, props) {
      let cur = obj;
      for (const p of props) { if (cur == null) return ''; cur = cur[p]; }
      return cur ?? '';
    }



    async function exportCurrentHTMLAsViewer() {
      // ensure latest header inputs are reflected
      // if (typeof syncHeaderInputsIntoSop === 'function') syncHeaderInputsIntoSop();

      //  btnPreview?.addEventListener('click', async () => {

      let loadSopFromSaved = false;
      if (isDirty) {
        if (savedSop) {
          const ok = await confirmDialog({
            title: 'Export last saved version?',
            message: 'You have unsaved changes. Export the last saved version and keep your current edits?',
            confirmText: 'Export Saved Version',
            cancelText: 'Cancel',
            // variant: 'neutral'
          });
          if (!ok) return;
          loadSopFromSaved = true;
          // return;
        }
      }

      const slot = document.getElementById('jsonEmbedded');
      if (!slot) { alert('Missing #jsonEmbedded'); return; }

      try {
        // embed current sop or replace json in existing html <script id="jsonEmbedded">/script>
        slot.textContent = safeJSONStringify(loadSopFromSaved ? savedSop : sop, null, 2) + '\n';
        // switch to guide mode (removes editor-only UI)
        changeRunMode('guide');
        // change title
        renderSopTitle();
        // download current html 
        downloadCurrentHTML((typeof slugify === 'function' ? slugify(sop?.title || 'sop-viewer') : 'sop-viewer') + '.html');

        // switch back to studio mode
        changeRunMode('studio');
        // change title again
        renderSopTitle();


      } catch (e) {
        alert('Failed to stringify SOP JSON: ' + (e?.message || e));
      }
    }

    function safeJSONStringify(obj) {
      return JSON.stringify(obj, null, 2)
        // Escape anything that could prematurely close the script tag
        .replace(/<\/script>/gi, '<\\/script>')
        // Also neutralize raw "<" so any "<\/script" variants are safe
        .replace(/</g, '\\u003C')
        // Normalize line separators that can break JS/JSON embedding in some engines
        .replace(/\u2028/g, '\\u2028')
        .replace(/\u2029/g, '\\u2029');
    }


    function renderSopTitle() {
      const modeTitle = document.getElementById('sop-run-mode-title');
      const modeTabTitle = document.getElementById('sop-run-mode-tab-title');
      const elInput = document.getElementById('sop-run-mode-title-input');
      const sopTypeTitle = `${sop.title} ${sop.title?.trim() === '' ? '' : ' ·'} SOP ${getCurrentRunMode() === 'guide' ? 'Guide' : 'Studio Builder'}`;

      if (modeTitle) modeTitle.textContent = sopTypeTitle;
      if (modeTabTitle) modeTabTitle.textContent = sopTypeTitle;
      if (elInput) elInput.value = sop.title;
    }


    function downloadCurrentHTML(filename) {
      // filename fallback
      const title = (document.title || 'page').toString();
      const slug = title.toLowerCase().replace(/[^\w]+/g, '-').replace(/^-+|-+$/g, '');
      const name = filename || (slug ? `${slug}.html` : 'page.html');

      // build <!DOCTYPE> safely
      const d = document.doctype;
      const doctype = d
        ? `<!DOCTYPE ${d.name}${d.publicId ? ` PUBLIC "${d.publicId}"` : ''}${d.systemId ? ` "${d.systemId}"` : ''}>`
        : '<!DOCTYPE html>';

      // serialize current DOM "as is"
      const html = `${doctype}\n${document.documentElement.outerHTML}`;

      // download
      const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 300);
    }

    // this is useless, i am not gonna use it, it just only one time will be called by browser console only if needed
    /**
 * Add step-level "next" pointers within each starter (no cross-starter links).
 * - Preserves any existing step.next
 * - Adds step.next to any step missing it (points to the next step's id)
 * - Never sets next on the final step of a starter (removes it if present)
 * - Never adds next to steps of type "end"
 */



    //  browser console only if needed

    function addNextPointers(sop) {
      const clone = (obj) =>
      (typeof structuredClone === "function"
        ? structuredClone(obj)
        : JSON.parse(JSON.stringify(obj)));

      const out = clone(sop);
      if (!out || !Array.isArray(out.starters)) return out;

      out.starters.forEach((starter) => {
        const steps = Array.isArray(starter.steps) ? starter.steps : [];
        for (let i = 0; i < steps.length; i++) {
          const step = steps[i];

          // Last step: ensure no "next"
          if (i === steps.length - 1) {
            if (step && Object.prototype.hasOwnProperty.call(step, "next")) {
              delete step.next;
            }
            continue;
          }

          // For non-last steps: add "next" only if missing and not an "end" step
          if (
            step &&
            step.type !== "end" &&
            !Object.prototype.hasOwnProperty.call(step, "next")
          ) {
            const nextId = steps[i + 1] && steps[i + 1].id;
            if (nextId) step.next = nextId;
          }
        }
      });

      return out;
    }


    // --- helpers reused by both file + URL paths ---
    async function parseApplyImportedHtml(htmlText, sourceName) {
      // unescape if entity-escaped html (same as your current logic)
      if (/&lt;html\b/i.test(htmlText) && !/<html\b/i.test(htmlText)) {
        htmlText = htmlText
          .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"').replace(/&#39;/g, "'")
          .replace(/&amp;/g, '&');
      }

      const doc = new DOMParser().parseFromString(htmlText, 'text/html');
      let jsonText = '';

      const slotPlain = doc.querySelector('script#jsonEmbedded');
      if (slotPlain?.textContent.trim()) jsonText = slotPlain.textContent.trim();

      if (!jsonText) {
        const slotDefault = doc.querySelector('script#default-sop[type="application/json"]');
        if (slotDefault?.textContent.trim()) jsonText = slotDefault.textContent.trim();
      }

      if (!jsonText) {
        const anyJson = Array.from(doc.querySelectorAll('script[type="application/json"]'))
          .find(s => /\bstarters\b/.test(s.textContent || ''));
        if (anyJson) jsonText = anyJson.textContent.trim();
      }

      let parsed;
      try {
        parsed = JSON.parse(jsonText);
        if (!parsed || !Array.isArray(parsed.starters)) throw new Error('Missing starters[]');
      } catch (err) {
        alert('Could not import this file.\n\n' + (err?.message || 'Invalid or missing SOP JSON.'));
        return false;
      }

      // Confirm
      const ok = await confirmDialog({
        title: 'Import SOP?',
        message: `Replace the current SOP with “${sourceName}”?`,
        confirmText: 'Import',
        cancelText: 'Cancel',
        variant: 'subtleDanger'
      });
      if (!ok) return false;

      // Apply + save + refresh (same flow you already do)
      sop = parsed;
      ensureSop();
      viewState.starterIdx = 0;
      setSelectedStepById(sop.starters[0]?.steps?.[0]?.id);

      setDirty(true);
      const saved = await performSave();
      if (!saved) return false;

      renderViewAndEditLanding();
      changeScreen('landing');
      changeDataMode('edit');
      updateSaveBtn?.();
      return true;
    }

    // async function extractSopFromHtml_viaIframe(htmlText) {
    //   return new Promise((resolve, reject) => {
    //     const iframe = document.createElement('iframe');
    //     iframe.style.display = 'none';
    //     iframe.setAttribute('sandbox', 'allow-same-origin'); // scripts won't run
    //     iframe.srcdoc = htmlText;
    //     iframe.onload = () => {
    //       try {
    //         const doc = iframe.contentDocument;
    //         let jsonText = '';

    //         const slot1 = doc.querySelector('script#jsonEmbedded');
    //         if (slot1?.textContent.trim()) jsonText = slot1.textContent.trim();

    //         if (!jsonText) {
    //           const slot2 = doc.querySelector('script#default-sop[type="application/json"]');
    //           if (slot2?.textContent.trim()) jsonText = slot2.textContent.trim();
    //         }

    //         if (!jsonText) {
    //           const anyJson = Array.from(doc.querySelectorAll('script[type="application/json"]'))
    //             .find(s => /\bstarters\b/.test(s.textContent || ''));
    //           if (anyJson) jsonText = anyJson.textContent.trim();
    //         }

    //         if (!jsonText) throw new Error('No embedded SOP JSON found.');
    //         const parsed = JSON.parse(jsonText);
    //         if (!parsed || !Array.isArray(parsed.starters)) throw new Error('Invalid SOP JSON (missing starters[]).');
    //         resolve(parsed);
    //       } catch (err) {
    //         reject(err);
    //       } finally {
    //         iframe.remove();
    //       }
    //     };
    //     iframe.onerror = () => { iframe.remove(); reject(new Error('Failed to load iframe.')); };
    //     document.body.appendChild(iframe);
    //   });
    // }

    async function applyImportedSop(parsed, sourceName) {
      const ok = await confirmDialog({
        title: 'Import SOP?',
        message: `Replace the current SOP with “${sourceName}”?`,
        confirmText: 'Import',
        cancelText: 'Cancel',
        variant: 'subtleDanger'
      });
      if (!ok) return false;

      sop = parsed;
      ensureSop();
      viewState.starterIdx = 0;
      setSelectedStepById(sop.starters[0]?.steps?.[0]?.id);
      setDirty(true);
      const saved = await performSave();
      if (!saved) return false;

      renderViewAndEditLanding();
      changeScreen('landing');
      changeDataMode('edit');
      updateSaveBtn?.();
      return true;
    }

    // async function fetchImportFromUrl(u) {
    //   let text;
    //   const res = await fetch(u, { mode: 'cors', credentials: 'omit' });
    //   if (!res.ok) throw new Error(`HTTP ${res.status}`);
    //   text = await res.text();

    //   if (/&lt;html\b/i.test(text) && !/<html\b/i.test(text)) {
    //     text = text
    //       .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
    //       .replace(/&quot;/g, '"').replace(/&#39;/g, "'")
    //       .replace(/&amp;/g, '&');
    //   }
    //   const parsed = await extractSopFromHtml_viaIframe(text);
    //   return applyImportedSop(parsed, u);
    // }


    // Call this when the user clicks "Import" in your menu
    function openImportDialog() {
      const dlg = document.getElementById('dlgImport');
      if (!dlg) return;
      resetImportDialog();
      dlg.classList.remove('hidden');

      // close on clicking outside the panel
      const onBackdropClick = (e) => {
        if (e.target === dlg) close();
      };
      dlg.addEventListener('click', onBackdropClick);

      const onEsc = (e) => { if (e.key === 'Escape') close(); };
      document.addEventListener('keydown', onEsc);


      function close() {
        dlg.classList.add('hidden');
        dlg.removeEventListener('click', onBackdropClick);
        document.removeEventListener('keydown', onEsc);
      }


      // const onEsc = (e) => { if (e.key === 'Escape') close(); };
      // document.addEventListener('keydown', onEsc);
      // document.getElementById('imCancel').onclick = close;

      function close() {
        dlg.classList.add('hidden');
        document.removeEventListener('keydown', onEsc);
        teardownDnD();
      }
    }

    //— Wire once on app init
    (function wireImportDialog() {
      const drop = document.getElementById('imDrop');
      const browse = document.getElementById('imBrowse');
      const fileI = document.getElementById('imFile');
      const urlI = document.getElementById('imUrl');
      const fetchB = document.getElementById('imFetch');
      const errF = document.getElementById('imErrFile');
      const errU = document.getElementById('imErrUrl');
      if (!drop || !browse || !fileI || !urlI || !fetchB) return;

      // — browse
      browse.addEventListener('click', (e) => { e.preventDefault(); fileI.click(); });
      fileI.addEventListener('change', async () => {
        const f = fileI.files?.[0];
        if (!f) return;
        if (!/\.html?$/i.test(f.name)) { errF.textContent = 'Please choose a .html file.'; return; }
        errF.textContent = '';
        const text = await f.text();
        await applyImportedHtml(text, f.name);
      });

      // — drag & drop
      const stop = (e) => { e.preventDefault(); e.stopPropagation(); };
      const enter = (e) => { stop(e); drop.classList.add('drag'); };
      const leave = (e) => { stop(e); drop.classList.remove('drag'); };
      const dropH = async (e) => {
        stop(e); drop.classList.remove('drag');
        const f = e.dataTransfer?.files?.[0];
        if (!f) return;
        if (!/\.html?$/i.test(f.name)) { errF.textContent = 'Please drop a .html file.'; return; }
        errF.textContent = '';
        const text = await f.text();
        await applyImportedHtml(text, f.name);
      };
      drop.addEventListener('dragenter', enter);
      drop.addEventListener('dragover', enter);
      drop.addEventListener('dragleave', leave);
      drop.addEventListener('drop', dropH);
      drop.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileI.click(); } });

      // — URL validate + enable button
      const isValidUrl = (v) => {
        try { const u = new URL(v, location.origin); return /^(https?:)$/i.test(u.protocol); }
        catch { return false; }
      };
      urlI.addEventListener('input', () => {
        // errU.textContent = '';
        // fetchB.disabled = !isValidUrl(urlI.value.trim());
      });

      // fetchB.addEventListener('click', async () => {
      //   const u = urlI.value.trim();
      //   if (!isValidUrl(u)) { errU.textContent = 'Enter a valid http(s) URL.'; return; }
      //   try {
      //     const res = await fetch(u, { mode: 'cors', credentials: 'omit' });
      //     if (!res.ok) throw new Error(`HTTP ${res.status}`);
      //     const text = await res.text();
      //     await applyImportedHtml(text, u);
      //   } catch (e) {
      //     errU.textContent = 'Could not fetch that URL.';
      //   }
      // });

      // document.getElementById('imFetch')?.addEventListener('click', async () => {
      //   const btn = document.getElementById('imFetch');
      //   const input = document.getElementById('imUrl');
      //   const err = document.getElementById('imErrUrl');
      //   err.textContent = '';
      //   btn.disabled = true;
      //   try {
      //     await fetchImportFromUrl(input.value.trim());
      //     document.getElementById('dlgImport')?.classList.add('hidden'); // close on success, optional
      //   } catch (e) {
      //     err.textContent = e.message || 'Import failed.';
      //     console.error(e);
      //   } finally {
      //     btn.disabled = false;
      //   }
      // });

      // --- small helpers -----------------------------------------------------------

      function isValidHttpUrl(v) {
        try {
          const u = new URL(v, location.href);
          return u.protocol === 'http:' || u.protocol === 'https:';
        } catch { return false; }
      }

      function isMixedContent(u) {
        try {
          const url = new URL(u, location.href);
          return location.protocol === 'https:' && url.protocol === 'http:';
        } catch { return false; }
      }

      async function fetchWithTimeout(url, options = {}, ms = 15000) {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), ms);
        try {
          const res = await fetch(url, { ...options, signal: ctrl.signal });
          return res;
        } finally {
          clearTimeout(t);
        }
      }

      // --- existing iframe extractor (unchanged) -----------------------------------
      async function extractSopFromHtml_viaIframe(htmlText) {
        return new Promise((resolve, reject) => {
          const iframe = document.createElement('iframe');
          iframe.style.display = 'none';
          iframe.setAttribute('sandbox', 'allow-same-origin'); // scriptless, readable DOM
          iframe.srcdoc = htmlText;

          iframe.onload = () => {
            try {
              const doc = iframe.contentDocument;
              let jsonText = '';

              const slot1 = doc.querySelector('script#jsonEmbedded');
              if (slot1?.textContent.trim()) jsonText = slot1.textContent.trim();

              if (!jsonText) {
                const slot2 = doc.querySelector('script#default-sop[type="application/json"]');
                if (slot2?.textContent.trim()) jsonText = slot2.textContent.trim();
              }

              if (!jsonText) {
                const anyJson = Array.from(doc.querySelectorAll('script[type="application/json"]'))
                  .find(s => /\bstarters\b/.test(s.textContent || ''));
                if (anyJson) jsonText = anyJson.textContent.trim();
              }

              if (!jsonText) throw new Error('No embedded SOP JSON found.');
              const parsed = JSON.parse(jsonText);
              if (!parsed || !Array.isArray(parsed.starters)) throw new Error('Invalid SOP JSON (missing starters[]).');
              resolve(parsed);
            } catch (err) {
              reject(err);
            } finally {
              iframe.remove();
            }
          };

          iframe.onerror = () => {
            iframe.remove();
            reject(new Error('Failed to load iframe.'));
          };

          document.body.appendChild(iframe);
        });
      }

      // --- enhanced importer --------------------------------------------------------
      async function fetchImportFromUrl(rawUrl) {
        // 1) Basic input checks
        if (!rawUrl) throw new Error('URL is required.');
        if (!isValidHttpUrl(rawUrl)) throw new Error('Enter a valid http(s) URL.');

        // 2) Mixed content
        if (isMixedContent(rawUrl)) {
          throw new Error('Blocked: cannot fetch http from an https page (mixed content). Use an https link or open the app over http.');
        }

        // 3) Fetch with timeout; surface common cases cleanly
        let res;
        try {
          res = await fetchWithTimeout(rawUrl, { mode: 'cors', credentials: 'omit' }, 15000);
        } catch (e) {
          if (e.name === 'AbortError') throw new Error('Timed out fetching the URL. Try again.');
          // Chrome/Firefox use TypeError for network-level failures / DNS issues / CORS preflight blocks
          if (e instanceof TypeError) throw new Error('Failed to fetch. The host may be unreachable or blocked by CORS.');
          throw e;
        }

        // 4) HTTP status handling
        if (!res.ok) {
          const status = `${res.status} ${res.statusText || ''}`.trim();
          if (res.status === 404) throw new Error('404: File not found at the URL.');
          if (res.status === 403) throw new Error('403: Access denied. Check permissions or CORS.');
          if (res.status === 500) throw new Error('Server error (500). Try again later.');
          throw new Error(`HTTP error: ${status}`);
        }

        // 5) Content-type sanity (warn but don’t block if missing)
        const ctype = res.headers.get('Content-Type') || '';
        if (ctype && !/text\/html|application\/xhtml\+xml/i.test(ctype)) {
          // Some hosts send text/plain for static files; allow but message if it fails later
          // We won't throw yet.
        }

        // 6) Read the HTML text
        let text = await res.text();

        // 7) Unescape if HTML-entity encoded
        if (/&lt;html\b/i.test(text) && !/<html\b/i.test(text)) {
          text = text
            .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"').replace(/&#39;/g, "'")
            .replace(/&amp;/g, '&');
        }

        // 8) Extract SOP JSON via iframe + apply
        let parsed;
        try {
          parsed = await extractSopFromHtml_viaIframe(text);
        } catch (e) {
          // Add hint if likely CORS/opaque or wrong file
          const hint = ctype && !/html/i.test(ctype) ? ' (response is not HTML)' : '';
          throw new Error((e && e.message) ? e.message + hint : 'Could not read embedded SOP JSON' + hint);
        }

        // 9) Confirm + apply (reuse your existing logic)
        return applyImportedSop(parsed, rawUrl);
      }

      // --- hardened click handler ---------------------------------------------------
      document.getElementById('imFetch')?.addEventListener('click', async () => {
        const btn = document.getElementById('imFetch');
        const input = document.getElementById('imUrl');
        const err = document.getElementById('imErrUrl');

        // UI reset
        if (err) { err.textContent = ''; err.style.display = 'block'; }
        btn.disabled = true;
        btn.dataset.label = btn.dataset.label || btn.textContent;
        btn.textContent = 'Fetching…';

        try {
          const url = (input?.value || '').trim();
          // Pre-validate to avoid firing a request for nothing
          if (!url) throw new Error('URL is required.');
          if (!isValidHttpUrl(url)) throw new Error('Enter a valid http(s) URL.');
          if (isMixedContent(url)) throw new Error('Blocked: cannot fetch http from an https page.');

          await fetchImportFromUrl(url);

          // Close dialog on success (optional)
          document.getElementById('dlgImport')?.classList.add('hidden');
        } catch (e) {
          if (err) err.textContent = (e && e.message) ? e.message : 'Import failed.';
          // console.error(e);
        } finally {
          btn.disabled = false;
          btn.textContent = btn.dataset.label || 'Fetch / Import';
        }
      });



      // expose teardown so open/close can remove DnD styles if needed
      window.teardownDnD = () => drop.classList.remove('drag');

      function resetImportDialog() {
        if (errF) errF.textContent = '';
        if (errU) errU.textContent = '';
        if (urlI) { urlI.value = ''; }
        // if (fetchB) { fetchB.disabled = true; }
      }
      window.resetImportDialog = resetImportDialog;
    })();

    //— Hook to your CURRENT import logic.
    // If you already have a function like parseApplyImportedHtml(text, sourceName), it will be used.
    // Otherwise this shows a one-time alert so you can wire it later.
    async function applyImportedHtml(htmlText, sourceName) {
      if (typeof window.parseApplyImportedHtml === 'function') {
        await window.parseApplyImportedHtml(htmlText, sourceName);
      } else if (typeof window.handleImportHtml === 'function') {
        await window.handleImportHtml(htmlText, sourceName);
      } else {
        alert('Import UI is ready. Connect it to your existing import parser (e.g., parseApplyImportedHtml).');
      }
      // Close dialog on success (optional): document.getElementById('dlgImport')?.classList.add('hidden');
    }




    async function handleImportSop() {
      // 1) pick a file
      const file = await pickFile('.html,.htm');
      if (!file) return;

      // 2) read & parse
      let text = await file.text();

      // unescape if entity-escaped html
      if (/&lt;html\b/i.test(text) && !/<html\b/i.test(text)) {
        text = text
          .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"').replace(/&#39;/g, "'")
          .replace(/&amp;/g, '&');
      }

      const doc = new DOMParser().parseFromString(text, 'text/html');
      let jsonText = '';

      // prefer your embedded viewer slot
      const slotPlain = doc.querySelector('script#jsonEmbedded');
      if (slotPlain && slotPlain.textContent.trim()) jsonText = slotPlain.textContent.trim();

      // fallback: default-sop JSON
      if (!jsonText) {
        const slotDefault = doc.querySelector('script#default-sop[type="application/json"]');
        if (slotDefault && slotDefault.textContent.trim()) jsonText = slotDefault.textContent.trim();
      }

      // fallback: any JSON script that looks like a SOP
      if (!jsonText) {
        const anyJson = Array.from(doc.querySelectorAll('script[type="application/json"]'))
          .find(s => /\bstarters\b/.test(s.textContent || ''));
        if (anyJson) jsonText = anyJson.textContent.trim();
      }

      let parsed;
      try {
        parsed = JSON.parse(jsonText);
        if (!parsed || !Array.isArray(parsed.starters)) throw new Error('Missing starters[]');
      } catch (err) {
        alert('Could not import this file.\n\n' + (err?.message || 'Invalid or missing SOP JSON.'));
        return;
      }

      // 3) confirm
      const ok = await confirmDialog({
        title: 'Import SOP?',
        message: `Replace the current SOP with “${file.name}”?`,
        confirmText: 'Import',
        cancelText: 'Cancel',
        variant: 'subtleDanger' // calm but distinct
      });
      if (!ok) return;

      // 4) apply, save, refresh UI
      sop = parsed;
      ensureSop();
      viewState.starterIdx = 0;
      // viewState.selectedStepId = sop.starters[0]?.steps?.[0]?.id || null;
      setSelectedStepById(sop.starters[0]?.steps?.[0]?.id);

      setDirty(true);
      const saved = await performSave();   // persists + updates savedSop
      if (!saved) return;

      renderViewAndEditLanding();
      changeScreen('landing');
      changeDataMode('edit');
      if (typeof updateSaveBtn === 'function') updateSaveBtn();
    }



    // tiny file picker (no permanent DOM needed)
    function pickFile(accept = '') {
      return new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        if (accept) input.accept = accept;
        input.addEventListener('change', () => resolve(input.files?.[0] || null), { once: true });
        input.click();
        // cleanup next tick
        setTimeout(() => input.remove(), 0);
      });
    }

    function setTheme(mode) {
      document.documentElement.setAttribute('data-theme', mode);
      localStorage.setItem('theme', mode);
      // if (btn) btn.textContent = (mode === 'dark') ? '🌞 Light' : '🌙 Dark';
    }

    function isDarkMode() {
      const stored = localStorage.getItem('theme');
      return stored === 'dark';
    }


    async function createNewSop() {
      const ok = await confirmDialog({
        title: 'New SOP?',
        message: 'This will delete the saved SOP in this browser and start a brand-new one.',
        confirmText: 'Proceed',
        cancelText: 'Cancel',
        variant: 'subtleDanger',
      });
      if (!ok) return;

      try { await idbDel('opsPathDB', 'sops', 'current'); } catch (e) { /* ignore */ }

      // fresh model + clean state
      sop = makeBlankSOP();
      ensureSopPositions();
      savedSop = structuredClone(sop);
      isDirty = true;
      performSave();
      isDirty = false;
      // formDirty = false;

      // reset pointers
      viewState.starterIdx = 0;
      // viewState.selectedStepId = sop.starters[0]?.steps?.[0]?.id || null;
      setSelectedStepById(sop.starters[0]?.steps?.[0]?.id);

      // show edit landing for the new SOP
      changeDataMode('edit');
      changeScreen('landing');
      renderViewAndEditLanding();
      updateSaveBtn?.();
    }

    function openSettingsMenu(anchorBtn) {
      // prevent duplicates
      if (document.getElementById('settingsOverlay')) return;

      // overlay (click outside to close)
      const overlay = document.createElement('div');
      overlay.id = 'settingsOverlay';
      overlay.className = 'settings-overlay';

      // panel
      const panel = document.createElement('div');
      panel.className = 'settings-panel';

      // current theme from DOM
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
      const options = [
        { label: 'New SOP', action: 'new-sop', attrs: { 'data-hide': 'guide' } },
        { label: 'Import', action: 'import', attrs: { 'data-hide': 'guide' } },
        { label: 'Export', action: 'export', attrs: { 'data-hide': 'guide' } },
        { label: (currentTheme === 'dark') ? '🌞 Light' : '🌙 Dark', action: 'theme' },
      ];

      // build items
      panel.innerHTML = options.map(o => {
        const base = { 'data-action': o.action, ...(o.attrs || {}) }; // ensure data-action exists
        const attrs = Object.entries(base).map(([k, v]) => {
          if (v === true) return ` ${k}`;                 // boolean attribute
          if (v === false || v == null) return '';        // skip
          return ` ${k}="${String(v).replace(/"/g, '&quot;')}"`;
        }).join('');
        return `<button class="settings-item"${attrs}>${o.label}</button>`;
      }).join('');

      // place panel near the anchor button
      document.body.appendChild(overlay);
      document.body.appendChild(panel);
      const rect = anchorBtn.getBoundingClientRect();
      const top = rect.bottom + 6 + window.scrollY;
      const left = Math.min(
        rect.left + window.scrollX,
        window.scrollX + document.documentElement.clientWidth - panel.offsetWidth - 12
      );
      panel.style.top = `${top}px`;
      panel.style.left = `${left}px`;

      // handlers
      const onItemClick = async (e) => {
        const btn = e.target.closest('.settings-item');
        if (!btn) return;
        const action = btn.getAttribute('data-action');
        if (action == "new-sop") {
          createNewSop();
        } else if (action == "import") {
          // importHTML();
          // await handleImportSop();
          openImportDialog();
        } else if (action == "export") {
          cleanup();
          exportCurrentHTMLAsViewer();

        } else if (action == "theme") {

          const nextTheme = (currentTheme === 'light') ? 'dark' : 'light';
          setTheme(nextTheme);
          // toggleTheme();

        }

        cleanup();
      };
      const onOutside = (e) => { if (e.target === overlay) cleanup(); };
      const onEsc = (e) => { if (e.key === 'Escape') cleanup(); };

      panel.addEventListener('click', onItemClick);
      overlay.addEventListener('click', onOutside);
      document.addEventListener('keydown', onEsc);

      function cleanup() {
        panel.removeEventListener('click', onItemClick);
        overlay.removeEventListener('click', onOutside);
        document.removeEventListener('keydown', onEsc);
        panel.remove();
        overlay.remove();
      }
    }

    // Wire it
    // In wireGlobal(), add:
    document.getElementById('settingsBtn')?.addEventListener('click', (e) => {
      openSettingsMenu(e.currentTarget);
    });



    function renderViewAndEditLanding() {
      const landing = document.getElementById('vwLanding');   // preview landing host
      if (!landing) return;

      // const title = String(sop?.title || 'New SOP Library');
      // const desc = String(sop?.description || 'Describe your library');
      const starters = Array.isArray(sop?.starters) ? sop.starters : [];



      const q = (viewState.searchQ || '').trim().toLowerCase();
      const filteredStarters = [];
      for (const st of sop.starters) {
        // clear previous annotation on re-render
        if ('searchPlaceStepId' in st) delete st.searchPlaceStepId;

        if (!q) { filteredStarters.push(st); continue; }

        const { matched, place } = findSearchPlaceStepId(st, q);
        if (matched) {
          if (place) st.searchPlaceStepId = place;  // "starter" or a stepId
          filteredStarters.push(st);
        }
      }

      landing.innerHTML = `
      <div class="wrap">
      <!-- VIEW block -->
        <div id="vwHeader" style="margin:16px 0 14px">
          <div id="vwSearchBar" class="vw-search">
            <label for="vwSearchInput" class="vh">Search starters</label>
            <input id="vwSearchInput" type="search" placeholder="Search ..." autocomplete="off">
          </div>
      </div>

     
    </div>

   <div class="vw-grid">
      ${filteredStarters.map((st, idx) => `
        <div class="starter-dual" data-idx="${st.id}">
          <!-- read-only card (shown in view mode) -->
          <button class="vw-card" data-idx="${st.id}" data-action="starter-view">
            <h3>${escapeHtml(st.label)}</h3>
            ${st.summary ? `<p>${escapeHtml(st.summary)}</p>` : ``}
            
            <div class="vw-card__actions">
              <div class="vw-pill">
                <span>Steps</span>
                <strong>${(typeof countFlowSteps === 'function' ? countFlowSteps(st) : (st.steps || []).length)}</strong>
              </div>

              <p class="search-place"> ${buildSearchBadge(st, q)} </p>
            </div>
          </button>

          <!-- editable card (shown in edit mode) -->
          <div class="vw-card vw-card--edit" data-action="starter-edit" data-idx="${st.id}">
            <input class="st-label" type="text"
                  placeholder="Label"
                  value="${escapeAttr(st.label)}" />
            <input class="st-summary" type="text"
                  placeholder="Summary"
                  value="${escapeAttr(st.summary || '')}" />
           
            <div class="vw-card__actions" >
              <div class="vw-pill">
                <span>Steps</span>
                <strong>${(typeof countFlowSteps === 'function' ? countFlowSteps(st) : (st.steps || []).length)}</strong>
              </div>
              <button class="cfm-btn cfm-btn--subtleDanger" data-action="starter-delete">Delete</button>
            </div>
          </div>
        </div>
      `).join('')}



      <!-- “+ New” card -->
      <button type="button" class="vw-card vw-card--add" data-action="create-starter" >
        <span class="vw-card--add-icon" >+</span>
        <h4>Create new starter</h4>
      </button>
    </div>



  </div>
`;

      // if filteredStarters is 0 show no found
      if (filteredStarters.length === 0) {
        console.log(`no starters match "${q}"`);
        const msg = document.createElement('div');
        msg.className = 'small';
        msg.textContent = `No starters match “${(viewState.searchQ || '').trim()}”.`;
        landing.appendChild(msg); // use your landing container element
      }

      const sInp = document.getElementById('vwSearchInput');
      sInp.value = viewState.searchQ || '';

      sInp.oninput = () => {
        viewState.searchQ = sInp.value;

        // preserve focus + caret before re-render
        const keepFocus = (document.activeElement === sInp);
        const selStart = sInp.selectionStart, selEnd = sInp.selectionEnd;

        renderViewAndEditLanding();

        // restore focus + caret after re-render
        if (keepFocus) {
          const s2 = document.getElementById('vwSearchInput');
          if (s2) { s2.focus(); try { s2.setSelectionRange(selStart, selEnd); } catch (_) { } }
        }
      };

      sInp.onkeydown = (e) => {
        if (e.key === 'Escape') {
          viewState.searchQ = '';
          // same preserve/restore so Esc doesn’t drop focus
          const keepFocus = (document.activeElement === sInp);
          renderViewAndEditLanding();
          if (keepFocus) {
            const s2 = document.getElementById('vwSearchInput');
            if (s2) { s2.focus(); s2.select(); }
          }
        }
      };


    }




    function isEditMode() { return document.documentElement.getAttribute('data-mode') === 'edit'; }

    // function enterViewOrEditStarter(starterId) {
    //   const idx = starterIdxById(starterId);
    //   resetStarterValues(idx);
    //   changeScreen('starter');
    //   const st = sop.starters[idx];
    //   document.getElementById('vwStarterTitle').textContent = st?.label || 'Starter';
    //   renderAll();
    // }

    // function enterViewOrEditStarter(starterId, { replace = false } = {}) {
    //   const idx = starterIdxById(starterId);
    //   if (idx < 0) return false;

    //   resetStarterValues(idx);
    //   changeScreen('starter');

    //   const st = sop.starters[idx];
    //   document.getElementById('vwStarterTitle').textContent = st?.label || 'Starter';
    //   renderAll();

    //   // Sync the URL (?starter_id=...)
    //   try {
    //     const url = new URL(location.href);
    //     if (url.searchParams.get('starter_id') !== String(starterId)) {
    //       url.searchParams.set('starter_id', String(starterId));
    //       const title = document.title;
    //       const state = { starter_id: String(starterId) };
    //       replace ? history.replaceState(state, title, url.toString())
    //         : history.pushState(state, title, url.toString());
    //     }
    //   } catch (_) { /* ignore URL/History edge cases */ }

    //   return true;
    // }

    // function enterViewOrEditStarter(starterId, { doHistory = true, replace = false } = {}) {
    //   const idx = starterIdxById(starterId);
    //   if (idx < 0) return false;

    //   resetStarterValues(idx);
    //   changeScreen('starter');
    //   document.getElementById('vwStarterTitle').textContent = sop.starters[idx]?.label || 'Starter';
    //   renderAll();

    //   // --- URL sync ---
    //   if (doHistory) {
    //     const H = window.history;                 // avoid shadowing
    //     if (H && (H.pushState || H.replaceState)) {
    //       const url = new URL(location.href);
    //       if (url.searchParams.get('starter_id') !== String(starterId)) {
    //         url.searchParams.set('starter_id', String(starterId));
    //         const state = { starter_id: String(starterId) };
    //         replace ? H.replaceState(state, '', url) : H.pushState(state, '', url);
    //       }
    //     }
    //   }
    //   return true;
    // }

    function enterViewOrEditStarter(starterId, { doHistory = true, replace = false } = {}) {
      const idx = typeof starterIdxById === 'function' ? starterIdxById(starterId) : -1;
      if (idx < 0 || !Array.isArray(sop?.starters) || !sop.starters[idx]) return false;

      resetStarterValues(idx);
      changeScreen('starter');
      const st = sop.starters[idx];
      const titleEl = document.getElementById('vwStarterTitle');
      if (titleEl) titleEl.textContent = st?.label || 'Starter';
      renderAll?.();

      // remember last
      try {
        viewState.lastStarterId = String(st.id);
        sessionStorage.setItem('last_starter_id', String(st.id));
      } catch { }

      if (doHistory) {
        const H = window.history;
        try {
          const url = new URL(location.href);
          url.searchParams.set('starter_id', String(starterId));
          const state = { starter_id: String(starterId) };
          replace ? H.replaceState(state, '', url) : H.pushState(state, '', url);
        } catch { }
      }
      return true;
    }

    function goHome({ doHistory = true } = {}) {
      changeScreen('landing');
      // clear any “current” so popstate won’t no-op
      viewState.starterIdx = -1;
      viewState.selectedStepId = null;

      if (doHistory) {
        try {
          const url = new URL(location.href);
          const hadStarter = url.searchParams.has('starter_id');
          url.searchParams.delete('starter_id');

          // Only push a Home entry if we were on a starter; otherwise don't spam history
          if (hadStarter) {
            window.history.pushState({}, '', url);
          } else {
            // already home — leave history alone
          }
        } catch { }
      }
    }

    // URL -> UI (runs for both Back and Forward)
    function applyStarterFromUrl() {
      const sp = new URLSearchParams(location.search);
      const id = sp.get('starter_id');
      if (id) {
        enterViewOrEditStarter(id, { doHistory: false }); // do not push again
      } else {
        goHome({ doHistory: false }); // do not push again
      }
    }

    // Bind once
    if (!window.__sopPopBound) {
      window.addEventListener('popstate', applyStarterFromUrl);
      window.__sopPopBound = true;
    }

    // On initial load (after your async SOP init finishes), call once:
    /// applyStarterFromUrl();



    const QUERY_KEY = 'starter_id';
    function getQueryStarterId() {
      const sp = new URLSearchParams(location.search);
      console.log(`sp`, sp);
      const v = sp.get(QUERY_KEY);
      console.log(`v`, v);
      if (v) return v.trim();
      return null;
    }

    // function applyStarterFromUrl() {
    //   const starterId = getQueryStarterId();
    //   const current = sop?.starters?.[viewState.starterIdx]?.id;
    //   if (starterId && String(starterId) !== String(current)) enterViewOrEditStarter(starterId, { doHistory: false });
    //   else if (!starterId) goHome();
    // }

    function applyStarterFromUrl() {
      const id = getQueryStarterId();
      if (id) {
        enterViewOrEditStarter(id, { doHistory: false }); // no push
      } else {
        goHome();
      }
    }




    window.addEventListener('popstate', applyStarterFromUrl);



    function starterSearchText(st) {
      const out = [];
      console.log(`st, out`, st, out);
      (function walk(v, key) {
        console.log(`v`, v);
        if (v == null) return;
        if (key === 'img_b64') return;                 // skip base64 blobs
        if (typeof v === 'string') out.push(v);
        else if (Array.isArray(v)) v.forEach(x => walk(x));
        else if (typeof v === 'object') for (const k in v) walk(v[k], k);
      })(st, '');
      return out.join(' ').toLowerCase();
    }

    // returns { matched: boolean, place: string|null }
    // place = stepId when match is inside a step; "starter" when match is outside steps; null if no match
    // returns { matched: boolean, place: string|null }
    // place = stepId when match is inside a step; "starter" when match is outside steps; null if no match
    // function findSearchPlaceStepId(st, q) {
    //   q = (q || '').trim().toLowerCase();
    //   if (!q) return { matched: true, place: null };

    //   const stepIds = new Set((st.steps || []).map(s => s?.id).filter(Boolean));

    //   // whitelist of fields we actually want to match
    //   const ALLOWED_KEYS = new Set([
    //     'id', 'label', 'summary',         // starter / step
    //     'title', 'body',                  // step (instruction/input)
    //     'placeholder', 'error', 'regex', 'requiredMessage',
    //     'hint',                    // select option text
    //   ]);

    //   // blacklist of fields/branches to skip entirely
    //   const SKIP_KEYS = new Set(['img_b64', 'pos', 'next', 'nextId', 'type', 'mode']);

    //   let matched = false;
    //   let place = null; // first hit wins

    //   (function walk(node, key, stepCtx) {
    //     if (matched || node == null) return;

    //     // entering a step object → set context to that step id
    //     if (node && typeof node === 'object' && node.id && stepIds.has(node.id)) {
    //       stepCtx = node.id;
    //     }

    //     // skip whole branches by key
    //     if (SKIP_KEYS.has(key)) return;

    //     if (typeof node === 'string') {
    //       // only match strings whose property name is allowed (root-level key may be '')
    //       if (!key || ALLOWED_KEYS.has(key)) {
    //         if (node.toLowerCase().includes(q)) {
    //           matched = true;
    //           place = stepCtx || 'starter';
    //         }
    //       }
    //     }
    //     else if (Array.isArray(node)) {
    //       for (const item of node) walk(item, '', stepCtx);
    //     }
    //     else if (typeof node === 'object') {
    //       for (const k in node) {
    //         if (SKIP_KEYS.has(k)) continue;
    //         walk(node[k], k, stepCtx);
    //       }
    //     }
    //   })(st, '', null);

    //   return { matched, place };
    // }

    // function findSearchPlaceStepId(st, q) {
    //   q = (q || '').trim().toLowerCase();
    //   if (!q) return { matched: true, place: null };

    //   const stepIds = new Set((st.steps || []).map(s => s?.id).filter(Boolean));

    //   // fields to search
    //   const ALLOWED_KEYS = new Set([
    //     'id', 'label', 'summary',
    //     'title', 'body',
    //     'placeholder', 'error', 'regex', 'requiredMessage',
    //     'hint',
    //   ]);

    //   // branches to skip entirely
    //   const SKIP_KEYS = new Set(['img_b64', 'pos', 'next', 'nextId', 'type', 'mode']);

    //   let matched = false;
    //   let place = null; // first hit wins

    //   // Build a searchable string from rich HTML:
    //   // - include visible text (between tags)
    //   // - include title="" attribute values
    //   // - ignore href entirely (so data:… base64 doesn’t match)
    //   function bodySearchHaystack(html) {
    //     if (!html || typeof html !== 'string') return '';
    //     const tpl = document.createElement('template');
    //     tpl.innerHTML = html;

    //     const parts = [];
    //     const walker = document.createTreeWalker(
    //       tpl.content,
    //       NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
    //       null
    //     );

    //     let n;
    //     while ((n = walker.nextNode())) {
    //       if (n.nodeType === Node.TEXT_NODE) {
    //         const t = n.nodeValue;
    //         if (t && t.trim()) parts.push(t);
    //       } else if (n.nodeType === Node.ELEMENT_NODE) {
    //         const el = /** @type {HTMLElement} */(n);
    //         // collect useful attributes that are human-facing
    //         const title = el.getAttribute && el.getAttribute('title');
    //         if (title && title.trim()) parts.push(title);
    //         // NOTE: intentionally do NOT read href/src/etc.
    //       }
    //     }
    //     return parts.join(' ').trim();
    //   }

    //   (function walk(node, key, stepCtx) {
    //     if (matched || node == null) return;

    //     // entering a step object → set context to that step id
    //     if (node && typeof node === 'object' && node.id && stepIds.has(node.id)) {
    //       stepCtx = node.id;
    //     }

    //     if (SKIP_KEYS.has(key)) return;

    //     if (typeof node === 'string') {
    //       if (!key || ALLOWED_KEYS.has(key)) {
    //         let hay = node;
    //         if (key === 'body') hay = bodySearchHaystack(node); // parse HTML, ignore href
    //         if (hay.toLowerCase().includes(q)) {
    //           matched = true;
    //           place = stepCtx || 'starter';
    //         }
    //       }
    //     } else if (Array.isArray(node)) {
    //       for (const item of node) walk(item, '', stepCtx);
    //     } else if (typeof node === 'object') {
    //       for (const k in node) {
    //         if (SKIP_KEYS.has(k)) continue;
    //         walk(node[k], k, stepCtx);
    //       }
    //     }
    //   })(st, '', null);

    //   return { matched, place };
    // }

    function findSearchPlaceStepId(st, q) {
      q = (q || '').trim().toLowerCase();
      if (!q) return { matched: true, place: null };

      const stepIds = new Set((st.steps || []).map(s => s?.id).filter(Boolean));

      // fields to search
      const ALLOWED_KEYS = new Set([
        'id', 'label', 'summary',
        'title', 'body',
        'placeholder', 'error', 'regex', 'requiredMessage',
        'hint',
      ]);

      // branches to skip entirely
      const SKIP_KEYS = new Set(['img_b64', 'pos', 'next', 'nextId', 'type', 'mode']);

      let matched = false;
      let place = null; // first hit wins

      // Parse rich HTML safely:
      // - include visible text + human-facing attrs
      // - ignore href/src (so data:… base64 doesn’t match)
      function bodySearchHaystack(html) {
        if (!html || typeof html !== 'string') return '';
        const tpl = document.createElement('template');
        tpl.innerHTML = html;

        const parts = [];
        const walker = document.createTreeWalker(
          tpl.content,
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
          null
        );

        let n;
        while ((n = walker.nextNode())) {
          if (n.nodeType === Node.TEXT_NODE) {
            const t = n.nodeValue;
            if (t && t.trim()) parts.push(t);
          } else if (n.nodeType === Node.ELEMENT_NODE) {
            const el = /** @type {HTMLElement} */(n);
            const title = el.getAttribute?.('title');
            const alt = el.getAttribute?.('alt');
            const aria = el.getAttribute?.('aria-label');
            if (title && title.trim()) parts.push(title);
            if (alt && alt.trim()) parts.push(alt);
            if (aria && aria.trim()) parts.push(aria);
            // intentionally skip href/src/etc. (avoid matching base64/data:)
          }
        }
        return parts.join(' ').trim();
      }

      // Look inside a single embed.html (skip scripts/styles/images + data: urls)
      function embedContainsQuery(html, q) {
        if (!html || !q) return false;
        try {
          const doc = new DOMParser().parseFromString(String(html), 'text/html');

          // strip noisy/non-text nodes
          doc.querySelectorAll('script, style, img, svg, image').forEach(n => n.remove());

          // drop any data: URLs so they don't match
          doc.querySelectorAll('[src],[href]').forEach(el => {
            ['src', 'href'].forEach(a => {
              const v = el.getAttribute(a);
              if (v && /^data:/i.test(v)) el.removeAttribute(a);
            });
          });

          // text content + a few human-facing attrs
          const text = (doc.body?.textContent || '').toLowerCase();
          if (text.includes(q)) return true;

          let found = false;
          doc.querySelectorAll('*').forEach(el => {
            if (found) return;
            for (const a of ['title', 'alt', 'aria-label']) {
              const v = el.getAttribute(a);
              if (v && v.toLowerCase().includes(q)) { found = true; break; }
            }
          });
          return found;
        } catch {
          return false;
        }
      }

      (function walk(node, key, stepCtx) {
        if (matched || node == null) return;

        // entering a step object → set context to that step id
        if (node && typeof node === 'object' && node.id && stepIds.has(node.id)) {
          stepCtx = node.id;
        }

        if (SKIP_KEYS.has(key)) return;

        // NEW: search embeds[] html, but don't recurse into it further
        if (key === 'embeds' && Array.isArray(node)) {
          for (const emb of node) {
            if (emb && typeof emb.html === 'string' && embedContainsQuery(emb.html, q)) {
              matched = true;
              place = stepCtx || 'starter';
              return;
            }
          }
          return;
        }

        if (typeof node === 'string') {
          if (!key || ALLOWED_KEYS.has(key)) {
            let hay = node;
            if (key === 'body') hay = bodySearchHaystack(node); // parse HTML, ignore href/src
            if (hay.toLowerCase().includes(q)) {
              matched = true;
              place = stepCtx || 'starter';
            }
          }
        } else if (Array.isArray(node)) {
          for (const item of node) walk(item, '', stepCtx);
        } else if (typeof node === 'object') {
          for (const k in node) {
            if (SKIP_KEYS.has(k)) continue;
            walk(node[k], k, stepCtx);
          }
        }
      })(st, '', null);

      return { matched, place };
    }






    // Run data normalization (ids/types/nexts/startId) for every starter.
    // Returns true if anything changed.
    function ensureSopMandatory() {
      // console.log('ensureSopMandatory called');
      if (!sop || !Array.isArray(sop.starters)) return false;
      let changed = false;

      for (const st of sop.starters) {
        if (!st || !Array.isArray(st.steps)) continue;

        // Legacy field: prefer startId; fall back to rootStepId if present
        if (typeof st.startId !== 'string' && typeof st.rootStepId === 'string') {
          st.startId = st.rootStepId;
          changed = true;
        }

        if (ensureMandatory(st)) changed = true;
      }
      // console.log('Starter after ensuring mandatory: ', JSON.stringify(sop.starters[0], null, 2));

      return changed;
    }

    // Ensure positions for every starter (assign only when missing).
    // Returns true if anything changed.
    function ensureSopPositions() {
      if (!sop || !Array.isArray(sop.starters)) return false;
      let changed = false;

      for (const st of sop.starters) {
        if (!st || !Array.isArray(st.steps)) continue;
        if (ensurePositions(st)) changed = true;
      }
      return changed;
    }

    // Convenience wrapper: run both; marks dirty if anything changed.
    function ensureSop() {
      const changed = !!(ensureSopMandatory() | ensureSopPositions());
      // if (changed && typeof setDirty === 'function') setDirty(true);
      return changed;
    }


    // Ensure every step has a pos; keep existing pos untouched.
    // Vertical-first grid: fills rows top→bottom, then moves to next column.

    // function ensurePositions(starter) {
    //   if (!starter) return false;
    //   const steps = starter.steps || [];
    //   if (!steps.length) return false;

    //   const x0 = 200, y0 = 60;    // start origin
    //   const colWidth = 220;       // horizontal gap
    //   const rowGap = 140;         // vertical gap

    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const hasPos = s => s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);

    //   // pick the start from starter.startId if valid; else first step
    //   const start = (typeof starter.startId === 'string' && byId[starter.startId])
    //     ? byId[starter.startId]
    //     : steps[0];

    //   console.log(`start`, start);

    //   let changed = false;
    //   const visited = new Set();

    //   // 1) Main chain: follow .next from START downward (only assigns if missing)
    //   let cur = start;
    //   let y = y0;
    //   const x = x0;
    //   const guardMax = steps.length + 5;

    //   for (let guard = 0; cur && guard < guardMax; guard++) {
    //     if (!hasPos(cur)) { cur.pos = { x, y }; changed = true; }
    //     visited.add(cur.id);

    //     const nxt = (cur.next && byId[cur.next]) ? byId[cur.next] : null;
    //     if (!nxt || visited.has(nxt.id)) break; // end/missing/cycle
    //     y += rowGap;
    //     cur = nxt;
    //   }

    //   // 2) Everything not on the main chain → top row to the right
    //   let col = 1; // start at next column so we don't overlap the start
    //   for (const s of steps) {
    //     if (visited.has(s.id)) continue;
    //     if (!hasPos(s)) {
    //       s.pos = { x: x0 + colWidth * col, y: y0 };
    //       changed = true;
    //     }
    //     visited.add(s.id);
    //     col++;
    //   }

    //   console.log(`visited`, visited);

    //   return changed;
    // }



    // function ensurePositions(starter) {
    //   if (!starter) return false;
    //   const steps = starter.steps || [];
    //   if (!steps.length) return false;
    //   // debugger;

    //   const x0 = 200, y0 = 60;    // origin
    //   const colWidth = 220;       // horizontal gap
    //   const rowGap = 140;         // vertical gap

    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const hasPos = s => s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);

    //   // pick explicit start (supports legacy rootStepId), else first step
    //   const startId =
    //     (typeof starter.startId === 'string' && byId[starter.startId]) ? starter.startId :
    //       (typeof starter.rootStepId === 'string' && byId[starter.rootStepId]) ? starter.rootStepId :
    //         steps[0].id;

    //   // compute in-degree (count step.next and select option.next)
    //   const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
    //   for (const s of steps) {
    //     if (s.next && byId[s.next]) indeg[s.next] += 1;
    //     if (s.type === 'select') {
    //       for (const o of (s.options || [])) {
    //         if (o && o.next && byId[o.next]) indeg[o.next] += 1;
    //       }
    //     }
    //   }

    //   // roots: the chosen start first, then other nodes with in-degree 0 (order preserved)
    //   const roots = [];
    //   if (byId[startId]) roots.push(byId[startId]);
    //   for (const s of steps) {
    //     if (s.id !== startId && indeg[s.id] === 0) roots.push(s);
    //   }

    //   let changed = false;
    //   const visited = new Set();
    //   let col = 0;

    //   // lay a single .next chain vertically in a column (don’t overwrite pos)
    //   const layChain = (node) => {
    //     let cur = node;
    //     let row = 0;
    //     const guardMax = steps.length + 5;
    //     for (let g = 0; cur && g < guardMax; g++) {
    //       if (!visited.has(cur.id)) {
    //         if (!hasPos(cur)) {
    //           cur.pos = { x: x0 + colWidth * col, y: y0 + rowGap * row };
    //           changed = true;
    //         }
    //         visited.add(cur.id);
    //         row++;
    //       }
    //       const nxtId = (cur.next && byId[cur.next]) ? cur.next : null;
    //       if (!nxtId || visited.has(nxtId)) break;
    //       cur = byId[nxtId];
    //     }
    //   };

    //   // 1) place each root’s chain in its own column
    //   for (const r of roots) {
    //     if (visited.has(r.id)) continue;
    //     layChain(r);
    //     col++;
    //   }

    //   // 2) any leftover nodes (cycles/broken refs) → top row to the right
    //   for (const s of steps) {
    //     if (visited.has(s.id)) continue;
    //     if (!hasPos(s)) {
    //       s.pos = { x: x0 + colWidth * col, y: y0 };
    //       changed = true;
    //     }
    //     visited.add(s.id);
    //     col++;
    //   }

    //   // normalize to startId for future saves (optional)
    //   if (starter.startId !== startId) {
    //     starter.startId = startId;
    //     changed = true;
    //   }

    //   return changed;
    // }

    // function ensurePositions(starter) {
    //   console.log('ensurePositions called');
    //   if (!starter) return false;
    //   const steps = starter.steps || [];
    //   if (!steps.length) return false;

    //   const x0 = 200, y0 = 60;    // origin
    //   const colWidth = 220;       // horizontal gap
    //   const rowGap = 140;         // vertical gap

    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const hasPos = s => s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);

    //   // explicit start (supports legacy), else first step
    //   const startId =
    //     (typeof starter.startId === 'string' && byId[starter.startId]) ? starter.startId :
    //       (typeof starter.rootStepId === 'string' && byId[starter.rootStepId]) ? starter.rootStepId :
    //         steps[0].id;

    //   // in-degree (counts step.next and select option.next)
    //   const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
    //   for (const s of steps) {
    //     if (s.next && byId[s.next]) indeg[s.next] += 1;
    //     if (s.type === 'select') {
    //       for (const o of (s.options || [])) {
    //         if (o && o.next && byId[o.next]) indeg[o.next] += 1;
    //       }
    //     }
    //   }

    //   // roots: chosen start first, then other in-degree-0 nodes
    //   const roots = [];
    //   if (byId[startId]) roots.push(byId[startId]);
    //   for (const s of steps) if (s.id !== startId && indeg[s.id] === 0) roots.push(s);

    //   let changed = false;
    //   const visited = new Set();

    //   const place = (col, row, node) => {
    //     if (!hasPos(node)) {
    //       node.pos = { x: x0 + colWidth * col, y: y0 + rowGap * row };
    //       changed = true;
    //     }
    //     visited.add(node.id);
    //   };

    //   // Lay a chain with branching:
    //   // - primary child (first) continues downward in same column
    //   // - additional children start new columns to the right at (row+1)
    //   const layFrom = (startNode, baseCol, baseRow) => {
    //     let rightmost = baseCol;
    //     let node = startNode, col = baseCol, row = baseRow;
    //     const guardMax = steps.length * 3;
    //     const queue = [];

    //     for (let g = 0; node && g < guardMax; g++) {
    //       if (!visited.has(node.id)) place(col, row, node);

    //       // gather children
    //       const children = [];
    //       if (node.type === 'select') {
    //         for (const o of (node.options || [])) {
    //           if (o && o.next && byId[o.next]) children.push(byId[o.next]);
    //         }
    //       } else if (node.next && byId[node.next]) {
    //         children.push(byId[node.next]);
    //       }

    //       if (!children.length) break;

    //       // enqueue side branches (each to the right)
    //       for (let i = 1; i < children.length; i++) {
    //         const branchCol = col + i;
    //         rightmost = Math.max(rightmost, branchCol);
    //         queue.push({ node: children[i], col: branchCol, row: row + 1 });
    //       }

    //       // continue with primary child downward
    //       node = children[0];
    //       row += 1;
    //     }

    //     // process queued branches (breadth-first)
    //     while (queue.length) {
    //       const { node: seedNode, col: seedCol, row: seedRow } = queue.shift();
    //       if (visited.has(seedNode.id)) continue;
    //       rightmost = Math.max(rightmost, layFrom(seedNode, seedCol, seedRow));
    //     }

    //     return rightmost;
    //   };

    //   // 1) layout each root chain; keep track of rightmost used column
    //   let nextRootCol = 0;
    //   for (const r of roots) {
    //     if (visited.has(r.id)) continue;
    //     const right = layFrom(r, nextRootCol, 0);
    //     nextRootCol = right + 1;
    //   }

    //   // 2) leftover nodes (cycles/broken links) → top row, continuing columns
    //   for (const s of steps) {
    //     if (visited.has(s.id)) continue;
    //     if (!hasPos(s)) {
    //       s.pos = { x: x0 + colWidth * nextRootCol, y: y0 };
    //       changed = true;
    //     }
    //     visited.add(s.id);
    //     nextRootCol++;
    //   }

    //   // normalize to startId for future saves
    //   if (starter.startId !== startId) {
    //     starter.startId = startId;
    //     changed = true;
    //   }

    //   return changed;
    // }


    function ensurePositions(starter) {
      if (!starter || !Array.isArray(starter.steps)) return false;
      const steps = starter.steps;
      if (!steps.length) return false;

      // NODES & EDGES (mirror layoutVertical)
      const nodes = steps.map(s => ({ id: s.id, pos: s.pos }));
      const edges = [];
      for (const s of steps) {
        // if instruction/input/multi-select, always follow step.next if present
        const ifSingleSelect = (s.type === 'select' && s.mode === 'single');
        if (!ifSingleSelect && s.next) edges.push({ from: s.id, to: s.next });
        else if (ifSingleSelect) {
          for (const o of (s.options || [])) if (o && o.next) edges.push({ from: s.id, to: o.next });
        }
      }

      if (!nodes.length) return false;

      // adjacency
      const adj = {};
      nodes.forEach(n => adj[n.id] = []);
      edges.forEach(e => { (adj[e.from] ||= []).push(e.to); });

      // depths from FIRST node (same as layoutVertical)
      const depth = {};
      const start = nodes[0].id;
      depth[start] = 0;

      // BFS
      const q = [start];
      while (q.length) {
        const u = q.shift();
        for (const v of adj[u] || []) {
          if (depth[v] == null) {
            depth[v] = (depth[u] || 0) + 1;
            q.push(v);
          }
        }
      }
      // unreached → depth 0
      nodes.forEach(n => { if (depth[n.id] == null) depth[n.id] = 0; });

      // relax so every edge goes downward
      let changedDepth = true, guard = 0;
      while (changedDepth && guard < 50) {
        changedDepth = false; guard++;
        for (const e of edges) {
          const a = depth[e.from], b = depth[e.to];
          if (a != null && b != null && b <= a) {
            depth[e.to] = a + 1;
            changedDepth = true;
          }
        }
      }

      // rows & stable order within row
      // const rows = {};
      // nodes.forEach(n => {
      //   const d = depth[n.id] || 0;
      //   (rows[d] ||= []).push(n.id);
      // });
      // const colIndex = {};
      // Object.keys(rows).sort((a, b) => a - b).forEach(d => {
      //   rows[d].forEach((id, i) => colIndex[id] = i);
      // });

      // // compute lane positions (same constants as layoutVertical)
      // const colWidth = 200;    // horizontal spacing
      // const rowGap = 140;     // vertical spacing
      // const x0 = 200, y0 = 60; // origin

      // // WRITE BACK positions only if missing
      // let wroteAny = false;
      // for (const n of nodes) {
      //   const s = steps.find(x => x.id === n.id);
      //   const has = s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);
      //   if (!has) {
      //     const d = depth[n.id] || 0;
      //     const i = colIndex[n.id] || 0;
      //     s.pos = { x: x0 + i * colWidth, y: y0 + d * rowGap };
      //     wroteAny = true;
      //   }
      // }

      // if (wroteAny && typeof setDirty === 'function') setDirty(true);

      // --- build lookup for step meta ---
      const byId = new Map(steps.map(s => [s.id, s]));
      const isSingleSelect = (id) => {
        const s = byId.get(id);
        return s && s.type === 'select' && s.mode === 'single';
      };

      // --- group nodes by depth ---
      const depthNodes = {};
      nodes.forEach(n => {
        const d = depth[n.id] || 0;
        (depthNodes[d] ||= []).push(n.id);
      });

      // --- assign columns per depth with left/right fan-out ---
      const colIndex = {};           // id -> absolute column (can be negative)
      let minCol = Infinity;         // track global min to normalize later
      let maxDepth = Math.max(...Object.values(depth).map(d => d || 0));

      // seed depth 0 (start column = 0)
      (depthNodes[0] || []).forEach((id, i) => {  // usually one node
        colIndex[id] = 0 + i;                     // if multiple, spread to the right
        if (colIndex[id] < minCol) minCol = colIndex[id];
      });

      // process from d=1 to bottom
      for (let d = 1; d <= maxDepth; d++) {
        const levelIds = (depthNodes[d] || []).slice(); // shallow copy
        if (!levelIds.length) continue;

        // desired columns from parents at d-1
        const occupied = new Set();   // columns already taken at this depth
        const desiredCol = new Map(); // id -> wished column

        // build reverse adjacency (parents) quickly when needed
        const parentsOf = (vid) => {
          const ps = [];
          for (const e of edges) if (e.to === vid) ps.push(e.from);
          return ps;
        };

        // for each parent at d-1 that is single-select, fan its children at d
        for (const pid of (depthNodes[d - 1] || [])) {
          if (!isSingleSelect(pid)) continue;

          const pcol = colIndex[pid] ?? 0;
          const kids = (adj[pid] || []).filter(k => (depth[k] || 0) === d);

          if (!kids.length) continue;

          // offsets pattern: 1 -> [+1], else [-1,+1,-2,+2,...]
          const offsets = (kids.length === 1)
            ? [+1]
            : Array.from({ length: kids.length }, (_, i) =>
              (i % 2 === 0 ? -(i / 2 + 1) : (Math.floor(i / 2) + 1))
            );

          kids.forEach((kid, idx) => {
            const wish = pcol + offsets[idx];
            if (!desiredCol.has(kid)) desiredCol.set(kid, wish);
          });
        }

        // place nodes that have desired columns first (resolve collisions nearest to desired)
        function placeAtNearestFree(id, wish) {
          let delta = 0;
          let chosen = wish;
          while (occupied.has(chosen)) {
            delta++;
            // prefer the side that keeps things compact: try +delta then -delta
            const rightTry = wish + delta;
            const leftTry = wish - delta;
            if (!occupied.has(rightTry)) { chosen = rightTry; break; }
            if (!occupied.has(leftTry)) { chosen = leftTry; break; }
          }
          colIndex[id] = chosen;
          occupied.add(chosen);
          if (chosen < minCol) minCol = chosen;
        }

        // sort to stabilize placement (optional: by desired, then id)
        const withDesired = levelIds.filter(id => desiredCol.has(id))
          .sort((a, b) => (desiredCol.get(a) - desiredCol.get(b)) || String(a).localeCompare(String(b)));
        withDesired.forEach(id => placeAtNearestFree(id, desiredCol.get(id)));

        // place the rest in remaining nearest-to-0 slots (stable order)
        const rest = levelIds.filter(id => !desiredCol.has(id));
        let probe = 0;
        const nextFree = () => {
          // find nearest free around 0 to keep compact
          if (!occupied.has(0)) return 0;
          let k = 1;
          while (true) {
            if (!occupied.has(-k)) return -k;
            if (!occupied.has(+k)) return +k;
            k++;
          }
        };
        rest.forEach(id => {
          const c = nextFree();
          colIndex[id] = c;
          occupied.add(c);
          if (c < minCol) minCol = c;
        });
      }

      // --- WRITE BACK positions (normalize columns so x >= 0) ---


      const colWidth = 200;  // horizontal spacing
      const rowGap = 140;  // vertical spacing
      const x0 = 200, y0 = 60;

      let wroteAny = false;
      for (const n of nodes) {
        const s = steps.find(x => x.id === n.id);
        const has = s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);
        if (!has) {
          const d = depth[n.id] || 0;
          // const ci = colIndex[n.id] ??   0;
          const ci = colIndex[n.id] ?? 0;
          const cx = (ci - (Number.isFinite(minCol) ? minCol : 0)); // shift so leftmost is 0
          s.pos = { x: x0 + ci * colWidth, y: y0 + d * rowGap };
          // s.pos = { x: x0 + cx * colWidth, y: y0 + d * rowGap };
          wroteAny = true;
        }
      }

      return wroteAny;
    }







    // Normalize & validate a starter in place.
    // - Converts legacy `end` steps → `instruction` (implicit ends = no `next`)
    // - Ensures a single valid `startId` on the starter (defaults to a root or first step)
    // - Ensures step ids are unique
    // - Cleans invalid/empty `next` refs
    // - Normalizes select steps (options array, unique option values)
    // Returns true if it changed anything.
    function ensureMandatory(starter) {
      if (!starter || !Array.isArray(starter.steps)) return false;
      const steps = starter.steps;
      if (!steps.length) return false;

      let changed = false;

      // 0) Ensure starter label exists: "starter <idx>"
      if (typeof starter.label !== 'string' || !starter.label.trim()) {
        const idx = (Array.isArray(sop?.starters) ? sop.starters.indexOf(starter) : -1);
        const n = (idx >= 0 ? idx + 1 : 1);
        starter.label = 'starter ' + n; // as requested: "starter + idx"
        changed = true;
      }

      // 1) Make step ids unique (stable rename with suffixes when needed)
      // const seen = new Set();
      // for (const s of steps) {
      //   if (typeof s.id !== 'string' || !s.id.trim()) {
      //     s.id = 'step'; changed = true;
      //   }
      //   let base = s.id.trim();
      //   let out = base, i = 1;
      //   while (seen.has(out)) { out = base + '_' + (++i); }
      //   if (out !== s.id) { s.id = out; changed = true; }
      //   seen.add(out);
      // }

      // 2) Legacy type: 'end' → 'instruction' (implicit end = no next)
      // for (const s of steps) {
      //   if (s.type !== 'instruction' || s.type !== 'input' || s.type !== 'select') {
      //     s.type = 'instruction'; changed = true;
      //   }
      // }

      // 2) Normalize type and coerce unknowns → 'instruction'
      for (const s of steps) {
        let t = (s.type ?? 'instruction');
        if (typeof t !== 'string') t = 'instruction';
        t = t.trim().toLowerCase();

        if (t !== 'instruction' && t !== 'input' && t !== 'select') {
          if (s.type !== 'instruction') { s.type = 'instruction'; changed = true; }
        } else if (s.type !== t) {
          s.type = t; // normalize casing
          changed = true;
        }
      }


      // 3) Build byId and clean `next` (empty or missing target -> remove)
      const byId = Object.fromEntries(steps.map(s => [s.id, s]));
      for (const s of steps) {
        if (s.next == null || s.next === '') continue;
        if (!byId[s.next]) { delete s.next; changed = true; }
      }

      // 4) Normalize select steps
      for (const s of steps) {
        if (s.type !== 'select') continue;
        if (!Array.isArray(s.options)) { s.options = []; changed = true; }
        // Ensure unique option values and non-empty labels
        const valSeen = new Set();
        for (let i = 0; i < s.options.length; i++) {
          const o = s.options[i] || {};
          if (typeof o.value !== 'string' || !o.value) { o.value = 'opt' + (i + 1); changed = true; }
          if (typeof o.label !== 'string') { o.label = String(o.value); changed = true; }
          // Dedup option values by suffixing
          let v = o.value, k = 1;
          while (valSeen.has(v)) { v = o.value + '_' + (++k); }
          if (v !== o.value) { o.value = v; changed = true; }
          valSeen.add(o.value);
          // Clean empty next on options
          if (o.next === '') { delete o.next; changed = true; }
          s.options[i] = o;
        }
        // Mode defaults
        if (s.mode !== 'multi' && s.mode !== 'single') { s.mode = 'single'; changed = true; }
      }

      // 5) Ensure single valid startId at starter level
      //    Prefer a node with in-degree 0; among them prefer one that has an outgoing edge; else first.
      // if (!(typeof starter.startId === 'string' && byId[starter.startId])) {

      //   const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
      //   for (const s of steps) {
      //     if (s.next && byId[s.next]) indeg[s.next] += 1;
      //     if (s.type === 'select') {
      //       for (const o of (s.options || [])) {
      //         if (o && o.next && byId[o.next]) indeg[o.next] += 1;
      //       }
      //     }
      //   }

      //   // roots: in-degree = 0, kept in original order
      //   const roots = steps.filter(s => indeg[s.id] === 0);

      //   // helper: does this step have any outgoing edge?
      //   const hasOut = (s) =>
      //     !!s.next ||
      //     (s.type === 'select' && (s.options || []).some(o => o && o.next));

      //   let candidate = steps[0]; // fallback
      //   if (roots.length) {
      //     const prefer = roots.find(hasOut);
      //     candidate = prefer || roots[0];
      //   }

      //   if (typeof starter.startId !== 'string' || !byId[starter.startId]) {
      //     starter.startId = candidate.id;
      //     changed = true;
      //   }


      // }


      // if (!(typeof starter.startId === 'string' && byId[starter.startId])) {
      // starter.startId = candidate.id;

      if (ensureStarterStartId(starter)) {
        changed = true;
      }
      // }
      return changed;
    }

    function ensureStarterStartId(starter) {
      const startId = getStarterStartId(starter);
      if (startId && starter.startId !== startId) {
        starter.startId = startId;
        changed = true;
      }
    }
    // Decide the best start step id for a single starter and set it.
    // Rules:
    // 1) Prefer roots (in-degree 0) that have an outgoing edge (step.next or select option.next).
    // 2) If multiple, take the first by steps order.
    // 3) Else fall back to any root.
    // 4) Else fall back to the first step.
    function getStarterStartId(starter) {
      if (!starter || !Array.isArray(starter.steps) || starter.steps.length === 0) return null;

      const steps = starter.steps;
      const byId = Object.fromEntries(steps.map(s => [s.id, s]));

      // in-degree (count step.next and select option.next)
      const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
      for (const s of steps) {
        if (s.next && byId[s.next]) indeg[s.next] += 1;
        if (s.type === 'select') {
          for (const o of (s.options || [])) {
            if (o && o.next && byId[o.next]) indeg[o.next] += 1;
          }
        }
      }

      const hasOut = (s) => !!s.next || (s.type === 'select' && (s.options || []).some(o => o && o.next));

      const rootWithOut = steps.filter(s => indeg[s.id] === 0 && hasOut(s));
      const anyRoot = steps.filter(s => indeg[s.id] === 0);

      const candidate =
        rootWithOut[0] ||   // best: root that leads somewhere
        anyRoot[0] ||     // otherwise: any root
        steps.find(hasOut) || // otherwise: any node that leads somewhere
        steps[0];           // absolute fallback

      const startId = candidate?.id || null;

      return startId;
    }


    // Wire live editing of title/description (landing, edit mode)
    (function wireTitleDesc() {
      if (window.titleDescWired) return; window.titleDescWired = true;

      document.addEventListener('input', (e) => {
        // debugger;
        if (!isEditMode()) return;
        const t = e.target;
        if (t.id !== 'sop-run-mode-title-input') return;

        const v = (t.value || '').trim();

        if (t.id === 'sop-run-mode-title-input') {
          if ((sop.title || '') !== v) {
            sop.title = v;
            renderSopTitle();
            setDirty?.(true);

          }
          return;
        }

      }, true);
    })();


    // Inline edit for starter cards (landing, edit mode)
    let starterCardWired = false;
    (function wireStarterCards() {
      if (starterCardWired) return; starterCardWired = true;

      // Update label/summary live
      document.addEventListener('input', (e) => {

        if (!isEditMode()) return;

        const inp = e.target;
        if (!inp.classList?.contains('st-label') && !inp.classList?.contains('st-summary')) return;
        const card = inp.closest('.vw-card--edit');
        if (!card) return;

        const starterId = card.dataset.idx;
        const idx = starterIdxById(starterId);

        const st = sop.starters[idx]; if (!st) return;

        if (inp.classList.contains('st-label')) st.label = inp.value;

        if (inp.classList.contains('st-summary')) st.summary = inp.value;

        setDirty?.(true);
      }, true);

      // Edit / Delete buttons
      // document.addEventListener('click', (e) => {
      //   const btn = e.target.closest('[data-action="starter-edit"],[data-action="starter-delete"]');
      //   if (!btn) return;
      //   const idx = parseInt(btn.dataset.idx, 10);


      document.addEventListener('click', async (e) => {
        // delete button inside the card
        const view = e.target.closest('[data-action="starter-view"]');
        const edit = e.target.closest('[data-action="starter-edit"]');

        // we must start check delete to prevent conflict with edit and delete button inside the card
        const del = e.target.closest('[data-action="starter-delete"]');
        // console.log(`view`, view);
        // console.log(`edit`, edit);
        // console.log(`del`, del);
        if (del) {
          const card = del.closest('.vw-card[data-idx]');
          if (!card) return;
          const starterId = card.dataset.idx;
          const starterIdx = starterIdxById(starterId);
          const currentStarter = sop.starters[starterIdx];
          const label = currentStarter?.label || `Starter ${starterId}`;

          let haveOneStarterOnly = false;
          if (sop?.starters?.length === 1) {
            haveOneStarterOnly = await confirmDialog({
              // title: '??',
              title: 'You must have at least one starter.',
              confirmText: 'Okay',
              // cancelText: 'Cancel',
              variant: 'neutral',
              one: true
            });
          }
          if (haveOneStarterOnly) return;
          const ok = await confirmDialog({
            title: `Delete “${label}”?`,
            message: `Are you sure you want to delete “${label}” and  all its steps? This action cannot be undone.`,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            variant: 'subtleDanger'   // ← small “danger” cue, not aggressive
          });

          if (!ok) return;

          deleteStarter(starterIdx);

          setDirty?.(true);
          renderViewAndEditLanding();
          return;
        } else if (view || (edit && !e.target.closest('input, textarea, select, [contenteditable="true"]'))) {
          const card = (view || edit)?.closest('.vw-card[data-idx]');
          if (!card) return;
          // const idx = parseInt(card.dataset.idx, 10);
          const starterId = card.dataset.idx;
          // const starterIdx = starterIdxById(starterId);
          enterViewOrEditStarter(starterId);
          return;
        }

      });

    })();

    function getStepIndexById(steps, id) {
      if (!Array.isArray(steps) || steps.length === 0) return 0;
      if (typeof id !== 'string') return 0;
      const i = steps.findIndex(s => s && s.id === id);
      return (i >= 0) ? i : 0;
    }

    // helper: find starter index by stable id
    function starterIdxById(id) {
      return sop?.starters ? sop.starters.findIndex(s => s.id === id) : -1;
    }

    // Reset viewState for a given starter index (or 0 if invalid).
    // Sets stepIdx to the starter's startId (or 0 if invalid).
    function resetStarterValues(starterIdx) {
      const starters = sop?.starters || [];
      const si = (Number.isInteger(starterIdx) && starterIdx >= 0 && starterIdx < starters.length) ? starterIdx : 0;

      viewState.starterIdx = si;
      viewState.answers = {};

      const st = starters[si];
      const steps = st?.steps || [];
      const startId = (typeof st?.startId === 'string') ? st.startId : steps[0]?.id;
      // const startId = 2;

      // viewState.stepIdx = getStepIndexById(steps, startId);
      // viewState.selectedStepId = startId || null;
      setSelectedStepById(startId);

      viewState.history = [];
    }
    // Creates a new starter, re-renders grid (optional), and returns its index.
    function createNewStarter() {
      // const starterIdx = 
      // viewState.selectedStepId = starterIdx;
      const idx = sop.starters.length;

      const newStarter = {
        id: 'starter_' + (idx + 1),
        label: 'Starter ' + (idx + 1),
        steps: []
      };

      const step1 = makeStep('instruction', newStarter);
      step1.id = "welcome_step";
      step1.label = "Welcome";
      newStarter.steps.push(step1);

      const step2 = makeStep('instruction', newStarter);
      step2.id = "end_step";
      step2.label = "The End";
      newStarter.steps.push(step2);

      step1.next = step2.id;

      sop.starters.push(newStarter);
      ensureMandatory(newStarter);
      ensurePositions(newStarter);

      // console.log(`newStarter`, newStarter);
      return sop.starters.length - 1;
    }

    function deleteStarter(idx) {
      const starters = (sop && Array.isArray(sop.starters)) ? sop.starters : null;
      if (!starters || idx == null || idx < 0 || idx >= starters.length) return;

      // remove
      starters.splice(idx, 1);

      // fix selection/index if needed
      if (typeof viewState === 'object') {
        const n = starters.length;
        if (typeof viewState.currentStarterIdx === 'number') {
          if (viewState.currentStarterIdx === idx) {
            viewState.currentStarterIdx = Math.min(idx, n - 1);
          } else if (viewState.currentStarterIdx > idx) {
            viewState.currentStarterIdx -= 1;
          }
        }
      }
    }



    document.addEventListener('click', onCreateStarterClick);

    function onCreateStarterClick(e) {
      const add = e.target.closest('[data-action="create-starter"], .vw-card--add');
      if (!add) return;
      openNewStarterDialog();
    }

    function openNewStarterDialog() {
      const modal = document.getElementById('dlgNewStarter');
      if (!modal) return; // fail-safe

      const labelI = document.getElementById('nsLabel');
      const summaryI = document.getElementById('nsSummary');
      const btnCreate = document.getElementById('nsCreate');
      const btnCancel = document.getElementById('nsCancel');
      const labelErr = document.getElementById('nsLabelErr');

      // seed defaults + reset errors
      labelI.value = `Starter ${sop.starters.length + 1}`;
      summaryI.value = '';
      labelI.classList.remove('is-invalid');
      if (labelErr) labelErr.textContent = '';

      // helpers
      const clearInvalid = () => {
        if (labelI.value.trim()) {
          labelI.classList.remove('is-invalid');
          if (labelErr) labelErr.textContent = '';
        }
      };
      const onOverlay = (ev) => { if (ev.target === modal) cleanup(); };
      const onCancel = () => cleanup();
      const onEsc = (ev) => { if (ev.key === 'Escape') cleanup(); };

      const onCreate = () => {
        const label = (labelI.value || '').trim();
        if (!label) {
          labelI.classList.add('is-invalid');
          if (labelErr) labelErr.textContent = 'Label is required';
          labelI.focus();
          return;
        }
        const exists = sop.starters.some(s =>
          (s && typeof s.label === 'string' ? s.label.trim().toLowerCase() : '') === label.toLowerCase()
        );
        if (exists) {
          labelI.classList.add('is-invalid');
          if (labelErr) labelErr.textContent = 'Label must be unique';
          labelI.focus();
          return;
        }

        const idx = createNewStarter(); // pushes new object, returns index
        const st = sop.starters[idx];
        st.label = label;
        st.summary = (summaryI.value || '').trim();

        cleanup();

        // if (typeof renderStarters === 'function')
        if (viewState) viewState.starterIdx = idx;
        setDirty(true);
        enterViewOrEditStarter(st.id);
      };

      function cleanup() {
        modal.classList.add('hidden');
        btnCreate.removeEventListener('click', onCreate);
        btnCancel.removeEventListener('click', onCancel);
        modal.removeEventListener('click', onOverlay);
        document.removeEventListener('keydown', onEsc);
        labelI.removeEventListener('input', clearInvalid);
      }

      // open
      modal.classList.remove('hidden');
      setTimeout(() => labelI.focus(), 0);

      // one-time listeners per open
      labelI.addEventListener('input', clearInvalid, { passive: true });
      btnCreate.addEventListener('click', onCreate);
      btnCancel.addEventListener('click', onCancel);
      modal.addEventListener('click', onOverlay);
      document.addEventListener('keydown', onEsc);
    }


    function setNextEnabled(enabled) {
      const btn = document.getElementById('vwNext');
      if (!btn) return;
      // console.log(`btn`, btn);
      // console.log(`enabled`, enabled);
      btn.disabled = !enabled; // enable when true, disable when false
      // btn.disabled = true; // enable when true, disable when false
    }


    // function validateValueForStep(step, value) {
    //   if (step.type === 'input') {
    //     if (!String(value || '').trim()) return { ok: false, msg: step.requiredMessage || 'This field is required' };
    //   }
    //   else if (step.type === 'select' && step.mode === 'single' && !value) {
    //     return {
    //       ok: false, msg: step.requiredMessage || 'Please choose an option'
    //     };
    //   }
    //   if (step.type === 'input' && step.regex) {
    //     if (value.trim() === '') return { ok: false, msg: 'Invalid format' };
    //     try {
    //       const re = new RegExp(step.regex);
    //       if (!re.test(String(value || ''))) return { ok: false, msg: step.error || 'Invalid format' };
    //     } catch (e) { /* ignore invalid regex */ }
    //   }
    //   if (step.type === 'select' && step.mode === 'multi') {
    //     const count = Array.isArray(value) ? value.length : 0;
    //     if (typeof step.min === 'number' && count < step.min) return { ok: false, msg: step.minMessage || `Select at least ${step.min}` };
    //     if (typeof step.max === 'number' && count > step.max) return { ok: false, msg: step.maxMessage || `Select at most ${step.max}` };
    //   }
    //   return { ok: true, msg: '' };
    // }

    function validateValueForStep(step, value) {
      // ----- END STEP: always disable -----
      console.log(`isEndStep(step)`, isEndStep(step));
      if (typeof isEndStep === 'function' && isEndStep(step)) {
        return { ok: false, msg: '', end: true }; // end=true helps callers if needed
      }

      const type = step?.type;
      const mode = step?.mode;
      const valStr = String(value ?? '');
      const valTrim = valStr.trim();

      // ----- INPUT -----
      if (type === 'input') {
        if (!valTrim) {
          return { ok: false, msg: step?.requiredMessage || 'This field is required' };
        }
        if (step?.regex) {
          try {
            const re = step.__re || (step.__re = new RegExp(step.regex)); // cache compiled regex
            if (!re.test(valStr)) return { ok: false, msg: step?.error || 'Invalid format' };
          } catch { /* ignore invalid regex */ }
        }
        return { ok: true, msg: '' };
      }

      // ----- SELECT -----
      if (type === 'select') {
        if (mode === 'single') {
          if (!value) return { ok: false, msg: step?.requiredMessage || 'Please choose an option' };
          return { ok: true, msg: '' };
        }
        // multi
        const count = Array.isArray(value) ? value.length : 0;
        if (typeof step?.min === 'number' && count < step.min) {
          return { ok: false, msg: step?.minMessage || `Select at least ${step.min}` };
        }
        if (typeof step?.max === 'number' && count > step.max) {
          return { ok: false, msg: step?.maxMessage || `Select at most ${step.max}` };
        }
        return { ok: true, msg: '' };
      }

      // default: pass-through
      return { ok: true, msg: '' };
    }


    // has no next step implicitly (no indicator)
    // const isEndStep = (s) => !s?.next;

    const isEndStep = (s) => {
      if (!s || typeof s !== 'object') return true;

      if (s.type === 'select') {
        if (s.mode === 'multi') {
          // select + multi: NOT end if step.next exists
          return !s.next;
        }
        // select + single: NOT end if at least one option has next
        const opts = Array.isArray(s.options) ? s.options : [];
        const anyOptHasNext = opts.some(o => o && o.next);
        return !anyOptHasNext;
      }

      // all other types: NOT end if step.next exists
      return !s.next;
    };

    // shortest hop count from start to target stepId, following real edges
    // - instruction/input/multi → step.next
    // - single-select → all option.next
    // returns 0-based hops from start, or -1 if unreachable
    function stepHopsFromStart(starter, targetId) {
      const steps = starter?.steps || [];
      if (!steps.length || !targetId) return -1;

      const startId = starter.startId || getStarterStartId(starter);
      if (!startId) return -1;

      const dist = new Map([[startId, 0]]);
      const q = [startId];

      while (q.length) {
        const id = q.shift();
        if (id === targetId) return dist.get(id);

        const i = getStepIndexById(steps, id);
        const s = steps[i];
        if (!s) continue;

        const push = (nid) => {
          if (!nid) return;
          if (!dist.has(nid)) { dist.set(nid, dist.get(id) + 1); q.push(nid); }
        };

        if (s.type === 'select' && s.mode === 'single') {
          (s.options || []).forEach(o => push(o && o.next));
        } else {
          push(s.next);
        }
      }
      return -1;
    }

    // Build the small “found in …” label for a starter and current query.
    // Uses your existing findSearchPlaceStepId(st, q)
    function buildSearchBadge(starter, q) {
      q = (q || '').trim();
      if (!q) return '';

      const res = findSearchPlaceStepId(starter, q);
      if (!res.matched) return '';

      if (res.place === 'starter') return 'Found in starter';
      // place is a stepId
      const hops = stepHopsFromStart(starter, res.place);
      if (hops < 0) {
        return `Found around step: ${res.place} <span class="warn">(unreachable)</span>`;
      } else {
        // show 1-based position from start for humans
        return `Found around step: ${hops + 1}`;
      }
    }

    // Linearize the path for THIS run, honoring current answers.
    // Returns an array of step IDs in the order they'd be visited.
    // function computeProjectedPath(starter, answers = {}) {
    //   if (!starter) return [];
    //   const steps = starter.steps || [];
    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const seen = new Set();                         // guard against cycles
    //   const path = [];

    //   let id = starter.startId || steps[0]?.id || null;
    //   while (id && !seen.has(id)) {
    //     const step = byId[id]; if (!step) break;
    //     path.push(id);
    //     seen.add(id);

    //     // decide next
    //     let nextId = null;
    //     if (step.type === 'select' && step.mode === 'single') {
    //       const choice = answers[step.id];            // you already store the chosen option object
    //       nextId = choice?.next || step.next || null; // prefer chosen option.next, else fallback
    //     } else if (step.type === 'select' && step.mode === 'multi') {
    //       nextId = step.next || null;                 // multi branches continue via step.next
    //     } else {
    //       nextId = step.next || null;                 // instruction/input
    //     }

    //     if (!nextId) break;
    //     id = nextId;
    //   }
    //   return path;
    // }

    // // Update "Step N of M" using the projected path & current selection
    // function updateProgressLabel() {
    //   const st = getStarter();
    //   const path = computeProjectedPath(st, viewState.answers || {});
    //   const curId = viewState.selectedStepId;
    //   const idx = Math.max(0, path.indexOf(curId));   // if not found, show as first
    //   const total = path.length || 1;
    //   document.getElementById('vwProgress').textContent = `Step ${idx + 1} of ${total}`;
    // }


    function countFlowSteps(starter) {
      const steps = starter?.steps || [];

      if (!steps.length) return 0;

      const startId = starter.startId || getStarterStartId(starter);
      if (!startId) return 0;

      let id = startId;
      const seen = new Set();
      let cnt = 0;

      // follow: instruction/input/multi → step.next ; single-select → first option.next
      while (id && !seen.has(id) && cnt <= steps.length + 5) {
        seen.add(id);
        cnt++;

        const idx = getStepIndexById(steps, id);
        const cur = steps[idx];
        if (!cur) break;

        if (cur.type === 'select' && cur.mode === 'single') {
          const opt = (cur.options || []).find(o => o && o.next);
          id = opt ? opt.next : null;
        } else {
          id = cur.next || null;
        }
      }
      return cnt;
    }

    function getReachableStepIndex(starter, targetId) {
      const steps = starter?.steps || [];
      if (!steps.length || !targetId) return `unreachable "${targetId}"`;

      const startId = starter.startId || getStarterStartId(starter);
      if (!startId) return `unreachable "${targetId}"`;

      const seen = new Set();
      const stack = [startId];

      while (stack.length) {
        const id = stack.pop();
        if (!id || seen.has(id)) continue;
        seen.add(id);

        if (id === targetId) return getStepIndexById(steps, id);

        const idx = getStepIndexById(steps, id);
        const cur = steps[idx];
        if (!cur) continue;

        if (cur.type === 'select' && cur.mode === 'single') {
          // explore all option.next
          (cur.options || []).forEach(o => { if (o && o.next) stack.push(o.next); });
        } else {
          // instruction / input / multi-select use step.next
          if (cur.next) stack.push(cur.next);
        }
      }

      return `unreachable "${targetId}"`;
    }




    // function renderViewStep() {

    //   const st = sop.starters[viewState.starterIdx];
    //   const steps = st.steps || [];
    //   let i = getStepIndexById(steps, viewState.selectedStepId);

    //   const box = document.getElementById('vwStep');
    //   box.innerHTML = '';
    //   const step = steps[i];
    //   const head = step.title ? `<div class="vw-head"><h3 id="vw-head">${viewEscape(step.title)}</h3></div>` : '';

    //   if (!step) { setNextEnabled(false); return; }
    //   // const isDoneStep = step.type === 'end';

    //   let node;
    //   if (step.type === 'instruction') {
    //     node = document.createElement('div');

    //     // hello


    //     node.innerHTML = `
    //   ${head}
    //   ${renderBody(step.body)}
    //   ${step.img_b64 ? `<img class="thumb" src="${step.img_b64}" alt="">` : ''}
    // `;
    //     box.appendChild(node);
    //     setNextEnabled(true);
    //   }
    //   else if (step.type === 'input') {
    //     node = document.createElement('div');
    //     node.innerHTML = `
    //   ${step.title ? `<label for="vw_inp">${viewEscape(step.title)}</label>` : ''}
    //   <input id="vw_inp" type="text" class="text-input" placeholder="${viewEscape(step.placeholder || '')}">
    //   ${step.img_b64 ? `<img class="thumb" src="${step.img_b64}" alt="">` : ''}
    // `;
    //     box.appendChild(node);
    //     const inp = node.querySelector('#vw_inp');
    //     const img = node.querySelector('.thumb');              // ← add this
    //     inp.value = viewState.answers[step.id] || '';
    //     const err = document.createElement('div');
    //     err.className = 'error';
    //     err.style.display = 'none';
    //     // node.appendChild(err);                               // ← remove this
    //     img ? img.before(err) : inp.insertAdjacentElement('afterend', err);  // ← insert here


    //     function refreshInput() {
    //       const res = validateValueForStep(step, inp.value);
    //       err.textContent = res.ok ? '' : res.msg;
    //       err.style.display = res.ok ? 'none' : '';
    //       setNextEnabled(res.ok);
    //     }
    //     inp.addEventListener('input', () => {
    //       viewState.answers[step.id] = inp.value;
    //       // console.log(`answers`, viewState.answers);
    //       refreshInput();
    //     });
    //     refreshInput();  // initial

    //   }
    //   else if (step.type === 'select') {
    //     node = document.createElement('div');
    //     if (step.title) node.innerHTML = `<h3>${viewEscape(step.title)}</h3>`;
    //     const wrap = document.createElement('div');
    //     wrap.className = 'vw-grid-sel';
    //     const mode = step.mode === 'multi' ? 'multi' : 'single';
    //     let sel = viewState.answers[step.id] ?? (mode === 'multi' ? [] : null);

    //     (step.options || []).forEach(opt => {
    //       const btn = document.createElement('button');
    //       btn.className = 'vw-option';
    //       btn.innerHTML = `<strong>${viewEscape(opt.label)}</strong>${opt.hint ? `<div class="small">${viewEscape(opt.hint)}</div>` : ''}`;
    //       const isSel = mode === 'multi' ? (Array.isArray(sel) && sel.some(o => (o?.value ?? o) === opt.value))
    //         : (sel && ((sel?.value ?? sel) === opt.value));
    //       if (isSel) btn.classList.add('selected');
    //       btn.addEventListener('click', () => {
    //         if (mode === 'multi') {
    //           sel = Array.isArray(viewState.answers[step.id]) ? [...viewState.answers[step.id]] : [];
    //           const k = sel.findIndex(o => (o?.value ?? o) === opt.value);
    //           if (k >= 0) { sel.splice(k, 1); btn.classList.remove('selected'); }
    //           else { sel.push({ value: opt.value, label: opt.label }); btn.classList.add('selected'); }
    //           viewState.answers[step.id] = sel;
    //           // setNextEnabled(sel.length > 0 || !step.required);
    //           // validate

    //           refreshSelect();
    //         } else {
    //           viewState.answers[step.id] = { value: opt.value, label: opt.label, next: opt.next };
    //           wrap.querySelectorAll('.vw-option').forEach(el => el.classList.remove('selected'));
    //           btn.classList.add('selected');
    //           // setNextEnabled(true);
    //           refreshSelect();

    //         }
    //       });
    //       wrap.appendChild(btn);
    //     });

    //     node.appendChild(wrap);
    //     // error message area
    //     const err = document.createElement('div');
    //     err.className = 'error';
    //     err.style.display = 'none';
    //     node.appendChild(err);

    //     function refreshSelect() {
    //       const res = validateValueForStep(step, viewState.answers[step.id]);
    //       err.textContent = res.ok ? '' : res.msg;
    //       err.style.display = res.ok ? 'none' : '';
    //       setNextEnabled(res.ok);
    //     }

    //     refreshSelect();

    //     box.appendChild(node);
    //     const hasSel = mode === 'multi' ? (Array.isArray(sel) && sel.length > 0) : Boolean(sel);
    //     setNextEnabled(hasSel || !step.required);
    //   }
    //   else if (isEndStep(step)) {
    //     node = document.createElement('div');
    //     node.innerHTML = `
    //   ${step.title ? `<h3>${viewEscape(step.title)}</h3>` : '<h3>Completed</h3>'}
    //   ${viewBodyHtml(step.body)}`;
    //     box.appendChild(node);
    //     setNextEnabled(false);
    //   } else {
    //     box.textContent = 'Unknown step type';
    //     setNextEnabled(false);
    //   }

    //   document.getElementById('vwPrev').disabled =
    //     !((viewState.history?.length || 0) > 0 || !!getFirstPredecessorId(getStarter(), viewState.selectedStepId));

    //   const nextBtn = document.getElementById('vwNext');
    //   nextBtn.textContent = isEndStep(step) ? 'Finish' : 'Next';


    //   document.getElementById('vwPrev').onclick = () => goPrevious();


    //   nextBtn.onclick = () => {
    //     if (isEndStep(step)) return;

    //     const steps = getSteps();
    //     const current = getStepById(viewState.selectedStepId);

    //     // try single-select branch (use chosen option.next if present)
    //     if (current?.type === 'select' && current.mode === 'single') {
    //       const choice = viewState.answers[current.id];
    //       if (choice?.next && steps.find(x => x.id === choice.next)) {
    //         viewState.history.push(viewState.selectedStepId); // record traversal
    //         setSelectedStepById(choice.next);
    //         renderViewStep(); renderGraph(); renderInspector();
    //         // updateProgressLabel();                             // ← recompute "of M"
    //         return;
    //       }
    //     }

    //     // step-level next
    //     if (current?.next) {
    //       if (steps.find(x => x.id === current.next)) {
    //         viewState.history.push(viewState.selectedStepId); // record traversal
    //         setSelectedStepById(current.next);
    //         renderViewStep(); renderGraph(); renderInspector();
    //         return;
    //       }
    //     }

    //     renderViewStep(); renderGraph(); renderInspector();
    //   };



    // }

    // function renderViewStep() {
    //   const st = sop.starters[viewState.starterIdx];
    //   const steps = st.steps || [];
    //   let i = getStepIndexById(steps, viewState.selectedStepId);

    //   const box = document.getElementById('vwStep');
    //   box.innerHTML = '';
    //   const step = steps[i];
    //   if (!step) { setNextEnabled(false); return; }

    //   // one header everywhere
    //   // const head = step.title ? `<h3 class="vw-title">${viewEscape(step.title)}</h3>` : '';
    //   const head = step.title
    //     ? `<h3 class="vw-title" id="vw-title-${step.id}">${viewEscape(step.title)}</h3><hr class="vw-hr">`
    //     : '';
    //   const imgHtml = step.img_b64 ? `<img class="thumb" src="${step.img_b64}" alt="">` : '';

    //   let node;

    //   if (step.type === 'instruction') {
    //     node = document.createElement('div');
    //     node.innerHTML = `${head}${renderBody(step.body)}${imgHtml}`;
    //     // AFTER: node.innerHTML = `${head}${renderBody(step.body)}${imgHtml}`;
    //     (function renderRunnableEmbeds() {
    //       const embeds = Array.isArray(step.embeds) ? step.embeds : [];

    //       // collect chip IDs BEFORE we replace them
    //       const usedIds = new Set(
    //         [...node.querySelectorAll('.embed-chip[data-embed-id]')]
    //           .map(c => c.getAttribute('data-embed-id'))
    //       );

    //       // A) Replace chips with iframes
    //       node.querySelectorAll('.embed-chip[data-embed-id]').forEach(chip => {
    //         const id = chip.getAttribute('data-embed-id');
    //         const emb = embeds.find(e => e.id === id);
    //         if (!emb) return;

    //         const ifr = document.createElement('iframe');
    //         ifr.sandbox = 'allow-scripts allow-same-origin allow-popups allow-forms';
    //         ifr.referrerPolicy = 'no-referrer';
    //         ifr.style.width = '100%';
    //         ifr.style.border = '1px solid var(--muted)';
    //         ifr.style.minHeight = '360px';
    //         // ifr.style.maxHeight = '1360px';
    //         ifr.style.height = 'auto';
    //         ifr.srcdoc = buildEmbedSrcdoc(emb);

    //         chip.replaceWith(ifr);
    //       });

    //       // B) Append embeds that have NO chip reference
    //       embeds.filter(e => !usedIds.has(e.id)).forEach(emb => {
    //         const ifr = document.createElement('iframe');
    //         ifr.sandbox = 'allow-scripts allow-same-origin allow-popups allow-forms';
    //         ifr.referrerPolicy = 'no-referrer';
    //         ifr.style.width = '100%';
    //         ifr.style.border = '1px solid var(--muted)';
    //         ifr.style.minHeight = '360px';
    //         ifr.srcdoc = buildEmbedSrcdoc(emb);
    //         node.appendChild(ifr);
    //       });
    //     })();

    //     box.appendChild(node);
    //     setNextEnabled(true);
    //   }

    //   else if (step.type === 'input') {
    //     node = document.createElement('div');
    //     node.innerHTML = `
    //                     ${step.title ? `<label for="vw_inp">${viewEscape(step.title)}</label>` : ''}
    //                     <input id="vw_inp" type="text" class="text-input"
    //                           placeholder="${viewEscape(step.placeholder || '')}">
    //                   `;

    //     box.appendChild(node);

    //     const inp = node.querySelector('#vw_inp');
    //     const img = node.querySelector('.thumb');
    //     inp.value = viewState.answers[step.id] || '';

    //     const err = document.createElement('div');
    //     err.className = 'error';
    //     err.style.display = 'none';
    //     (img ? img : inp).insertAdjacentElement(img ? 'beforebegin' : 'afterend', err);

    //     function refreshInput() {
    //       const res = validateValueForStep(step, inp.value);
    //       err.textContent = res.ok ? '' : res.msg;
    //       err.style.display = res.ok ? 'none' : '';
    //       setNextEnabled(res.ok);
    //     }
    //     inp.addEventListener('input', () => {
    //       viewState.answers[step.id] = inp.value;
    //       refreshInput();
    //     });
    //     refreshInput();
    //   }

    //   else if (step.type === 'select') {
    //     node = document.createElement('div');
    //     node.innerHTML = `<h3>${viewEscape(step.title)}</h3>`;

    //     const wrap = document.createElement('div');
    //     wrap.className = 'vw-grid-sel';
    //     node.appendChild(wrap);

    //     const mode = step.mode === 'multi' ? 'multi' : 'single';
    //     let sel = viewState.answers[step.id] ?? (mode === 'multi' ? [] : null);

    //     (step.options || []).forEach(opt => {
    //       const btn = document.createElement('button');
    //       btn.className = 'vw-option';
    //       btn.innerHTML = `<strong>${viewEscape(opt.label)}</strong>${opt.hint ? `<div class="small">${viewEscape(opt.hint)}</div>` : ''}`;

    //       const isSel = mode === 'multi'
    //         ? (Array.isArray(sel) && sel.some(o => (o?.value ?? o) === opt.value))
    //         : (sel && ((sel?.value ?? sel) === opt.value));

    //       if (isSel) btn.classList.add('selected');

    //       btn.addEventListener('click', () => {
    //         if (mode === 'multi') {
    //           sel = Array.isArray(viewState.answers[step.id]) ? [...viewState.answers[step.id]] : [];
    //           const k = sel.findIndex(o => (o?.value ?? o) === opt.value);
    //           if (k >= 0) { sel.splice(k, 1); btn.classList.remove('selected'); }
    //           else { sel.push({ value: opt.value, label: opt.label }); btn.classList.add('selected'); }
    //           viewState.answers[step.id] = sel;
    //           refreshSelect();
    //         } else {
    //           viewState.answers[step.id] = { value: opt.value, label: opt.label, next: opt.next };
    //           wrap.querySelectorAll('.vw-option').forEach(el => el.classList.remove('selected'));
    //           btn.classList.add('selected');
    //           refreshSelect();
    //         }
    //       });

    //       wrap.appendChild(btn);
    //     });

    //     const err = document.createElement('div');
    //     err.className = 'error';
    //     err.style.display = 'none';
    //     node.appendChild(err);

    //     function refreshSelect() {
    //       const res = validateValueForStep(step, viewState.answers[step.id]);
    //       err.textContent = res.ok ? '' : res.msg;
    //       err.style.display = res.ok ? 'none' : '';
    //       setNextEnabled(res.ok);
    //     }
    //     refreshSelect();

    //     box.appendChild(node);

    //     // const hasSel = mode === 'multi' ? (Array.isArray(sel) && sel.length > 0) : Boolean(sel);
    //     // console.log(`hasSel`, hasSel);
    //     // setNextEnabled(hasSel);
    //   }

    //   else if (isEndStep(step)) {
    //     node = document.createElement('div');
    //     node.innerHTML = `${head || '<h3>Completed</h3>'}${viewBodyHtml(step.body)}`;
    //     box.appendChild(node);
    //     setNextEnabled(false);
    //   }

    //   else {
    //     box.textContent = 'Unknown step type';
    //     setNextEnabled(false);
    //   }

    //   // Prev state + handlers
    //   document.getElementById('vwPrev').disabled =
    //     !((viewState.history?.length || 0) > 0 || !!getFirstPredecessorId(getStarter(), viewState.selectedStepId));

    //   const nextBtn = document.getElementById('vwNext');
    //   nextBtn.textContent = isEndStep(step) ? 'Finish' : 'Next';
    //   if (isEndStep(step)) {
    //     nextBtn.disabled = true;
    //   }

    //   document.getElementById('vwPrev').onclick = () => goPrevious();

    //   nextBtn.onclick = () => {
    //     if (isEndStep(step)) return;

    //     const stepsAll = getSteps();
    //     const current = getStepById(viewState.selectedStepId);


    //     // single-select branch
    //     if (current?.type === 'select' && current.mode === 'single') {
    //       const choice = viewState.answers[current.id];
    //       if (choice?.next && stepsAll.find(x => x.id === choice.next)) {
    //         const toId = choice.next;
    //         if (toId !== viewState.selectedStepId) {
    //           recordTransition(viewState.selectedStepId, toId);   // ← add this
    //           setSelectedStepById(toId);
    //           renderViewStep(); renderGraph(); renderInspector();
    //         }
    //         return;
    //       }

    //     }


    //     // step-level next
    //     if (current?.next && stepsAll.find(x => x.id === current.next)) {
    //       const toId = current.next;
    //       if (toId !== viewState.selectedStepId) {
    //         recordTransition(viewState.selectedStepId, toId);   // ← add this
    //         setSelectedStepById(toId);
    //         renderViewStep(); renderGraph(); renderInspector();
    //       }
    //       return;
    //     }

    //     renderViewStep(); renderGraph(); renderInspector();
    //   };
    // }

    function renderViewStep() {
      const st = sop.starters[viewState.starterIdx];
      const steps = st.steps || [];
      let i = getStepIndexById(steps, viewState.selectedStepId);
      if (i < 0) i = 0;

      const box = document.getElementById('vwStep');
      box.innerHTML = '';

      const step = steps[i];
      if (!step) { setNextEnabled(false); return; }

      const frag = document.createDocumentFragment();

      // Header (kept your style; added id for a11y)
      const headHtml = step.title
        ? `<h3 class="vw-title" id="vw-title-${step.id}">${viewEscape(step.title)}</h3><hr class="vw-hr">`
        : '';
      const imgHtml = step.img_b64 ? `<img class="thumb" src="${step.img_b64}" alt="">` : '';

      // ---------- helpers ----------
      const EMBED_MIN_H = 360;
      const EMBED_MAX_H = 1600; // cap to stop runaway growth
      function createEmbedIframe(emb) {
        const ifr = document.createElement('iframe');
        ifr.sandbox = 'allow-scripts allow-same-origin allow-popups allow-forms';
        ifr.referrerPolicy = 'no-referrer';
        ifr.style.width = '100%';
        ifr.style.border = '1px solid var(--muted)';
        ifr.style.minHeight = EMBED_MIN_H + 'px';
        ifr.style.maxHeight = EMBED_MAX_H + 'px';
        ifr.style.height = 'auto';
        ifr.style.overflow = 'auto'; // internal scroll beyond cap
        ifr.srcdoc = buildEmbedSrcdoc(emb);
        return ifr;
      }

      function renderEmbeds(intoNode) {
        const embeds = Array.isArray(step.embeds) ? step.embeds : [];

        // collect chip IDs BEFORE replacing
        const usedIds = new Set(
          [...intoNode.querySelectorAll('.embed-chip[data-embed-id]')]
            .map(c => c.getAttribute('data-embed-id'))
        );

        // A) Replace chips with iframes
        intoNode.querySelectorAll('.embed-chip[data-embed-id]').forEach(chip => {
          const id = chip.getAttribute('data-embed-id');
          const emb = embeds.find(e => e.id === id);
          if (!emb) return;
          const ifr = createEmbedIframe(emb);
          chip.replaceWith(ifr);
        });

        // B) Append embeds with no chip reference
        embeds.filter(e => !usedIds.has(e.id)).forEach(emb => {
          const ifr = createEmbedIframe(emb);
          intoNode.appendChild(ifr);
        });
      }

      // ---------- body by type ----------
      let node;

      if (step.type === 'instruction') {
        node = document.createElement('div');
        node.innerHTML = `${headHtml}${renderBody(step.body)}${imgHtml}`;
        renderEmbeds(node);
        frag.appendChild(node);
        setNextEnabled(true);
      }

      else if (step.type === 'input') {
        node = document.createElement('div');
        node.innerHTML = `
      ${step.title ? `<label for="vw_inp">${viewEscape(step.title)}</label>` : ''}
      <input id="vw_inp" type="text" class="text-input"
             placeholder="${viewEscape(step.placeholder || '')}">
      ${imgHtml}
    `;
        frag.appendChild(node);

        const inp = node.querySelector('#vw_inp');
        const img = node.querySelector('.thumb');
        inp.value = viewState.answers[step.id] || '';

        const err = document.createElement('div');
        err.className = 'error';
        err.style.display = 'none';
        (img ? img : inp).insertAdjacentElement(img ? 'beforebegin' : 'afterend', err);

        function refreshInput() {
          const res = validateValueForStep(step, inp.value);
          err.textContent = res.ok ? '' : res.msg;
          err.style.display = res.ok ? 'none' : '';
          setNextEnabled(res.ok);
        }
        inp.addEventListener('input', () => {
          viewState.answers[step.id] = inp.value;
          refreshInput();
        });
        refreshInput();
      }

      else if (step.type === 'select') {
        node = document.createElement('div');
        node.innerHTML = headHtml || `<h3>${viewEscape(step.title || '')}</h3>`;

        const wrap = document.createElement('div');
        wrap.className = 'vw-grid-sel';
        node.appendChild(wrap);

        const mode = step.mode === 'multi' ? 'multi' : 'single';
        let sel = viewState.answers[step.id] ?? (mode === 'multi' ? [] : null);

        (step.options || []).forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'vw-option';
          btn.type = 'button';
          btn.innerHTML = `<strong>${viewEscape(opt.label)}</strong>${opt.hint ? `<div class="small">${viewEscape(opt.hint)}</div>` : ''}`;

          const isSel = mode === 'multi'
            ? (Array.isArray(sel) && sel.some(o => (o?.value ?? o) === opt.value))
            : (sel && ((sel?.value ?? sel) === opt.value));

          if (isSel) btn.classList.add('selected');

          btn.addEventListener('click', () => {
            if (mode === 'multi') {
              sel = Array.isArray(viewState.answers[step.id]) ? [...viewState.answers[step.id]] : [];
              const k = sel.findIndex(o => (o?.value ?? o) === opt.value);
              if (k >= 0) { sel.splice(k, 1); btn.classList.remove('selected'); }
              else { sel.push({ value: opt.value, label: opt.label }); btn.classList.add('selected'); }
              viewState.answers[step.id] = sel;
              refreshSelect();
            } else {
              viewState.answers[step.id] = { value: opt.value, label: opt.label, next: opt.next };
              wrap.querySelectorAll('.vw-option').forEach(el => el.classList.remove('selected'));
              btn.classList.add('selected');
              refreshSelect();
            }
          });

          wrap.appendChild(btn);
        });

        const err = document.createElement('div');
        err.className = 'error';
        err.style.display = 'none';
        node.appendChild(err);

        function refreshSelect() {
          const res = validateValueForStep(step, viewState.answers[step.id]);
          err.textContent = res.ok ? '' : res.msg;
          err.style.display = res.ok ? 'none' : '';
          setNextEnabled(res.ok);
        }
        refreshSelect();

        frag.appendChild(node);
      }

      else if (isEndStep(step)) {
        node = document.createElement('div');
        node.innerHTML = `${headHtml || '<h3>Completed</h3>'}${viewBodyHtml(step.body)}`;
        frag.appendChild(node);
        setNextEnabled(false);
      }

      else {
        const warn = document.createElement('div');
        warn.textContent = 'Unknown step type';
        frag.appendChild(warn);
        setNextEnabled(false);
      }

      // ---------- mount ----------
      box.appendChild(frag);

      // ---------- nav controls ----------
      const prevBtn = document.getElementById('vwPrev');
      const nextBtn = document.getElementById('vwNext');

      prevBtn.disabled = !((viewState.history?.length || 0) > 0 || !!getFirstPredecessorId(getStarter(), viewState.selectedStepId));

      nextBtn.textContent = isEndStep(step) ? 'Finish' : 'Next';
      if (isEndStep(step)) {
        setNextEnabled(false);
      }

      prevBtn.onclick = () => goPrevious();

      nextBtn.onclick = () => {
        if (isEndStep(step)) return;

        const stepsAll = getSteps();
        const current = getStepById(viewState.selectedStepId);

        // single-select "branch next"
        if (current?.type === 'select' && current.mode === 'single') {
          const choice = viewState.answers[current.id];
          if (choice?.next && stepsAll.find(x => x.id === choice.next)) {
            const toId = choice.next;
            if (toId !== viewState.selectedStepId) {
              recordTransition(viewState.selectedStepId, toId);
              setSelectedStepById(toId);
              renderViewStep(); renderGraph(); renderInspector();
            }
            return;
          }
        }

        // step-level next
        if (current?.next && stepsAll.find(x => x.id === current.next)) {
          const toId = current.next;
          if (toId !== viewState.selectedStepId) {
            recordTransition(viewState.selectedStepId, toId);
            setSelectedStepById(toId);
            renderViewStep(); renderGraph(); renderInspector();
          }
          return;
        }

        renderViewStep(); renderGraph(); renderInspector();
      };

      // --- Keyboard: ArrowLeft / ArrowRight -> Prev / Next (ignore typing fields)
      if (!document.__vwArrowsBound) {
        document.addEventListener('keydown', (e) => {
          if (e.altKey || e.ctrlKey || e.metaKey) return;

          const t = e.target;
          const isTyping =
            t && (
              t.isContentEditable ||
              /^(input|textarea|select)$/i.test(t.tagName) ||
              t.getAttribute?.('role') === 'textbox'
            );

          if (isTyping) return;

          if (e.key === 'ArrowRight') { e.preventDefault(); document.getElementById('vwNext')?.click(); }
          else if (e.key === 'ArrowLeft') { e.preventDefault(); document.getElementById('vwPrev')?.click(); }
        });
        document.__vwArrowsBound = true;
      }

      // --- Mouse: click left/right side of the step box -> Prev/Next
      if (!box.__vwSideClickBound) {
        box.addEventListener('click', (e) => {
          // don't hijack clicks on real controls or links or inside iframes
          if (e.target.closest('a, button, input, textarea, select, label, iframe, .vw-option')) return;

          // don't navigate if user is selecting text
          const sel = window.getSelection?.();
          if (sel && sel.toString().trim()) return;

          const r = box.getBoundingClientRect();
          const x = e.clientX - r.left;
          const ratio = x / r.width;

          if (ratio >= 0.66) { document.getElementById('vwNext')?.click(); }
          else if (ratio <= 0.34) { document.getElementById('vwPrev')?.click(); }
          // clicks near the middle do nothing
        });
        box.__vwSideClickBound = true;
      }

      hydrateStarterLinks(node);
      function hydrateStarterLinks(root = document) {
        root.querySelectorAll('a[data-starter-id]').forEach(a => {
          const id = a.dataset.starterId;
          if (!id) return;
          const url = new URL(location.href);
          url.searchParams.set('starter_id', id);
          a.href = url.toString();
          a.title = a.href; // nice hover preview
        });
      }
    }


    function refreshMiniMap(fit = true) {
      console.log('refresh mini map');
      const dlg = document.getElementById('vwMapDlg');
      const host = document.getElementById('vwMiniGraph');
      if (!dlg || dlg.hidden || !host) return;

      // const hadContent = !!host.firstChild;
      host.innerHTML = '';
      renderGraphInto(host, {
        onNodeClick(id) { if (typeof navigateToStepId === 'function') navigateToStepId(id); },
      });
    }

    // 1) render on state change
    // (function miniMapAutoSync() {
    //   if (window.__miniSync) return;

    //   function scheduleMiniRefresh(fitFirst=false) {
    //     // let main UI settle a frame, then refresh
    //     requestAnimationFrame(() => { try { refreshMiniMap(fitFirst); } catch {} });
    //   }

    //   // Hook viewState.selectedStepId (source of truth)
    //   const st = (window.viewState ||= {});
    //   let _sel = st.selectedStepId;
    //   try {
    //     Object.defineProperty(st, 'selectedStepId', {
    //       configurable: true,
    //       enumerable: true,
    //       get() { return _sel; },
    //       set(v) { _sel = v; scheduleMiniRefresh(false); },
    //     });
    //   } catch { /* if already accessor, we still have the other hooks below */ }

    //   // 2) also hook navigateToStepId (covers viewers/other code paths)
    //   const origNav = window.navigateToStepId;
    //   if (typeof origNav === 'function') {
    //     window.navigateToStepId = function (...args) {
    //       const out = origNav.apply(this, args);
    //       scheduleMiniRefresh(false);
    //       return out;
    //     };
    //   }

    //   // 3) listen to common Next/Prev UI (broad selectors; harmless if absent)
    //   const navSelectors = [
    //     '#vwNext', '#vwPrev',
    //     '[data-action="next"]', '[data-action="prev"]',
    //     'button[aria-label="Next"]', 'button[aria-label="Prev"]'
    //   ];
    //   document.addEventListener('click', (e) => {
    //     if (navSelectors.some(sel => e.target.closest(sel))) scheduleMiniRefresh(false);
    //   });

    //   // 4) last resort: watch the main graph for selection/attribute changes
    //   const graphRoot =
    //     document.querySelector('.graph-canvas') ||
    //     document.getElementById('graphSvg') ||
    //     document.querySelector('#graph svg');
    //   if (graphRoot) {
    //     const mo = new MutationObserver(() => scheduleMiniRefresh(false));
    //     mo.observe(graphRoot, { subtree: true, attributes: true, attributeFilter: ['class', 'data-selected', 'step-id'] });
    //     window.__miniMo = mo;
    //   }

    //   window.__miniSync = true;
    // })();




    // (function initMapDialog() {
    //     const openBtn  = document.getElementById('vwOpenMap');
    //     const dlg      = document.getElementById('vwMapDlg');
    //     const closeBtn = document.getElementById('vwMapClose');
    //     const dragBar  = document.getElementById('vwMapDrag');
    //     const miniWrap = document.getElementById('vwMiniGraph');

    //     if (!openBtn || !dlg || !closeBtn || !dragBar || !miniWrap) return;

    //     function renderMini() {
    //       // Reuse your shared renderer
    //       renderGraphInto(miniWrap, {
    //         onNodeClick(id) {
    //           // match the main graph behavior
    //           navigateToStepId(id);
    //         }
    //       });
    //     }


    //     // Replace your entire openBtn click handler with this:
    //   openBtn.addEventListener('click', (e) => {
    //     e.preventDefault();
    //     dlg.hidden = false;

    //     // center once
    //     if (!dlg.__posSet) {
    //       dlg.style.left = Math.max(24, (window.innerWidth - dlg.offsetWidth) / 2) + 'px';
    //       dlg.style.top  = Math.max(24, (window.innerHeight - dlg.offsetHeight) / 2) + 'px';
    //       dlg.style.right = 'auto'; dlg.style.bottom = 'auto';
    //       dlg.__posSet = true;
    //     }

    //     // --- render (no listeners yet) ---
    //     function renderMiniPreserveVB() {
    //       const saved = dlg.__miniState ? { ...dlg.__miniState } : null;
    //       miniWrap.innerHTML = '';
    //       renderGraphInto(miniWrap, { readonly: true, compact: true, fit: true });
    //       let svg = miniWrap.querySelector('svg');
    //       if (!svg) return null;

    //       // ensure nodes clickable; edges inert
    //       svg.querySelectorAll('[step-id], g.node, .node').forEach(el => {
    //         el.style.pointerEvents = 'auto'; el.style.cursor = 'pointer';
    //       });
    //       svg.querySelectorAll('.edge, path.edge, .handle, .connector').forEach(el => {
    //         el.style.pointerEvents = 'none';
    //       });

    //       // init/restore viewBox state
    //       if (!dlg.__miniState) {
    //         const vb = (svg.getAttribute('viewBox') || '').trim().split(/\s+/).map(Number);
    //         dlg.__miniState = (vb.length === 4 && vb.every(Number.isFinite))
    //           ? { vx: vb[0], vy: vb[1], vw: vb[2], vh: vb[3] }
    //           : { vx: 0, vy: 0, vw: 1000, vh: 1000 };
    //       }
    //       if (saved) dlg.__miniState = saved;
    //       applyVB(svg);

    //       return svg;
    //     }

    //     function getSvgRect(svg) {
    //       const r = svg.getBoundingClientRect();
    //       return (r.width >= 1 && r.height >= 1) ? r : null;
    //     }
    //     function applyVB(svg) {
    //       const s = dlg.__miniState;
    //       if (!s) return;
    //       if (![s.vx, s.vy, s.vw, s.vh].every(Number.isFinite)) return;
    //       if (s.vw <= 0 || s.vh <= 0) return;
    //       svg.setAttribute('viewBox', `${s.vx} ${s.vy} ${s.vw} ${s.vh}`);
    //     }
    //     function zoomAtMouseMini(svg, ev, factor) {
    //       const s = dlg.__miniState, rect = getSvgRect(svg); if (!s || !rect) return;
    //       const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    //       const wx = s.vx + sx * (s.vw / rect.width);
    //       const wy = s.vy + sy * (s.vh / rect.height);

    //       const minScale = 0.1, maxScale = 8;
    //       const cur = 1000 / s.vw;
    //       const nxt = Math.min(maxScale, Math.max(minScale, cur * factor));
    //       const eff = nxt / cur; if (eff === 1) return;

    //       const vw2 = s.vw / eff, vh2 = s.vh / eff;
    //       s.vx = wx - sx * (vw2 / rect.width);
    //       s.vy = wy - sy * (vh2 / rect.height);
    //       s.vw = vw2; s.vh = vh2;
    //       applyVB(svg);
    //     }
    //     function panMini(svg, dxPx, dyPx) {
    //       const s = dlg.__miniState, rect = getSvgRect(svg); if (!s || !rect) return;
    //       const sx = s.vw / rect.width, sy = s.vh / rect.height;
    //       s.vx += dxPx * sx; s.vy += dyPx * sy;
    //       applyVB(svg);
    //     }

    //     // first render
    //     let svg = renderMiniPreserveVB();
    //     if (!svg) return;

    //     // bind once per dialog lifetime (no rebinding on every click)
    //     const viewport = dlg.querySelector('.mini-viewport') || miniWrap;
    //     if (!dlg.__wheelBound) {
    //       const onMiniWheel = (ev) => {
    //         // Ctrl/Cmd = zoom at mouse
    //         if (ev.ctrlKey || ev.metaKey) {
    //           ev.preventDefault();
    //           const step = Math.pow(1.0018, -ev.deltaY); // up => zoom in
    //           zoomAtMouseMini(svg, ev, step);
    //           return;
    //         }
    //         // pan (Shift = horizontal; up => left)
    //         ev.preventDefault();
    //         const dx = ev.shiftKey ? (-ev.deltaY) : ev.deltaX;
    //         const dy = ev.shiftKey ? 0 : ev.deltaY;
    //         panMini(svg, dx, dy);
    //       };
    //       viewport.addEventListener('wheel', onMiniWheel, { passive: false });
    //       dlg.__wheelBound = true;
    //     }

    //     if (!dlg.__clickBound) {
    //       let clicking = false; // reentrancy guard to avoid duplicate nav/refresh
    //       const onMiniClick = (ev) => {
    //         const hit = ev.target.closest?.('[step-id], g.node, .node'); if (!hit) return;
    //         const id = hit.getAttribute?.('step-id') || hit.getAttribute?.('data-id') || hit.id; if (!id) return;

    //         if (clicking) return; clicking = true;
    //         try {
    //           if (typeof navigateToStepId === 'function') navigateToStepId(id);
    //           // re-render clone to reflect selection, but keep current VB and listeners
    //           svg = renderMiniPreserveVB() || svg;
    //         } finally {
    //           // let layout settle before allowing another click
    //           setTimeout(() => { clicking = false; }, 0);
    //         }
    //       };
    //       viewport.addEventListener('click', onMiniClick);
    //       dlg.__clickBound = true;
    //     }
    //   });



    //     closeBtn.addEventListener('click', () => { dlg.hidden = true; });

    //     // simple draggable header
    //     (function makeDraggable(box, handle) {
    //       let sx = 0, sy = 0, sl = 0, st = 0, moving = false;

    //       handle.addEventListener('mousedown', (e) => {
    //         moving = true;
    //         sx = e.clientX; sy = e.clientY;
    //         const rect = box.getBoundingClientRect();
    //         sl = rect.left; st = rect.top;
    //         document.addEventListener('mousemove', onMove);
    //         document.addEventListener('mouseup', onUp, { once: true });
    //         e.preventDefault();
    //       });

    //       function onMove(e) {
    //         if (!moving) return;
    //         const dx = e.clientX - sx, dy = e.clientY - sy;
    //         box.style.left = Math.max(0, sl + dx) + 'px';
    //         box.style.top  = Math.max(0, st + dy) + 'px';
    //         box.style.right = 'auto'; box.style.bottom = 'auto';
    //       }
    //       function onUp() { moving = false; document.removeEventListener('mousemove', onMove); }
    //     })(dlg, dragBar);

    //     // zoom buttons in the dialog
    //     dlg.querySelectorAll('.btn-sm[data-zoom]').forEach(btn => {
    //       btn.addEventListener('click', () => {
    //         const v = btn.getAttribute('data-zoom');
    //         if (v === 'fit') renderMini(true);
    //         else renderMini(false); // renderer reads your stored layout and viewBox
    //       });
    //     });

    //   })();



    (function ensureCfmOverlay() {
      if (window.__cfmOverlay) return;

      const el = document.querySelector('.cfm-overlay') || (() => {
        const d = document.createElement('div');
        d.className = 'cfm-overlay';
        d.style.display = 'none';
        document.body.appendChild(d);
        return d;
      })();

      el.style.zIndex = String(Math.max(9999, parseInt(getComputedStyle(el).zIndex || '9999', 10)));

      const stack = []; // LIFO of closer functions: (reason) => void

      function show() { el.style.display = 'flex'; }
      function hideIfEmpty() { if (stack.length === 0) el.style.display = 'none'; }

      el.addEventListener('click', () => {
        const top = stack[stack.length - 1];
        if (typeof top === 'function') top('backdrop');
      });

      // block wheel/touch behind
      const block = (e) => { if (stack.length) { e.preventDefault(); } };
      el.addEventListener('wheel', block, { passive: false });
      el.addEventListener('touchmove', block, { passive: false });

      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        const top = stack[stack.length - 1];
        if (!top) return;
        e.preventDefault();
        if (typeof top === 'function') top('esc');
      });

      window.__cfmOverlay = {
        push(closerFn) { if (typeof closerFn === 'function') { stack.push(closerFn); show(); } },
        remove(closerFn) {
          const i = stack.lastIndexOf(closerFn);
          if (i !== -1) stack.splice(i, 1);
          hideIfEmpty();
        },
        bringToFront() { show(); },
        _debugCount() { return stack.length; }
      };
    })();

    /* ---------------- your dialog init (uses overlay manager) ---------------- */
    // (function initMapDialog() {
    //   const openBtn  = document.getElementById('vwOpenMap');
    //   const dlg      = document.getElementById('vwMapDlg');
    //   const closeBtn = document.getElementById('vwMapClose');
    //   const dragBar  = document.getElementById('vwMapDrag');
    //   const miniWrap = document.getElementById('vwMiniGraph');

    //   if (!openBtn || !dlg || !closeBtn || !dragBar || !miniWrap) return;

    //   dlg.style.zIndex = String((parseInt(getComputedStyle(dlg).zIndex || '0',10) || 0) + 1 || 10000);
    //   dlg.setAttribute('role', 'dialog');
    //   dlg.setAttribute('aria-hidden', 'true');

    //   let lastFocus = null;

    //   // closer function stored in the overlay stack
    //   const closer = (reason) => {
    //     if (dlg.hidden) return;
    //     dlg.hidden = true;
    //     dlg.setAttribute('aria-hidden', 'true');
    //     dlg.removeAttribute('aria-modal');
    //     window.__cfmOverlay.remove(closer);
    //     if (lastFocus && typeof lastFocus.focus === 'function') setTimeout(() => lastFocus.focus(), 0);
    //   };

    //   function openDialog() {
    //     lastFocus = document.activeElement;
    //     dlg.hidden = false;
    //     dlg.removeAttribute('aria-hidden');
    //     dlg.setAttribute('aria-modal', 'true');

    //     if (!dlg.__posSet) {
    //       dlg.style.left   = Math.max(24, (window.innerWidth  - dlg.offsetWidth)  / 2) + 'px';
    //       dlg.style.top    = Math.max(24, (window.innerHeight - dlg.offsetHeight) / 2) + 'px';
    //       dlg.style.right  = 'auto';
    //       dlg.style.bottom = 'auto';
    //       dlg.__posSet = true;
    //     }

    //     setTimeout(() => {
    //       (closeBtn || dlg.querySelector('button,[href],[tabindex]:not([tabindex="-1"])'))?.focus?.();
    //     }, 0);

    //     window.__cfmOverlay.push(closer);
    //     window.__cfmOverlay.bringToFront();

    //     function renderMiniPreserveVB() {
    //       const saved = dlg.__miniState ? { ...dlg.__miniState } : null;
    //       miniWrap.innerHTML = '';
    //       renderGraphInto(miniWrap, { readonly: true, compact: true, fit: true });
    //       let svg = miniWrap.querySelector('svg');
    //       console.log(`svg`, svg);
    //       if (!svg) return null;

    //       svg.querySelectorAll('[step-id], g.node, .node').forEach(el => {
    //         el.style.pointerEvents = 'auto'; el.style.cursor = 'pointer';
    //       });
    //       svg.querySelectorAll('.edge, path.edge, .handle, .connector').forEach(el => {
    //         el.style.pointerEvents = 'none';
    //       });

    //       if (!dlg.__miniState) {
    //         const vb = (svg.getAttribute('viewBox') || '').trim().split(/\s+/).map(Number);
    //         dlg.__miniState = (vb.length === 4 && vb.every(Number.isFinite))
    //           ? { vx: vb[0], vy: vb[1], vw: vb[2], vh: vb[3] }
    //           : { vx: 0, vy: 0, vw: 1000, vh: 1000 };
    //       }
    //       if (saved) dlg.__miniState = saved;
    //       applyVB(svg);
    //       return svg;
    //     }

    //     function getSvgRect(svg) {
    //       const r = svg.getBoundingClientRect();
    //       return (r.width >= 1 && r.height >= 1) ? r : null;
    //     }

    //     function zoomAtMouseMini(svg, ev, factor) {
    //       const s = dlg.__miniState, rect = getSvgRect(svg); if (!s || !rect) return;
    //       const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    //       const wx = s.vx + sx * (s.vw / rect.width);
    //       const wy = s.vy + sy * (s.vh / rect.height);

    //       const minScale = 0.1, maxScale = 8;
    //       const cur = 1000 / s.vw;
    //       const nxt = Math.min(maxScale, Math.max(minScale, cur * factor));
    //       const eff = nxt / cur; if (eff === 1) return;

    //       const vw2 = s.vw / eff, vh2 = s.vh / eff;
    //       s.vx = wx - sx * (vw2 / rect.width);
    //       s.vy = wy - sy * (vh2 / rect.height);
    //       s.vw = vw2; s.vh = vh2;
    //       applyVB(svg);
    //     }
    //     function panMini(svg, dxPx, dyPx) {
    //       // console.log(`dxPx`, dxPx);
    //       debugger;
    //       console.log('panMini is called ?');
    //       const s = dlg.__miniState, rect = getSvgRect(svg); 
    //       console.log(`s`, s);
    //       if (!s || !rect) return;
    //       const sx = s.vw / rect.width, sy = s.vh / rect.height;
    //       s.vx += dxPx * sx; s.vy += dyPx * sy;
    //       console.log('end of panMini');
    //       applyVB(svg);
    //     }

    //     function applyVB(svg) {
    //       console.log('applyVB is called');
    //       const s = dlg.__miniState;
    //       console.log(`s`, s);
    //       if (!s) return;
    //       console.log('111');
    //       if (![s.vx, s.vy, s.vw, s.vh].every(Number.isFinite)) return;
    //       console.log('222');
    //       if (s.vw <= 0 || s.vh <= 0) return;
    //       console.log(`svg`, svg);
    //       console.log(`${s.vx} ${s.vy} ${s.vw} ${s.vh}`);
    //       svg.setAttribute('viewBox', `${s.vx} ${s.vy} ${s.vw} ${s.vh}`);
    //     }

    //     let svg = renderMiniPreserveVB();
    //     if (!svg) return;

    //     const viewport = dlg.querySelector('.mini-viewport') || miniWrap;
    //     if (!dlg.__wheelBound) {
    //       const onMiniWheel = (ev) => {
    //         if (ev.ctrlKey || ev.metaKey) {
    //           ev.preventDefault();
    //           const step = Math.pow(1.0018, -ev.deltaY);
    //           zoomAtMouseMini(svg, ev, step);
    //           return;
    //         }
    //         ev.preventDefault();
    //         const dx = ev.shiftKey ? (-ev.deltaY) : ev.deltaX;
    //         const dy = ev.shiftKey ? 0 : ev.deltaY;
    //         panMini(svg, dx, dy);
    //       };
    //       viewport.addEventListener('wheel', onMiniWheel, { passive: false });
    //       dlg.__wheelBound = true;
    //     }

    //     if (!dlg.__clickBound) {
    //       let clicking = false;
    //       const onMiniClick = (ev) => {
    //         const hit = ev.target.closest?.('[step-id], g.node, .node'); if (!hit) return;
    //         const id = hit.getAttribute?.('step-id') || hit.getAttribute?.('data-id') || hit.id; if (!id) return;
    //         if (clicking) return; clicking = true;
    //         try {
    //           if (typeof navigateToStepId === 'function') navigateToStepId(id);
    //           svg = renderMiniPreserveVB() || svg;
    //         } finally {
    //           setTimeout(() => { clicking = false; }, 0);
    //         }
    //       };
    //       viewport.addEventListener('click', onMiniClick);
    //       dlg.__clickBound = true;
    //     }
    //   }

    //   openBtn.addEventListener('click', (e) => { e.preventDefault(); openDialog(); });
    //   closeBtn.addEventListener('click', () => closer('button'));

    //   (function makeDraggable(box, handle) {
    //     let sx = 0, sy = 0, sl = 0, st = 0, moving = false;

    //     handle.addEventListener('mousedown', (e) => {
    //       moving = true;
    //       sx = e.clientX; sy = e.clientY;
    //       const rect = box.getBoundingClientRect();
    //       sl = rect.left; st = rect.top;
    //       document.addEventListener('mousemove', onMove);
    //       document.addEventListener('mouseup', onUp, { once: true });
    //       e.preventDefault();
    //     });

    //     function onMove(e) {
    //       if (!moving) return;
    //       const dx = e.clientX - sx, dy = e.clientY - sy;
    //       box.style.left = Math.max(0, sl + dx) + 'px';
    //       box.style.top  = Math.max(0, st + dy) + 'px';
    //       box.style.right = 'auto'; box.style.bottom = 'auto';
    //     }
    //     function onUp() { moving = false; document.removeEventListener('mousemove', onMove); }
    //   })(dlg, dragBar);

    //   dlg.querySelectorAll('.btn-sm[data-zoom]').forEach(btn => {
    //     btn.addEventListener('click', () => {
    //       const v = btn.getAttribute('data-zoom');
    //       if (v === 'fit') {
    //         miniWrap.innerHTML = '';
    //         renderGraphInto(miniWrap, { readonly: true, compact: true, fit: true });
    //       } else {
    //         miniWrap.innerHTML = '';
    //         renderGraphInto(miniWrap, { readonly: true, compact: true, fit: false });
    //       }
    //     });
    //   });

    // })();

    (function initMapDialog() {
      const openBtn = document.getElementById('vwOpenMap');
      const dlg = document.getElementById('vwMapDlg');
      const closeBtn = document.getElementById('vwMapClose');
      const dragBar = document.getElementById('vwMapDrag');
      const miniWrap = document.getElementById('vwMiniGraph');

      if (!openBtn || !dlg || !closeBtn || !dragBar || !miniWrap) return;

      dlg.style.zIndex = String((parseInt(getComputedStyle(dlg).zIndex || '0', 10) || 0) + 1 || 10000);
      dlg.setAttribute('role', 'dialog');
      dlg.setAttribute('aria-hidden', 'true');

      let lastFocus = null;

      // ---------- overlay-backed closer ----------
      const closer = (reason) => {
        if (dlg.hidden) return;
        dlg.hidden = true;
        dlg.setAttribute('aria-hidden', 'true');
        dlg.removeAttribute('aria-modal');
        dlg.__miniSvg = null; // important—avoid stale refs on reopen
        window.__cfmOverlay?.remove?.(closer);
        if (lastFocus && typeof lastFocus.focus === 'function') setTimeout(() => lastFocus.focus(), 0);
      };

      function openDialog() {
        lastFocus = document.activeElement;
        dlg.hidden = false;
        dlg.removeAttribute('aria-hidden');
        dlg.setAttribute('aria-modal', 'true');

        if (!dlg.__posSet) {
          dlg.style.left = Math.max(24, (window.innerWidth - dlg.offsetWidth) / 2) + 'px';
          dlg.style.top = Math.max(24, (window.innerHeight - dlg.offsetHeight) / 2) + 'px';
          dlg.style.right = 'auto';
          dlg.style.bottom = 'auto';
          dlg.__posSet = true;
        }

        setTimeout(() => {
          (closeBtn || dlg.querySelector('button,[href],[tabindex]:not([tabindex="-1"])'))?.focus?.();
        }, 0);

        window.__cfmOverlay?.push?.(closer);
        window.__cfmOverlay?.bringToFront?.();

        // ---- render mini (and store live svg) ----
        const svg = renderMiniPreserveVB();
        if (!svg) return;

        const viewport = dlg.querySelector('.mini-viewport') || miniWrap;

        // -------- geometry helpers (use viewport, not svg) --------
        function getViewportRect() {
          const r = viewport.getBoundingClientRect();
          return (r.width >= 1 && r.height >= 1) ? r : null;
        }
        function getLiveSvg() { return dlg.__miniSvg || miniWrap.querySelector('svg'); }

        function applyVB(svgEl) {
          // const s = dlg.__miniState;
          const s = dlg.__miniState;

          if (!s) return;
          if (![s.vx, s.vy, s.vw, s.vh].every(Number.isFinite)) return;
          if (s.vw <= 0 || s.vh <= 0) return;
          svgEl.setAttribute('viewBox', `${s.vx} ${s.vy} ${s.vw} ${s.vh}`);
        }

        function zoomAtMouseMini(ev, factor) {
          const s = dlg.__miniState, rect = getViewportRect(); if (!s || !rect) return;
          // const svgEl = getLiveSvg(); if (!svgEl) return;
          // const s = dlg.__miniState; if (!s) return;
          // const rect = getViewportRect();
          if (!rect) { requestAnimationFrame(() => zoomAtMouseMini(ev, factor)); return; }

          const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
          const wx = s.vx + sx * (s.vw / rect.width);
          const wy = s.vy + sy * (s.vh / rect.height);

          const minScale = 0.1, maxScale = 8;
          const cur = 1000 / s.vw;
          const nxt = Math.min(maxScale, Math.max(minScale, cur * factor));
          const eff = nxt / cur; if (eff === 1) return;

          const vw2 = s.vw / eff, vh2 = s.vh / eff;
          s.vx = wx - sx * (vw2 / rect.width);
          s.vy = wy - sy * (vh2 / rect.height);
          s.vw = vw2; s.vh = vh2;
          // applyVB(svgEl);
          applyVB(getLiveSvg());
        }

        // function zoomAtMouseMini(ev, factor) {
        //   const s = dlg.__miniState, rect = getViewportRect(); if (!s || !rect) return;
        //   // ... compute new vw/vh and vx/vy
        //   s.vx = /* ... */; s.vy = /* ... */; s.vw = vw2; s.vh = vh2;  // starterId stays
        // }

        function isMiniForCurrentStarter() {
          return !!(dlg.__miniState && dlg.__miniState.starterId === viewState.starterIdx);
        }


        // function panMini(dxPx, dyPx) {
        //   const svgEl = getLiveSvg(); if (!svgEl) return;
        //   const s = dlg.__miniState; if (!s) return;
        //   const rect = getViewportRect();
        //   if (!rect) { requestAnimationFrame(() => panMini(dxPx, dyPx)); return; }

        //   const sx = s.vw / rect.width, sy = s.vh / rect.height;
        //   s.vx += dxPx * sx; s.vy += dyPx * sy;
        //   applyVB(svgEl);
        // }
        function panMini(dxPx, dyPx) {
          const s = dlg.__miniState, rect = getViewportRect(); if (!s || !rect) return;
          const sx = s.vw / rect.width, sy = s.vh / rect.height;
          s.vx += dxPx * sx; s.vy += dyPx * sy;       // starterId stays untouched
          applyVB(getLiveSvg());
        }

        // -------- bind once; use live svg + viewport rect each time --------
        if (!dlg.__wheelBound) {
          const onMiniWheel = (ev) => {
            // Ctrl/Cmd => zoom at mouse; otherwise pan (Shift forces horizontal)
            ev.preventDefault();
            if (ev.ctrlKey || ev.metaKey) {
              const step = Math.pow(1.0018, -ev.deltaY);
              zoomAtMouseMini(ev, step);
              return;
            }
            const dx = ev.shiftKey ? (-ev.deltaY) : ev.deltaX;
            const dy = ev.shiftKey ? 0 : ev.deltaY;
            panMini(dx, dy);
          };
          viewport.addEventListener('wheel', onMiniWheel, { passive: false });
          dlg.__wheelBound = true;
        }

        if (!dlg.__clickBound) {
          let clicking = false;
          const onMiniClick = (ev) => {
            const hit = ev.target.closest?.('[step-id], g.node, .node'); if (!hit) return;
            const id = hit.getAttribute?.('step-id') || hit.getAttribute?.('data-id') || hit.id; if (!id) return;
            if (clicking) return; clicking = true;
            try {
              if (typeof navigateToStepId === 'function') navigateToStepId(id);
              renderMiniPreserveVB(); // refresh + keep viewBox
            } finally {
              setTimeout(() => { clicking = false; }, 0);
            }
          };
          viewport.addEventListener('click', onMiniClick);
          dlg.__clickBound = true;
        }
      }

      // ---------- open/close ----------
      openBtn.addEventListener('click', (e) => { e.preventDefault(); openDialog(); });
      closeBtn.addEventListener('click', () => closer('button'));

      // ---------- drag header ----------
      (function makeDraggable(box, handle) {
        let sx = 0, sy = 0, sl = 0, st = 0, moving = false;
        handle.addEventListener('mousedown', (e) => {
          moving = true;
          sx = e.clientX; sy = e.clientY;
          const rect = box.getBoundingClientRect(); sl = rect.left; st = rect.top;
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp, { once: true });
          e.preventDefault();
        });
        function onMove(e) {
          if (!moving) return;
          const dx = e.clientX - sx, dy = e.clientY - sy;
          box.style.left = Math.max(0, sl + dx) + 'px';
          box.style.top = Math.max(0, st + dy) + 'px';
          box.style.right = 'auto'; box.style.bottom = 'auto';
        }
        function onUp() { moving = false; document.removeEventListener('mousemove', onMove); }
      })(dlg, dragBar);

      // ===== Starter deep-linking: ?starter=<id> (or ?starterId=<id>) =====
      (function initStarterDeepLinking() {


        // function findStarterIndexById(id) {
        //   if (!id || !Array.isArray(window.sop?.starters)) return -1;
        //   return window.sop.starters.findIndex(st => String(st?.id) === String(id));
        // }

        // function activateStarter(idx) {
        //   if (idx < 0) return false;
        //   // your own reset function (sets startId, clears answers/history, etc.)
        //   if (typeof resetStarterValues === 'function') resetStarterValues(idx);
        //   // render AFTER base UI has painted
        //   requestAnimationFrame(() => {
        //     if (typeof renderGraph === 'function') renderGraph();
        //     if (typeof renderViewStep === 'function') renderViewStep();
        //     if (typeof renderInspector === 'function') renderInspector();
        //   });
        //   return true;
        // }

        // Keep URL updated when user changes starter manually (optional)
        // function syncUrlToStarter(idx, replace = false) {
        //   const st = window.sop?.starters?.[idx];
        //   if (!st?.id) return;
        //   const url = new URL(location.href);
        //   url.searchParams.set('starter', st.id);
        //   const title = document.title;
        //   if (replace) history.replaceState({ starter: st.id }, title, url.toString());
        //   else history.pushState({ starter: st.id }, title, url.toString());
        // }

        // Hook your existing “switch starter” action if you have one
        // Example: whenever you call resetStarterValues(idx), also do syncUrlToStarter(idx).
        // If you control that function, add:  try { syncUrlToStarter(viewState.starterIdx); } catch {}

        // Apply query on first load—AFTER your app mounts
        window.addEventListener('DOMContentLoaded', () => {
          // Let your initial render happen (landing etc.), then apply deep link
          requestAnimationFrame(() => {
            const starterId = getQueryStarterId();
            console.log(`starterId`, starterId);
            console.log(`sop`, sop);
            if (starterId) {
              // enterViewOrEditStarter(starterId);
            }
            // const idx = findStarterIndexById(qid);
            // if (idx >= 0) {
            //   activateStarter(idx);
            //   syncUrlToStarter(idx, true); // normalize to ?starter=<id> in place
            // }
          });
        });

        // Back/forward support
        // window.addEventListener('popstate', () => {
        //   const qid = getQueryStarterId();
        //   const idx = findStarterIndexById(qid);
        //   if (idx >= 0) {
        //     activateStarter(idx);
        //   } else {
        //     // No query → return to landing (do nothing; your landing stays)
        //   }
        // });

        // Expose a tiny helper if you need to programmatically deep-link later
        // window.SOPNav = Object.assign(window.SOPNav || {}, {
        //   openStarterById(id) {
        //     const idx = findStarterIndexById(id);
        //     if (activateStarter(idx)) syncUrlToStarter(idx);
        //   }
        // });
      })();


      // ---------- zoom buttons ----------
      dlg.querySelectorAll('.btn-sm[data-zoom]').forEach(btn => {
        btn.addEventListener('click', () => {
          const fit = btn.getAttribute('data-zoom') === 'fit';
          miniWrap.innerHTML = '';
          renderGraphInto(miniWrap, { readonly: true, compact: true, fit });
          const svg = miniWrap.querySelector('svg');
          if (svg) dlg.__miniSvg = svg;
        });
      });

      // ---------- renderer (stores live svg + preserves VB) ----------
      // function renderMiniPreserveVB() {

      function renderMiniPreserveVB(reset = false) {
        const curStarterId = viewState.starterIdx;

        // If we have a state but it's for a different starter, drop it and force reset
        if (dlg.__miniState && dlg.__miniState.starterId !== curStarterId) {
          dlg.__miniState = null;
          reset = true;
        }

        const saved = (!reset && dlg.__miniState) ? { ...dlg.__miniState } : null;

        miniWrap.innerHTML = '';
        renderGraphInto(miniWrap, { readonly: true, compact: true, fit: true });

        const svg = miniWrap.querySelector('svg');
        if (!svg) return null;

        // nodes clickable; edges inert
        svg.querySelectorAll('[step-id], g.node, .node').forEach(el => {
          el.style.pointerEvents = 'auto'; el.style.cursor = 'pointer';
        });
        svg.querySelectorAll('.edge, path.edge, .handle, .connector').forEach(el => {
          el.style.pointerEvents = 'none';
        });

        // Base VB from SVG (or default)
        const vb = (svg.getAttribute('viewBox') || '').trim().split(/\s+/).map(Number);
        const base = (vb.length === 4 && vb.every(Number.isFinite))
          ? { vx: vb[0], vy: vb[1], vw: vb[2], vh: vb[3] }
          : { vx: 0, vy: 0, vw: 1000, vh: 1000 };

        // Reuse saved if allowed, else start fresh — and always attach starterId
        dlg.__miniState = saved ? { ...saved, starterId: curStarterId }
          : { ...base, starterId: curStarterId };

        // Apply & stash live svg
        svg.setAttribute('viewBox', `${dlg.__miniState.vx} ${dlg.__miniState.vy} ${dlg.__miniState.vw} ${dlg.__miniState.vh}`);
        dlg.__miniSvg = svg;

        return svg;
      }


    })();

    function buildEmbedSrcdoc(emb) {
      const raw = String(emb.html || '');

      //<script>


      const autosize = `
                            <script>
                            (function () {
                              function send() {
                                var h = Math.max(
                                  document.documentElement.scrollHeight,
                                  document.body ? document.body.scrollHeight : 0
                                );
                                parent.postMessage({ __sop_embed_resize: 1, h: h }, "*");
                              }
                              new ResizeObserver(send).observe(document.documentElement);
                              window.addEventListener("load", send);
                              setTimeout(send, 80);
                            })();
                            <\/script>`;



      if (/<head[\s>]/i.test(raw)) {
        return raw.replace(/<head(\b[^>]*)>/i, (m, attrs) => `<head${attrs}>${autosize}`);
      }
      return `<!doctype html><html><head>${autosize}</head><body>${raw}</body></html>`;
    }


    function reconcileEmbeds(step, editorEl) {
      const idsInBody = new Set(
        [...editorEl.querySelectorAll('.embed-chip[data-embed-id]')]
          .map(el => el.getAttribute('data-embed-id'))
      );
      if (!Array.isArray(step.embeds)) step.embeds = [];
      step.embeds = step.embeds.filter(e => idsInBody.has(e.id)); // remove orphans
    }


    function getFirstPredecessorId(starter, stepId) {
      if (!starter || !stepId) return null;
      const pred = buildPredecessors(starter);           // you already have this
      const set = pred[stepId];
      if (!set || set.size === 0) return null;
      const order = starter.steps.map(s => s.id);
      return [...set].sort((a, b) => order.indexOf(a) - order.indexOf(b))[0];
    }

    // Map: nextId -> prevId (last traversed prev for that node)
    function recordTransition(prevId, nextId) {
      if (!prevId || !nextId || prevId === nextId) return;
      (viewState.prev ||= Object.create(null))[nextId] = prevId; // overwrite if path changes
    }

    // Is `from` a valid predecessor of `to` in the current graph?
    function isValidPredecessor(starter, from, to) {
      if (!starter || !from || !to) return false;
      const pred = buildPredecessors(starter);       // you already use this util
      return !!(pred[to] && pred[to].has(from));
    }


    function buildPredecessors(starter) {
      const pred = Object.create(null);
      const add = (from, to) => { if (to) (pred[to] ||= new Set()).add(from); };
      for (const s of starter.steps) {
        add(s.id, s.next);
        if (Array.isArray(s.options)) for (const o of s.options) add(s.id, o?.next);
      }
      return pred;
    }

    function getStarter() {
      return sop.starters[viewState.starterIdx];
    }

    function getSteps() {
      return getStarter()?.steps || [];
    }

    // get step by stepId 
    function getStepById(stepId) {
      const steps = getSteps();
      return steps.find(s => s.id === stepId) || null;
    }

    // Set selection by **ID** and mirror stepIdx
    function setSelectedStepById(id) {
      const steps = getSteps();
      viewState.selectedStepId = id || null;
    }

    // Set selection by **index** and mirror selectedStepId
    function setSelectedStepByIdx(idx) {
      const steps = getSteps();
      const i = Math.max(0, Math.min(idx | 0, steps.length - 1));
      // viewState.stepIdx = i;
      viewState.selectedStepId = steps[i]?.id || null;
    }


    function navigateToStepId(nextId) {
      console.log('navigateToStepId', nextId);
      const curId = viewState.selectedStepId || null;
      if (!nextId || nextId === curId) return;

      setSelectedStepById(nextId);   // sync id + idx
      renderViewStep();
      renderGraph();
      renderInspector();
    }

    function goPrevious() {
      const st = getStarter();
      const cur = viewState.selectedStepId;
      const prevMap = viewState.prev || Object.create(null);

      // 1) Prefer the last traversed predecessor if still valid
      let target = prevMap[cur];
      if (target && !isValidPredecessor(st, target, cur)) {
        target = null; // path changed; don't trust stale link
      }

      // 2) Fallback: first predecessor in the current graph
      if (!target) {
        target = getFirstPredecessorId(st, cur);
      }

      if (target && target !== cur) {
        setSelectedStepById(target);
        renderViewStep(); renderGraph(); renderInspector();
      }
      // If no predecessor at all, do nothing (button can be disabled upstream)
    }



    function recordHistoryFromCurrent() {
      const cur = viewState.selectedStepId;
      if (!cur) return;
      const h = (viewState.history ||= []);
      if (h[h.length - 1] !== cur) h.push(cur);   // avoid consecutive duplicates
    }




    function makeBlankSOP() {
      return {
        title: "New SOP Library",
        description: "Describe your library",
        starters: [{
          id: "starter_1",
          label: "Starter 1",
          summary: "",
          description: "",
          steps: [
            {
              type: "instruction",
              id: "welcome",
              title: "Welcome",
              body: "Start here.",
              next: "done",
              // pos: { x: 200, y: 60 }
            },
            {
              type: "instruction",
              id: "done",
              title: "Done",
              body: "All set.",
              // pos: { x: 200, y: 200 }

            }
          ]
        }]
      };
    }

    function getDefaultOption(step) {
      // debugger;
      if (!step || step.type !== 'select') return null;

      const len = Array.isArray(step.options) ? step.options.length : 0;
      const idx = len + 1;

      const opt = {
        value: 'opt' + idx,
        label: 'Option ' + idx,
        hint: '',
        next: step.next ?? null
      };

      // ensure unique value even with null holes or user-made names
      const nextOptionVal = nextOptionValue(step);          // e.g., opt1, opt2, ...
      if (opt.value == null || String(opt.value).trim() === '' || !step.options || step.options.some(o => o && o.value === opt.value)) {
        opt.value = nextOptionVal;                   // keep value aligned if you use it as token
      }
      return opt;
    }

    function nextOptionValue(step, prefix = 'opt') {
      const used = new Set();
      if (Array.isArray(step.options)) {
        for (const o of step.options) {
          if (!o) continue;
          const k = (o.id ?? o.value ?? '').trim();
          if (k) used.add(k);
        }
      }
      let n = 1;
      while (used.has(`${prefix}${n}`)) n++;
      return `${prefix}${n}`;
    }


    // Reusable: remove per-option next links (safe on non-selects / missing arrays)
    function stripOptionNexts(step) {
      if (!step || step.type !== 'select' || !Array.isArray(step.options)) return false;
      let touched = false;
      step.options.forEach(o => {
        if (o && 'next' in o) { delete o.next; touched = true; }
      });
      return touched;
    }

    function makeStep(type, starter = getStarter()) {
      const id = uniqueId(type, starter);
      if (type === 'instruction') return { type, id, title: "Instruction", body: "" };
      if (type === 'input') return { type, id, label: "Input", placeholder: "", required: false };
      if (type === 'select') return { type, id, label: "Choose", display: "cards", mode: "single", required: false, options: [{ value: "opt1", label: "Option 1" }] };
      // if (type === 'end') return { type, id, title: "End", body: "" };
      return { type: 'instruction', id, title: "Instruction", body: "" };
    }

    function uniqueId(base, starter) {
      const ids = new Set((starter?.steps || []).map(s => s.id));
      let i = 1, v = slugify(base || 'step');

      let out = v;
      while (ids.has(out)) {
        out = v + '_' + (++i);
      }
      return out;
    }

    function slugify(s) { return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, ''); }
    function escapeHtml(str) { return String(str).replace(/[&<>"']/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[s])); }
    function escapeAttr(str) { return String(str).replace(/"/g, '&quot;'); }
    // function nextSummary(step) {
    //   if (step.type === 'select') {
    //     const optEdges = (step.options || []).filter(o => o.next).length;
    //     return (optEdges > 0 ? (optEdges + ' paths') : '') + (step.next ? (optEdges > 0 ? ' + ' : '') + 'after→' + step.next : (optEdges > 0 ? '' : '—'));
    //   }
    //   return step.next || '—';
    // }

    // function nextSelectHtml(steps, cur) {
    //   const selfId = viewState?.selectedStepId; // current node being edited
    //   const opts = steps
    //     .filter(s => s.id !== selfId) // hide itself
    //     .map(s => `<option value="${s.id}" ${s.id === cur ? 'selected' : ''}>${escapeHtml(s.id)}</option>`)
    //     .join('');
    //   return `<select id="f_next"><option value="">—</option>${opts}</select>`;
    // }

    function nextSelectHtml(steps, cur, selfId, withId = true) {
      const hideId = (typeof selfId === 'string' && selfId) || (viewState?.selectedStepId || null);
      const opts = (steps || [])
        .filter(s => s && s.id !== hideId) // hide itself
        .map(s => `<option value="${s.id}" ${s.id === cur ? 'selected' : ''}>${escapeHtml(s.id)}</option>`)
        .join('');
      const idAttr = withId ? ' id="f_next"' : ''; // avoid duplicate ids in lists
      const classAttr = ' class="opt-next"'; // always class for event delegation
      return `<select${idAttr}${classAttr}>` +
        `<option value="">—</option>${opts}</select>`;
    }



    //   function optionRowHtml(o, i, steps) {
    //     return `
    //   <tr data-opt-idx="${i}">
    //     <td><input class="f_opt_value" type="text" value="${escapeAttr(o.value || '')}"/></td>
    //     <td><input class="f_opt_label" type="text" value="${escapeAttr(o.label || '')}"/></td>
    //     <td><input class="f_opt_hint" type="text" value="${escapeAttr(o.hint || '')}"/></td>
    //     <td>
    //       <select class="f_opt_next">
    //         ${steps.map(s => {
    //       const text = s.id || s.title || s.label;
    //       return `<option value="${s.id}" ${s.id === (o.next || '') ? 'selected' : ''}>${escapeHtml(text)}</option>`;
    //     }).join('')}
    //       </select>
    //     </td>

    //     <td class="center"><button class="f_opt_del">🗑️</button></td>
    //   </tr>
    // `;
    //   }

    function optionRowHtml(o, i, steps, includeNext, curStepId) {
      const v = escapeAttr(o?.value || '');
      const lbl = escapeAttr(o?.label || '');
      const hint = escapeAttr(o?.hint || '');
      // const nextCell = includeNext
      //   ? `<td>${nextSelectHtml(steps, o?.next, curStepId)}</td>`
      //   : '';
      const nextCell = includeNext
        ? `<td>${nextSelectHtml(steps, o?.next, curStepId, /*withId=*/false)}</td>`
        : '';

      return `
    <tr data-opt-idx="${i}">
      <td><input class="opt-value" type="text" value="${v}"></td>
      <td><input class="opt-label" type="text" value="${lbl}"></td>
      <td><input class="opt-hint"  type="text" value="${hint}"></td>
      ${nextCell}
      <td class="center"><button class="iconbtn opt-del">✕</button></td>
    </tr>
  `;
    }

    function handleImageToBase64(ev, cb) {
      const f = ev.target.files?.[0]; if (!f) return;
      const r = new FileReader();
      r.onload = () => { cb(String(r.result)); };
      r.readAsDataURL(f);
    }

    function validateSOP() {
      const errors = [];
      if (!Array.isArray(sop.starters) || sop.starters.length === 0) errors.push('No starters');
      sop.starters.forEach((st, si) => {
        if (!Array.isArray(st.steps) || st.steps.length === 0) errors.push(`Starter[${si}] has no steps`);
        const ids = new Set();
        (st.steps || []).forEach((step, idx) => {
          if (!step.id) errors.push(`Starter[${si}] step[${idx}] missing id`);
          if (ids.has(step.id)) errors.push(`Starter[${si}] duplicate id ${step.id}`); ids.add(step.id);

          if (step.type === 'input' && step.regex) {
            try { new RegExp(step.regex); } catch { errors.push(`Invalid regex at ${step.id}`); }
          }
          if (step.type === 'select' && step.mode === 'multi') {
            const c = (Array.isArray(step.options) ? step.options.length : 0);
            if (step.min != null && step.min > c) errors.push(`min > options at ${step.id}`);
            if (step.max != null && step.max > c) errors.push(`max > options at ${step.id}`);
          }
          if (step.type === 'select' && step.mode === 'single') {
            // warn if no option.next and no step.next (unreachable continuation)
            const hasOptNext = (step.options || []).some(o => o.next);
            if (!hasOptNext && !step.next) errors.push(`No path from single-select ${step.id}`);
          }
        });
      });
      return { ok: errors.length === 0, errors };
    }

    function tidyIds() {
      sop.starters.forEach(st => {
        st.id = slugify(st.id || 'starter');
        (st.steps || []).forEach(s => {
          s.id = slugify(s.id || s.type || 'step');
          if (s.type === 'select' && Array.isArray(s.options)) {
            s.options.forEach(o => { o.value = slugify(o.value || o.label || 'opt'); });
          }
        });
      });
    }



  </script>


</body>

</html>