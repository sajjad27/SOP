<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OpsPath Studio ¬∑ SOP Builder</title>
  <style>
    :root {
      --fg: #0b1220;
      --bg: #f7f9fc;
      --muted: #60708a;
      --card: #ffffff;
      --line: #e4e8f0;
      --accent: #2563eb;
      --accent-weak: #eef3ff;
      --ok: #16a34a;
      --warn: #dc2626;
      --shadow: 0 2px 10px rgba(16, 24, 40, .06), 0 1px 3px rgba(16, 24, 40, .06);
      --radius: 16px;
      --surface: #ffffff;
      --text: #0f172a;
      --line: #cfd6dd;
      --input-bg: #f6f8fa;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
      color: var(--fg);
      background: var(--bg);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: saturate(1.2) blur(6px);
      background: rgba(247, 249, 252, .85);
      border-bottom: 1px solid var(--line);
    }

    .wrap {
      max-width: 1240px;
      margin: 0 auto;
      padding: 12px 16px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .2px;
    }

    .grow {
      flex: 1;
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    button,
    .btn {
      border: 1px solid var(--line);
      background: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    .btn-accent {
      background: var(--accent);
      color: #fff;
      border-color: transparent;
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 1px 4px rgba(16, 24, 40, .08);
    }

    input[type="file"] {
      font-size: 13px;
    }

    select,
    input[type="text"],
    textarea,
    input[type="number"] {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      font: inherit;
    }

    label {
      font-weight: 600;
      margin: 10px 0 6px;
      display: block;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    .hr {
      height: 1px;
      background: var(--line);
      margin: 12px 0;
    }

    main {
      max-width: 1240px;
      margin: 16px auto 60px;
      padding: 0 16px 24px;
    }

    .layout {
      display: flex;
      grid-template-columns: 280px 1fr 360px;
      gap: 12px;
      align-items: start;
    }

    .panel {
      background: #fff;
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }

    .panel h2 {
      font-size: 14px;
      margin: 0 0 8px;
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: calc(100vh - 220px);
      overflow: auto;
    }

    .item {
      padding: 8px;
      border: 1px solid var(--line);
      border-radius: 10px;
      cursor: pointer;
      background: #fff;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .item .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .kv {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .rowflex {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* NEW */
    .badge {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--card);
      /* follows theme */
      color: var(--muted);
    }

    .warn {
      color: var(--warn);
    }

    .success {
      color: var(--ok);
    }

    [screen="mapping"][data-mode="edit"] .graph-panel {
      height: calc(100vh - var(--topbar-h, 56px));
      min-height: 640px;
      width: 100%;
      margin: 0;
      padding: 0;
      grid-column: 1 / -1;
      /* safe if parent isn't grid */
    }

    /* Hide the Preview/Edit switch when <html run-mode="guide"> */
    html[run-mode="guide"] [data-hide~="guide"] {
      display: none !important;
    }



    /* make cy container fill the panel */
    .graph-panel>* {
      width: 100%;
      height: 100%;
    }

    /* tighten page wrappers on mapping editor (use what you have) */
    .vw-shell,
    .vw-main {
      max-width: none;
      padding-inline: 8px;
    }


    .graph-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .graph-zoom button {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--card);
      /* follows theme */
      color: var(--fg);
      cursor: pointer;
    }


    .graph-svg {
      width: 100%;
      height: 520px;
      display: block;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
    }


    .graph-svg.dragging {
      cursor: grabbing;
    }

    .node-rect {
      fill: #fff;
      stroke: #d4dbe7;
      rx: 8;
    }

    .node-rect.current {
      stroke: var(--accent);
      stroke-width: 2;
    }

    .edge {
      stroke: #98a2b3;
      stroke-width: 1.2;
      fill: none;
      marker-end: url(#arrow);
    }

    .edge-label {
      font-size: 11px;
      fill: #667085;
      pointer-events: none;
    }

    .node-label {
      font-size: 12px;
      fill: #0b1220;
      pointer-events: none;
    }

    .link-like {
      color: var(--accent);
      text-decoration: underline;
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      font-size: 13px;
    }

    .thumb {
      display: block;
      width: 66%;
      margin: 10px auto 0;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: #fff;
    }


    .graph-panel:fullscreen,
    .graph-panel:-webkit-full-screen {
      width: 100vw;
      height: 100vh;
      padding: 8px;
      box-sizing: border-box;
    }



    .graph-panel:fullscreen .graph-svg,
    .graph-panel:-webkit-full-screen .graph-svg {
      height: calc(100vh - 56px);
    }

    .table {
      width: 100%;
      border-collapse: collapse;
    }

    .table th,
    .table td {
      border: 1px solid var(--line);
      padding: 6px;
      font-size: 13px;
      vertical-align: top;
    }

    .table th {
      background: #f8fafc;
      text-align: left;
    }

    .iconbtn {
      padding: 6px 8px;
    }

    .center {
      text-align: center;
    }

    .error {
      color: var(--warn);
      font-size: 12px;
      margin-top: 4px;
    }

    /* Steps list spacing */
    #stepsList {
      gap: 14px;
      margin-top: 12px;
    }

    /* Step item */
    #stepsList .item {
      padding: 14px 16px;
      border-radius: 14px;
      border: 1.5px solid var(--line);
      background: var(--card);
      /* follows theme */
      position: relative;
      transition: box-shadow .15s ease, border-color .15s ease, background .15s ease;
    }

    /* Save button is visible only in Edit mode */
    [data-mode="view"] #globalSaveBtn {
      display: none;
    }

    /* Save button: stand out when enabled, muted when disabled */
    #globalSaveBtn {
      letter-spacing: .2px;
      transition: transform .12s ease, box-shadow .2s ease, filter .15s ease;
    }

    /* Enabled: bold green, subtle glow, disk icon */
    #globalSaveBtn:not([disabled]) {
      background: linear-gradient(180deg, #16a34a, #15803d);
      color: #fff;
      border: 1px solid #0f5132;
      box-shadow: 0 6px 18px rgba(22, 163, 74, .35);
    }

    #globalSaveBtn:not([disabled]):hover {
      transform: translateY(-1px);
      filter: brightness(1.04);
      box-shadow: 0 8px 22px rgba(22, 163, 74, .45);
    }

    /* Disabled: low contrast, dashed border */
    #globalSaveBtn[disabled] {
      background: transparent;
      color: #6b7280;
      border: 1px dashed #9ca3af;
      box-shadow: none;
      cursor: default;
    }


    button[disabled],
    .btn[disabled] {
      background: var(--card);
      color: var(--muted);
      opacity: .6;
    }

    .upload {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    /* #importHtmlBtn {
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
    }

    #importHtmlBtn:hover {
      box-shadow: 0 4px 14px rgba(2, 6, 23, .08);
    } */

    #importHtmlNote {
      color: var(--muted);
    }

    #stepsList .item:hover {
      border-color: #cfd8ea;
      box-shadow: 0 6px 18px rgba(2, 6, 23, .06);
    }

    #stepsList .item.active {
      border: 2px solid #1d4ed8;
      /* stronger blue */
      background: linear-gradient(0deg, rgba(29, 78, 216, .08), rgba(29, 78, 216, .08)), #fff;
    }

    #stepsList .item.active::before {
      content: "";
      position: absolute;
      left: -6px;
      top: 10px;
      bottom: 10px;
      width: 4px;
      border-radius: 3px;
      background: #1d4ed8;
    }

    /* make title pop a bit */
    #stepsList .item strong {
      font-weight: 700;
    }

    /* Danger (trash) buttons */
    .btn-danger {
      border: 1px solid #fca5a5;
      background: #fef2f2;
      color: #b91c1c;
    }

    .btn-danger:hover {
      background: #fee2e2;
      border-color: #fb7185;
    }

    .btn-danger:active {
      transform: translateY(1px);
      box-shadow: none;
    }


    /* dark mode */
    /* Use vars for common surfaces so dark can override cleanly */

    select {
      background-image: none;
    }

    html[data-theme="dark"] header {
      background: rgba(10, 14, 22, .85);
      border-bottom-color: var(--line);
    }

    html[data-theme="dark"] {
      --fg: #e5e7eb;
      --bg: #0b1220;
      --muted: #9aa4b2;
      --card: #0f172a;
      --line: #334155;
      /* was #233044: too low-contrast */
      --accent: #3b82f6;
      --accent-weak: rgba(59, 130, 246, .16);
      --ok: #22c55e;
      --warn: #ef4444;
      --shadow: none;
      --surface: #0f172a;
      --text: #e5ecf4;
      --line: #2a3442;
      --input-bg: rgba(255, 255, 255, .06);
    }

    /* Ensure all controls actually use the vars */
    button,
    .btn,
    select,
    input[type="text"],
    textarea,
    input[type="number"],
    .panel,
    .item,
    .graph-svg,
    .table th,
    .table td {
      background: var(--card);
      color: var(--fg);
      border-color: var(--line);
    }

    /* Focus + placeholder in both themes */
    input,
    select,
    textarea {
      color: var(--fg);
    }

    input::placeholder,
    textarea::placeholder {
      color: var(--muted);
      opacity: 1;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: 2px solid var(--accent);
      border-color: transparent;
      box-shadow: 0 0 0 2px var(--accent-weak);
    }

    /* Graph: tie lines/labels to theme vars */
    .edge {
      stroke: var(--muted);
      stroke-width: 1.2;
      fill: none;
    }

    .edge-label {
      fill: var(--muted);
    }

    .node-label {
      fill: var(--fg);
    }

    /* Selected list item stays readable */
    html[data-theme="dark"] #stepsList .item.active {
      background: linear-gradient(0deg, rgba(59, 130, 246, .18), rgba(59, 130, 246, .18)), var(--card);
      border-color: var(--accent);
    }

    /* === Map polish (dark + light) === */
    .graph-svg {
      /* subtle grid so spacing is readable */
      background:
        radial-gradient(circle at 1px 1px, rgba(148, 163, 184, .12) 1px, transparent 1px),
        radial-gradient(circle at 1px 1px, rgba(148, 163, 184, .06) 1px, transparent 1px);
      background-size: 16px 16px, 80px 80px;
      background-position: 0 0, -1px -1px;
      border-color: var(--line);
    }

    /* nodes */
    .node-rect {
      fill: var(--card);
      stroke: var(--line);
      stroke-width: 1.4;
      rx: 10;
      /* soft depth without blur stink */
      filter: drop-shadow(0 1px 0 rgba(0, 0, 0, .08));
    }

    .node-rect.current {
      stroke: var(--accent);
      stroke-width: 2;
    }

    /* labels */
    .node-label {
      font-size: 12.5px;
      /* up from 12 */
      font-weight: 600;
      fill: var(--fg);
    }

    .edge {
      stroke: var(--muted);
      /* tie to theme */
      stroke-width: 1.6;
      fill: none;
      marker-end: url(#arrow);
    }

    .edge-label {
      font-size: 11.5px;
      fill: var(--muted);
      pointer-events: none;
    }


    .hidden {
      display: none !important;
    }

    /* Segmented control */
    .seg {
      display: inline-flex;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      /* clip children to clean curves */
      background: var(--card);
      /* unify background behind buttons */
    }

    .seg-btn {
      padding: 8px 14px;
      background: transparent;
      color: var(--fg);
      border: 0;
      border-radius: 0;
      /* container owns the curves */
      line-height: 1;
    }

    /* divider line between buttons */
    .seg-btn+.seg-btn {
      box-shadow: inset 1px 0 0 var(--line);
    }

    /* default ‚Äúactive‚Äù look */
    .seg-btn.active {
      background: var(--accent);
      color: #fff;
      box-shadow: none;
    }

    /* automatic active states via data-mode */
    [data-mode="view"] #modeView {
      background: var(--accent);
      color: #fff;
      box-shadow: none;
    }

    [data-mode="edit"] #modeEdit {
      background: var(--accent);
      color: #fff;
      box-shadow: none;
    }

    /* Hide all by default */
    /* --- Default hidden --- */
    #vwLanding,
    #vwHeader,
    #vwHeaderEditor,
    #starter,
    #vwWizard,
    #editStarter {
      display: none;
    }

    /* --- Landing screen --- */

    [screen="landing"] .vw-card--add {
      display: none;
    }

    [screen="landing"][data-mode="edit"] .vw-card--add {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    [screen="landing"] #vwLanding {
      display: block;
    }

    /* Landing + view ‚Üí header text */
    [screen="landing"][data-mode="view"] #vwHeader {
      display: block;
    }

    [screen="landing"][data-mode="view"] #vwHeaderEditor {
      display: none;
    }

    /* Landing + edit ‚Üí header editor */
    [screen="landing"][data-mode="edit"] #vwHeader {
      display: none;
    }

    [screen="landing"][data-mode="edit"] #vwHeaderEditor {
      display: block;
    }

    /* --- Starter screen --- */
    [screen="starter"] #starter {
      display: block;
    }

    /* Starter + view ‚Üí show wizard */
    [screen="starter"][data-mode="view"] #vwWizard {
      display: block;
    }

    [screen="starter"][data-mode="view"] #editStarter {
      display: none;
    }

    /* Starter + edit ‚Üí show editor */
    [screen="starter"][data-mode="edit"] #vwWizard {
      display: none;
    }

    [screen="starter"][data-mode="edit"] #editStarter {
      display: flex;
    }




    /* optional: keyboard focus */
    .seg-btn:focus-visible {
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(96, 165, 250, .6);
    }



    /* ---- Preview landing cards (match Viewer) ---- */
    .vw-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 14px;
      margin-top: 12px;
    }

    .vw-card {
      display: block;
      cursor: pointer;
      text-align: left;
      background: var(--card);
      border: 2px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
    }

    .vw-card h3 {
      margin: 0 0 6px;
      font-size: 18px;
    }

    .vw-card p {
      margin: 0;
      color: var(--muted);
    }

    /* HOVER ONLY ‚Äî all cards */
    .vw-card:hover,
    .vw-card:focus-visible {
      background: rgba(0, 0, 0, .04);
      border: 3px solid var(--line);
      /* border-color: var(--line-hover, #dbe3ea); */
      transition: background-color .2s ease, border-color .2s ease;
    }

    /* HOVER ONLY ‚Äî ‚Äú+ New‚Äù card, and only when in Edit mode */
    .vw-card--add:hover,
    .vw-card--add:focus-visible {
      border-style: dashed;
      /* fewer cuts than dotted */
      border-width: 3px;
      /* bolder */
      /* border-color: var(--line-hover, #dbe3ea); */
      /* background: rgba(0, 0, 0, .03); */
      transition: background-color .2s ease, border-color .2s ease, border-width .2s ease;
      background: var(--card);

    }


    .vw-pill {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: var(--card);
      border: 1px solid var(--line);
      color: var(--muted);
      margin-top: 10px;
    }

    .vw-pill strong {
      color: var(--fg);
    }

    /* view-mode wizard */
    .vw-crumbs {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }

    #vwStep {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
    }

    #vwStep h3 {
      margin: 0 0 8px;
    }

    #vwStep ul {
      margin: 8px 0 0 20px;
    }

    #vwStep p {
      margin: 8px 0 0;
    }

    .vw-nav {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      gap: 10px;
    }

    .vw-grid-sel {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
    }

    .vw-option {
      display: block;
      width: 100%;
      text-align: left;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
    }

    .vw-option.selected {
      outline: 2px solid var(--accent);
    }

    .thumb {
      display: block;
      width: 66%;
      margin: 12px auto 0;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--card);
    }



    /* Simple confirm modal */
    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .45);
      z-index: 9999
    }

    .modal.hidden {
      display: none
    }

    .modal-card {
      min-width: 320px;
      max-width: 520px;
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 16px
    }

    .modal-title {
      margin: 0 0 8px
    }

    .modal-text {
      margin: 0 0 12px;
      color: var(--muted)
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end
    }

    .vw-card--add {
      display: flex;
      flex-direction: column;
      justify-content: center;
      border: 2px dashed var(--line, #3a4353);
      background: transparent;
      color: var(--muted, #9aa4b2);
    }

    .vw-card--add:hover {
      border-style: solid;
    }

    .vw-card--add-icon {
      font-size: 2.2rem;
      line-height: 1;
    }



    /* overlay (uses same pattern as confirm modal) */
    #dlgNewStarter.hidden {
      display: none;
    }

    #dlgNewStarter {
      position: fixed;
      inset: 0;
      z-index: 1000;
      padding: 4vh 16px;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, .45);
      /* fades correctly in light/dark */
    }

    #dlgNewStarter .vw-dialog__panel {
      width: min(560px, 92vw);
      background: var(--card);
      color: var(--fg);
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, .35);
    }



    /* REPLACE your inputs/textarea rules */
    #dlgNewStarter .vw-field {
      display: grid;
      gap: 6px;
      margin: 12px 0;
    }

    #dlgNewStarter input,
    #dlgNewStarter textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: transparent;
      /* respects dark & light */
      color: var(--fg);
    }

    #dlgNewStarter input::placeholder,
    #dlgNewStarter textarea::placeholder {
      color: var(--muted);
    }

    /* ADD: invalid state + focus */
    #dlgNewStarter input.is-invalid {
      border-color: var(--warn);
    }

    #dlgNewStarter input.is-invalid+.vw-error {
      display: block;
    }

    .vw-error {
      display: none;
      color: var(--warn);
      font-size: .875rem;
      margin-top: 4px;
      margin-bottom: 0px;
    }

    #dlgNewStarter input:focus,
    #dlgNewStarter textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-weak);
    }

    #dlgNewStarter .vw-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    /* Confirm dialog ‚Äî uses your CSS vars */
    .cfm-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      background: rgba(0, 0, 0, .45);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cfm-panel {
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      width: min(420px, 92vw);
      padding: 18px;
      font: inherit;
    }

    .cfm-title {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .cfm-msg {
      font-size: 14px;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .cfm-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .cfm-btn {
      padding: 8px 12px;
      border-radius: 8px;
      font: inherit;
      border: 1px solid var(--line);
      cursor: pointer;
    }

    .cfm-btn:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }

    /* Cancel: flat, simple */
    .cfm-btn--cancel {
      background: var(--input-bg);
      color: var(--text);
    }

    /* {
      filter: brightness(0.98);
    } */

    /* OK: primary or danger, no gradients */
    .cfm-btn--ok {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .cfm-btn--ok:hover,
    .cfm-btn--cancel:hover {
      filter: brightness(1.5);
    }

    .cfm-btn--danger {
      background: var(--warn);
      border-color: var(--warn);
    }

    .cfm-btn--neutral {
      background: var(--input-bg);
      color: var(--text);
      border-color: var(--line);
    }

    .cfm-btn--neutral:hover {
      filter: brightness(2.5);
    }

    /* Subtle danger (calm, but distinct) */
    .cfm-btn--subtleDanger {
      background: var(--input-bg);
      color: var(--warn);
      border-color: var(--line);
    }

    .cfm-btn--subtleDanger:hover {
      border-color: var(--warn);
    }

    /* Settings menu */
    .settings-overlay {
      position: fixed;
      inset: 0;
      z-index: 9998;
      background: transparent;
      /* click-outside catcher */
    }

    /* Default (view): hide edit cards */
    html[data-mode="view"] .vw-card--edit {
      display: none;
    }

    /* Edit: hide read-only cards, show edit cards */
    html[data-mode="edit"] .vw-card {
      display: none;
    }

    html[data-mode="edit"] .vw-card--edit {
      display: block;
    }


    /* Starter card ‚Äî inline edit */
    .vw-card--edit input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--card);
      color: var(--fg);
    }

    .vw-card--edit input+input {
      margin-top: 8px;
    }

    .vw-card__meta {
      margin-top: 10px;
    }

    .vw-card__actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
    }


    .settings-panel {
      position: absolute;
      z-index: 9999;
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      width: 150px;
      /* smaller fixed width */
      max-width: 92vw;
      /* keep mobile-safe */
      min-width: 0;
      padding: 6px;
    }

    /* Let the two variants participate in the grid like normal cards */
    .starter-dual {
      display: contents;
      /* children become the grid items */
    }


    .settings-item {
      width: 100%;
      text-align: left;
      border: 0;
      background: transparent;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
    }

    .settings-item:hover {
      background: var(--input-bg);
    }

    /* wrapper to anchor floating controls inside the graph area */
    .graph-canvas {
      position: relative;
    }

    /* top-centered buttons INSIDE the graph */
    .graph-canvas .graph-fabs--top {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 6;
      pointer-events: none;
      /* let graph drag/pan pass through */
    }

    .graph-canvas .graph-action {
      /* but keep buttons clickable */
      pointer-events: auto;
    }

    .graph-canvas .graph-action[disabled] {
      cursor: not-allowed;
    }

    /* Make the 'Required' checkbox bigger + aligned */
    .kv div:has(#f_req) {
      display: flex;
      align-items: end;
      gap: 0.4rem;
    }

    /* center it vertically */
    #f_req {
      transform: scale(1.5);
      /* tweak 1.9‚Äì2.3 to match your input height */
      transform-origin: bottom;
      accent-color: var(--accent);
      /* theme color when checked */
      margin: 4px;
      outline: none;
      box-shadow: none;
      /* small breathing room */
    }
  </style>
</head>

<body>

  <script type="text/plain" id="jsonEmbedded">


  </script>


  <header>
    <div class="wrap">
      <div class="row">
        <h1 class="grow">OpsPath Studio ¬∑ SOP Builder</h1>
        <div class="controls">
          <button id="btnHome" data-hide="guide" class="vw-home" title="Home" onclick="goHome()">
            üè† Home
          </button>

          <!-- <div class="upload">
            <input id="importHtmlInput" type="file" accept=".html,text/html" hidden>
            <button id="importHtmlBtn" class="btn">Import Viewer HTML‚Ä¶</button>
            <span id="importHtmlNote" class="small"></span>
          </div> -->

          <input id="importHtmlInput" type="file" accept=".html,text/html" hidden>
          <span id="importHtmlNote" class="small"></span>



          <button id="globalSaveBtn" disabled>Save</button>

          <!-- <button id="resetSopBtn" class="btn">Reset</button> -->


          <div class="seg" id="modeSeg" data-hide="guide">
            <button id="modeView" class="seg-btn">Preview</button>
            <button id="modeEdit" class="seg-btn">Edit</button>
          </div>

          <!-- <button id="themeToggle" class="btn">üåô Dark</button> -->
          <!-- <button id="exportViewerBtn" class="btn-accent">Export Viewer HTML</button> -->
          <button id="settingsBtn" class="btn">‚öôÔ∏è</button>

        </div>
      </div>
    </div>
  </header>

  <main>
    <section id="starter">
      <div id="vwWizard">
        <div class="vw-crumbs">
          <button id="vwBackHome" onclick="goHome()" class="btn">‚óÄ Back</button>
          <span class="title" id="vwStarterTitle"></span>
        </div>
        <div id="vwProgress" class="small"></div>
        <div id="vwStep"></div>
        <div class="vw-nav">
          <button id="vwPrev" class="btn">Previous</button>
          <button id="vwNext" class="btn btn-accent">Next</button>
        </div>
      </div>
      <div id="editStarter" class="layout">

        <!-- Center: Graph -->
        <div class="panel graph-panel" id="graphPanel">
          <div class="graph-header">
            <div class="rowflex">
              <strong>Map</strong>
              <span class="badge">Top‚ÜíBottom</span>
            </div>
            <div class="graph-zoom">
              <button id="zoomOutBtn">‚àí</button>
              <button id="zoomInBtn">+</button>
              <button id="zoomResetBtn">Reset position & zoom</button>
              <button id="formatBtn" class="graph-action" title="Auto format">Format graph</button>
              <button id="fullscreenBtn">Full screen</button>
            </div>
          </div>
          <div class="graph-canvas" id="graphCanvas">
            <svg id="graphSvg" class="graph-svg" role="img">
              <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8"
                  orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#98a2b3"></path>
                </marker>
              </defs>
            </svg>
            <div class="graph-fabs graph-fabs--top" id="graphFabsTop">
              <!-- <button id="addAfterBtn" class="graph-action graph-action--accent" title="Add step after">+After</button> -->
              <button id="addFreeBtn" class="graph-action" title="Add step (free)">+ Add Step</button>
              <!-- <button id="addBeforeBtn" class="graph-action graph-action--accent"
                title="Add step before">+Before</button>
              <button id="dupStepBtn" class="graph-action" title="Delete step">Duplicate</button> -->
              <button id="delStepBtn" class="graph-action warn" title="Delete step">- Delete Step</button>
            </div>
          </div>
          <div class="small">
            Click a node to edit. Edges come from <b>step.next</b> (instruction/input/multi-select) and from
            <b>option.next</b> (single-select). Edge labels show <i>option.value</i>.
          </div>
        </div>

        <!-- Right: Inspector -->
        <div class="panel" id="rightPanel">
          <h2>Properties</h2>
          <div id="propBox" class="small">Select a step from the list or the map.</div>

          <div id="toolMsg" class="small"></div>
        </div>
      </div>
    </section>
    <section id="landing">
      <div class="wrap">
        <div id="vwLanding"></div>

      </div>
    </section>


    <div id="dlgNewStarter" class="vw-dialog hidden">
      <div class="vw-dialog__panel" role="dialog">
        <h3 id="nsHeading">Create starter</h3>

        <div class="vw-field">
          <label for="nsLabel">Label</label>
          <input maxlength="50" id="nsLabel" type="text" placeholder="Starter X" required>
          <p id="nsLabelErr" class="vw-error"></p>

        </div>

        <div class="vw-field">
          <label for="nsSummary">Summary</label>
          <textarea maxlength="200" id="nsSummary" rows="3" placeholder="Optional"></textarea>
        </div>

        <div class="vw-actions">
          <button type="button" class="btn" id="nsCancel">Cancel</button>
          <button type="button" class="btn-accent" id="nsCreate">Create</button>
        </div>

      </div>
    </div>




  </main>

  <script>



    function flashSaved(btn) {
      const old = btn.textContent;
      btn.textContent = 'Saved ‚úì';
      setTimeout(() => (btn.textContent = old), 1200);
    }



    function openDB(name, version = 1, onUpgrade) {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(name, version);
        req.onerror = () => reject(req.error);
        req.onupgradeneeded = (e) => {
          const db = req.result;
          if (onUpgrade) onUpgrade(db, e.oldVersion, e.newVersion);
        };
        req.onsuccess = () => resolve(req.result);
      });
    }

    async function idbPut(dbName, storeName, value) {
      const db = await openDB(dbName, 1, (db) => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id' });
        }
      });
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).put(value);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // async function idbPut(dbName, storeName, value) {
    //   // 1) open without forcing a version, see what's there
    //   let db = await new Promise((res, rej) => {
    //     const req = indexedDB.open(dbName);
    //     req.onsuccess = () => res(req.result);
    //     req.onerror = () => rej(req.error);
    //   });

    //   // 2) if the store is missing, reopen with version+1 and create it in upgrade
    //   if (!db.objectStoreNames.contains(storeName)) {
    //     const newVersion = (db.version || 1) + 1;
    //     db.close();
    //     db = await new Promise((res, rej) => {
    //       const req = indexedDB.open(dbName, newVersion);
    //       req.onupgradeneeded = () => {
    //         const udb = req.result;
    //         if (!udb.objectStoreNames.contains(storeName)) {
    //           udb.createObjectStore(storeName, { keyPath: 'id' });
    //         }
    //       };
    //       req.onsuccess = () => res(req.result);
    //       req.onerror = () => rej(req.error);
    //     });
    //   }

    //   // 3) put
    //   return new Promise((resolve, reject) => {
    //     const tx = db.transaction(storeName, 'readwrite');
    //     tx.oncomplete = () => resolve(true);
    //     tx.onerror = () => reject(tx.error);
    //     tx.objectStore(storeName).put(value);
    //   });
    // }


    async function idbGet(dbName, storeName, key) {
      const db = await openDB(dbName, 1, (db) => {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id' });
        }
      });
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readonly');
        const req = tx.objectStore(storeName).get(key);
        req.onsuccess = () => resolve(req.result ? req.result.sop : null);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbDel(dbName, storeName, key) {
      const db = await openDB(dbName, 1);
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, 'readwrite');
        tx.objectStore(storeName).delete(key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Any input/change inside header editor or starter editor toggles dirty
    document.addEventListener('input', (e) => {
      // console.log('e.target', e.target);
      if (isInEditableArea(e.target)) setDirty(true); renderViewStep();
    }, true);

    // Only mark dirty on change if the value actually differs from SOP
    document.addEventListener('change', (e) => {
      // console.log('e.target', e.target);

      const t = e.target;
      if (!t) return;
      if (!isInEditableArea(t)) return;

      // if (t.id === 'vwTitleInput') {
      //   const v = (t.value || '').trim();
      //   if ((sop.title || '') !== v) { sop.title = v; setDirty(true); }
      //   return;
      // }
      // if (t.id === 'vwDescInput') {
      //   const v = (t.value || '').trim();
      //   if ((sop.description || '') !== v) { sop.description = v; setDirty(true); }
      //   return;
      // }

      setDirty(true);
    }, true);


    let sop = makeBlankSOP();
    let savedSop = null; // last saved snapshot

    const viewState = { starterIdx: 0, answers: {}, selectedStepId: 0 };


    // ---- Save button state ----
    let isDirty = false;
    function setDirty(v = true) { isDirty = !!v; updateSaveBtn(); }
    function clearDirty() { setDirty(false); }

    function updateSaveBtn() {
      const btn = document.getElementById('globalSaveBtn');
      if (!btn) return;
      btn.disabled = !isDirty;
      btn.classList.toggle('btn-accent', isDirty);
      btn.classList.toggle('btn', !isDirty);
    }

    function isInEditableArea(el) {
      const hdr = document.getElementById('vwHeaderEditor');
      const edt = document.getElementById('editStarter');
      return (hdr && hdr.contains(el)) || (edt && edt.contains(el));
    }

    async function performSave() {
      if (!isDirty) return false;
      try {
        // if (typeof syncHeaderInputsIntoSop === 'function') syncHeaderInputsIntoSop();
        const payload = JSON.parse(JSON.stringify(sop));
        await idbPut('opsPathDB', 'sops', {
          id: 'current',
          sop: payload,
          updatedAt: new Date().toISOString()
        });
        savedSop = structuredClone(sop);
        clearDirty();
        return true;
      } catch (err) {
        console.error('Save failed', err);
        alert('Save failed: ' + (err?.message || err));
        return false;
      }
    }

    document.getElementById('globalSaveBtn')?.addEventListener('click', saveSop);


    async function saveSop() {
      const ok = await performSave();
      if (!ok) return;
      const btnSave = document.getElementById('globalSaveBtn');
      const old = btnSave.textContent; btnSave.textContent = 'Saved ‚úì';
      setTimeout(() => btnSave.textContent = old, 1200);
    }


    let hotkeysWired = false;
    function wireHotkeys() {
      if (hotkeysWired) return; hotkeysWired = true;

      document.addEventListener('keydown', async (e) => {
        // const currentMode = document.documentElement.getAttribute('data-mode');
        const activeEl = document.activeElement;
        // if is dirty anywhere in the doc, Ctrl+S / Cmd+S triggers save
        const isSave = (e.ctrlKey || e.metaKey) && (e.key === 's' || e.key === 'S');

        // if (!) return;
        if (
          isSave &&
          isDirty &&
          isEditMode()) {

          e.preventDefault();
          // if (isDirty) {
          saveSop();
          // }
        }

        // if in edit mode and on the graph and a step is selected, Del triggers delete
        if (
          e.key === 'Delete' &&
          isEditMode() &&
          viewState.selectedStepId &&
          !isInEditableArea(activeEl)
        ) {
          e.preventDefault();
          delStep();
        }
      });
    }


    /*** Elements ***/
    const starterSelect = document.getElementById('starterSelect');
    const stepsList = document.getElementById('stepsList');
    const graphSvg = document.getElementById('graphSvg');
    const graphPanel = document.getElementById('graphPanel');


    document.addEventListener('DOMContentLoaded', () => {


      (async () => {
        // 1) Try embedded JSON
        // check run mode studio or guide
        const currentRunMode = document.documentElement.getAttribute('run-mode');
        if (currentRunMode === 'guide') {
          const embedded = document.getElementById('jsonEmbedded');
          if (embedded && embedded.textContent) {
            try {
              const parsed = JSON.parse(embedded.textContent);
              if (parsed && Array.isArray(parsed.starters)) {
                sop = parsed;
                // savedSop = structuredClone(sop);
              }
            } catch (err) {
              console.warn('Failed to parse embedded SOP JSON', err);
            }
          }

        }
        // 2) if not found, load it from db
        else {
          try {
            const restored = await idbGet('opsPathDB', 'sops', 'current');
            if (restored) {
              sop = restored;
              // savedSop = structuredClone(sop);

            }
          } catch (_) { }
        }
        // 1) if not found load create a new one
        if (!sop || !Array.isArray(sop.starters) || sop.starters.length === 0) {
          sop = makeBlankSOP();
        }




        viewState.starterIdx = 0;
        viewState.selectedStepId = sop.starters[0]?.steps?.[0]?.id || null;

        ensureSop();
        // renderAll();
        renderViewAndEditLanding();

        wireGlobal();
        wireHotkeys();
        savedSop = structuredClone(sop);


        if (typeof updateSaveBtn === 'function') updateSaveBtn();

        // Warn on tab close / refresh / navigate away when there are unsaved changes
        window.addEventListener('beforeunload', (e) => {
          if (!isDirty) return;   // only if something is unsaved
          e.preventDefault();                   // required by some browsers
          e.returnValue = '';                   // shows the built-in confirmation dialog
        });

      })();
    });


    // Force-blur active input when interacting with the map (so Enter/blur commits fire)
    ['pointerdown', 'mousedown', 'touchstart'].forEach(evt => {
      graphSvg.addEventListener(evt, () => {
        const a = document.activeElement;
        if (a && (a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.tagName === 'SELECT')) a.blur();
      }, true); // capture=true to catch drags too
    });

    function cssVar(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }
    function syncArrowColor() {
      const arrowPath = document.querySelector('#arrow path');
      if (arrowPath) arrowPath.setAttribute('fill', cssVar('--muted'));
    }
    syncArrowColor();

    // function applyMode() {
    //   const view = document.getElementById('landing');   // viewer section (landing + wizard containers)
    //   const starterEdit = document.getElementById('starter');   // studio section (left/center/right)
    //   const wizard = document.getElementById('vwWizard');    // viewer wizard panel (inside landing)
    //   const landing = document.getElementById('vwLanding');  // viewer landing host

    // }


    (function themeInit() {
      // const btn = document.getElementById('themeToggle');
      const saved = localStorage.getItem('theme');
      const prefersDark = matchMedia && matchMedia('(prefers-color-scheme: dark)').matches;
      setTheme(saved || (prefersDark ? 'dark' : 'light'));

      // btn?.addEventListener('click', () => {

      // });


    })();

    (function studioOrGuideInit() {
      // get current run mode from HTML attribute
      const currentRunMode = document.documentElement.getAttribute('run-mode');
      if (!currentRunMode) {
        document.documentElement.setAttribute('run-mode', 'studio');
      }

    })();

    (function modeInit() {
      let btnPreview = document.getElementById('modeView');
      let btnEdit = document.getElementById('modeEdit');

      changeDataMode('view');

      btnPreview?.addEventListener('click', async () => {
        if (isDirty) {
          const ok = await confirmDialog({
            title: 'Unsaved changes',
            message: 'Preview now will discard edits.',
            confirmText: 'Discard & Preview',
            cancelText: 'Stay in Edit',
            variant: 'subtleDanger'   // ‚Üê small ‚Äúdanger‚Äù cue, not aggressive
          });
          if (!ok) return;                 // Stay in Edit
          if (savedSop) {
            sop = structuredClone(savedSop);
          }
          clearDirty();
        }

        changeDataMode('view');



        // renderStarterMeta();
      });




      btnEdit?.addEventListener('click', () => {
        // renderAll();
        changeDataMode('edit');
        // formDirty = false;
        // renderAll();
        // wireLandingPageEdit();
      });

    })();

    // function showCurrent() {
    // }


    function goHome() {
      // resetStarterValues();
      changeScreen('landing');
    }


    (function screenInit() {
      // this is to initialize the data-screen="landing" or "starter" state in the top HTML


      // const saved = localStorage.getItem('screen');
      changeScreen('landing');
    })();

    function changeDataMode(newDataMode) {
      if (newDataMode !== 'view' && newDataMode !== 'edit') {
        throw new Error("Invalid mode: must be 'view' or 'edit'");
      }
      document.documentElement.setAttribute('data-mode', newDataMode);
      localStorage.setItem('data-mode', newDataMode);

      // renderStarters();
      renderViewAndEditLanding()
    }

    function changeScreen(screen) {
      if (screen !== 'landing' && screen !== 'starter') {
        throw new Error("Invalid screen: must be 'landing' or 'starter'");
      }
      document.documentElement.setAttribute('screen', screen);
      localStorage.setItem('screen', screen);
    }

    function changeRunMode(runMode) {
      if (runMode !== 'studio' && runMode !== 'guide') {
        throw new Error("Invalid Run Mode: must be 'studio' or 'guide'");
      }
      document.documentElement.setAttribute('run-mode', runMode);
    }



    function on(id, ev, fn) { const el = document.getElementById(id); if (el) el.addEventListener(ev, fn); }



    function wireGlobal() {


      // document.getElementById('addBeforeBtn').addEventListener('click', () => addStepRelative('before'));
      // document.getElementById('addAfterBtn').addEventListener('click', () => addStepRelative('after'));
      // document.getElementById('dupStepBtn').addEventListener('click', dupStep);
      document.getElementById('delStepBtn').addEventListener('click', delStep);

      document.getElementById('addFreeBtn').addEventListener('click', () => {
        placingFree = true;
        ghostPos = null;
        renderGraph();
      });




      document.getElementById('zoomInBtn').addEventListener('click', () => { mapZoom *= 1.2; renderGraph(); });
      document.getElementById('zoomOutBtn').addEventListener('click', () => { mapZoom /= 1.2; renderGraph(); });
      document.getElementById('zoomResetBtn').addEventListener('click', () => { resetGraphZoom(); renderGraph(); });

      document.getElementById('formatBtn').addEventListener('click', formatGraph);


      const fsBtn = document.getElementById('fullscreenBtn');
      fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement === graphPanel) document.exitFullscreen();
        else graphPanel.requestFullscreen?.();
      });

    }
    /*** Renderers ***/
    function renderAll() {
      renderViewAndEditLanding();
      // renderStarterMeta();

      renderViewStep();
      // renderSteps();
      renderInspector();
      renderGraph();
    }

    // function renderStarters() {
    //   if (!Array.isArray(sop.starters)) sop.starters = [];
    //   // ensure at least one starter exists
    //   // if (sop.starters.length === 0) {
    //   //   sop.starters.push({
    //   //     id: 'starter_1',
    //   //     label: 'Starter 1',
    //   //     summary: '',
    //   //     steps: [makeStep('instruction'), makeStep('end')]
    //   //   });
    //   // }
    //   viewState.starterIdx = Math.min(viewState.starterIdx, sop.starters.length - 1);

    // }

    // ['pointerdown', 'mousedown', 'touchstart'].forEach(evt => {
    //   graphSvg.addEventListener(evt, () => {
    //     const a = document.activeElement;
    //     if (a && (a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.tagName === 'SELECT')) a.blur();
    //   }, true);
    // });

    //   function renderStarterMeta() {
    //     const st = getStarter();
    //     const box = document.getElementById('starterMetaBox');
    //     if (!box) return;

    //     if (!st) {
    //       box.innerHTML = '<div class="small">No starter selected.</div>';
    //       return;
    //     }

    //     box.innerHTML = `
    //   <label>Title</label>
    //   <input id="st_title" type="text" value="${escapeAttr(st.title || '')}"/>

    //   <label>Summary</label>
    //   <input id="st_summary" type="text" value="${escapeAttr(st.summary || '')}"/>

    //   <label>Description</label>
    //   <input id="st_desc" type="text" value="${escapeAttr(st.description || '')}"/>


    // `;

    //     const t = box.querySelector('#st_title');
    //     const s = box.querySelector('#st_summary');
    //     const d = box.querySelector('#st_desc');

    //     t.addEventListener('input', () => { st.title = t.value; });
    //     s.addEventListener('input', () => { st.summary = s.value; });
    //     d.addEventListener('input', () => { st.description = d.value; });
    //   }



    function renderInspector() {
      const box = document.getElementById('propBox');
      const st = getStarter();
      const step = st.steps.find(x => x.id === viewState.selectedStepId);
      if (!step) { box.innerHTML = '<span class="small">Select a step.</span>'; return; }

      // Common fields
      let html = `
    <label>ID</label><input id="f_id" type="text" value="${escapeAttr(step.id)}"/>
    <div id="f_id_err" class="error" style="display:none"></div>
    <div class="kv">
      <div>
        <label>Type</label>
        <select id="f_type">
          ${['instruction', 'input', 'select'].map(t => `<option ${t === step.type ? 'selected' : ''} value="${t}">${t}</option>`).join('')}
        </select>
      </div>
      <div>
        <div>
          <input id="f_req" type="checkbox" ${step.required ? 'checked' : ''} />
        </div>
        <label>Required</label>
      </div>
    </div>
  `;

      // Type-specific
      if (step.type === 'instruction') {
        html += `
      <label>Title</label><input id="f_title" type="text" value="${escapeAttr(step.title || '')}"/>
      <label>Body</label><textarea id="f_body" rows="4">${escapeHtml(step.body || '')}</textarea>
      
        <label>Next (step.id)</label>
        ${nextSelectHtml(st.steps, step.next, step.id)}
      
      <div class="kv">
        <div><label>Image (base64)</label><input id="f_img" type="text" value="${escapeAttr(step.img_b64 || '')}"/></div>
        <div><label>Upload image</label><input id="f_img_file" type="file" accept="image/*"/></div>
      </div>
    `;
      }
      else if (step.type === 'input') {
        html += `
      <label>Label</label><input id="f_label" type="text" value="${escapeAttr(step.label || '')}"/>
      <label>Placeholder</label><input id="f_ph" type="text" value="${escapeAttr(step.placeholder || '')}"/>
      <div class="kv">
        <div><label>Regex</label><input id="f_regex" type="text" value="${escapeAttr(step.regex || '')}" placeholder="e.g. ^[1-9][0-9]{5}$"/></div>
        <div><label>Error message</label><input id="f_err" type="text" value="${escapeAttr(step.error || '')}"/></div>
      </div>
      <div class="kv">
        <div><label>Required message</label><input id="f_reqmsg" type="text" value="${escapeAttr(step.requiredMessage || '')}"/></div>
        <div></div>
        </div>
        <label>Next (step.id)</label>
        ${nextSelectHtml(st.steps, step.next, step.id)}
      <div class="kv">
        <div><label>Image (base64)</label><input id="f_img" type="text" value="${escapeAttr(step.img_b64 || '')}"/></div>
        <div><label>Upload image</label><input id="f_img_file" type="file" accept="image/*"/></div>
      </div>
    `;
      }
      else if (step.type === 'select') {
        html += `
      <label>Label</label><input id="f_label" type="text" value="${escapeAttr(step.label || '')}"/>
      <div class="kv">
        <div>
          <label>Display</label>
          <select id="f_display">
            <option ${step.display === 'cards' ? 'selected' : ''} value="cards">cards</option>
            <option ${step.display === 'list' ? 'selected' : ''} value="list">list</option>
          </select>
        </div>
        <div>
          <label>Mode</label>
          <select id="f_mode">
            <option ${step.mode === 'single' ? 'selected' : ''} value="single">single</option>
            <option ${step.mode === 'multi' ? 'selected' : ''} value="multi">multi</option>
          </select>
        </div>
      </div>
      <div class="kv">
        <div><label>Min (multi)</label><input id="f_min" type="number" value="${escapeAttr(step.min ?? '')}"/></div>
        <div><label>Max (multi)</label><input id="f_max" type="number" value="${escapeAttr(step.max ?? '')}"/></div>
      </div>
      <div class="kv">
        <div><label>Min message</label><input id="f_minmsg" type="text" value="${escapeAttr(step.minMessage || '')}"/></div>
        <div><label>Max message</label><input id="f_maxmsg" type="text" value="${escapeAttr(step.maxMessage || '')}"/></div>
      </div>
      <label>Options</label>
      <table class="table" id="optTable">
        <thead><tr><th style="width:18%">value</th><th style="width:18%">label</th><th>hint</th><th style="width:20%">next</th><th class="center">del</th></tr></thead>
        <tbody>
          ${(step.options || []).map((o, i) => optionRowHtml(o, i, st.steps)).join('')}
        </tbody>
      </table>
      <div class="rowflex">
        <button id="addOptBtn" class="iconbtn">+ Option</button>
      </div>
      <label>After (step.next, used esp. for multi)</label>
      ${nextSelectHtml(st.steps, step.next, step.id)}
    `;
      }

      box.innerHTML = html;

      // -------- Wire common ----------
      const f_type = box.querySelector('#f_type');
      const f_req = box.querySelector('#f_req');

      // --- ID commit on Enter/blur + duplicate guard
      const f_id = box.querySelector('#f_id');
      const f_id_err = box.querySelector('#f_id_err');

      function commitId() {
        const st = getStarter();
        const oldId = step.id;
        let v = slugify(f_id.value.trim()) || oldId;

        if (v === oldId) { f_id_err.style.display = 'none'; f_id_err.textContent = ''; return; }

        const dup = (st.steps || []).some(s => s.id === v && s !== step);
        if (dup) {
          f_id_err.textContent = `ID "${v}" already exists`;
          f_id_err.style.display = '';
          return;
        }

        rewriteRefs(oldId, v);
        step.id = v;
        viewState.selectedStepId = v;
        f_id.value = v;
        f_id_err.style.display = 'none'; f_id_err.textContent = '';
        renderGraph();
        renderViewStep();
        // if (studioMode === 'view') renderViewAndEditLanding();

      }
      f_id.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); commitId(); f_id.blur(); } });
      f_id.addEventListener('blur', commitId);

      f_type.addEventListener('change', () => {
        const t = f_type.value;
        if (t !== step.type) {
          const repl = makeStep(t);
          // keep same id & required
          repl.id = step.id; repl.required = step.required;
          // migrate title/label best-effort
          repl.title = step.title || repl.title;
          repl.label = step.label || repl.label;
          repl.next = step.next || repl.next;
          repl.pos = step.pos || repl.pos;
          replaceStep(step.id, repl);
          viewState.selectedStepId = repl.id;
          // renderAll();
          renderGraph();
          renderInspector();

          // if (studioMode === 'view') renderViewAndEditLanding();

        }
      });
      // f_req.addEventListener('change', () => { step.required = Boolean(f_req.value); });
      f_req?.addEventListener('change', () => { step.required = f_req.checked; setDirty(true); });

      // -------- Wire per-type ----------
      if (step.type === 'instruction') {
        const f_title = box.querySelector('#f_title');
        const f_body = box.querySelector('#f_body');
        const f_img = box.querySelector('#f_img');
        const f_img_file = box.querySelector('#f_img_file');

        // Title: commit on Enter/blur (no live render while typing)
        function commitTitle() {
          const v = f_title.value.trim();
          if ((step.title || '') === v) return;
          step.title = v;
          // renderSteps(); 
          renderGraph();
        }
        f_title.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); commitTitle(); f_title.blur(); } });
        f_title.addEventListener('blur', commitTitle);

        // Others can be live-updated
        f_body.addEventListener('input', () => { step.body = f_body.value; });
        f_img.addEventListener('input', () => { step.img_b64 = f_img.value || undefined; });
        f_img_file.addEventListener('change', ev => handleImageToBase64(ev, uri => { step.img_b64 = uri; f_img.value = uri; }));

        // if (step.type !== 'end') {
        const f_next = box.querySelector('#f_next');
        f_next.addEventListener('change', () => {
          step.next = f_next.value || undefined;
          ensureSopMandatory();
          renderGraph();
        });
        // }
      }
      else if (step.type === 'input') {
        const f_label = box.querySelector('#f_label');
        const f_ph = box.querySelector('#f_ph');
        const f_regex = box.querySelector('#f_regex');
        const f_err = box.querySelector('#f_err');
        const f_reqmsg = box.querySelector('#f_reqmsg');
        const f_img = box.querySelector('#f_img');
        const f_img_file = box.querySelector('#f_img_file');
        const f_next = box.querySelector('#f_next');

        // Label: commit on Enter/blur
        function commitLabel() {
          const v = f_label.value.trim();
          if ((step.label || '') === v) return;
          step.label = v;
          // renderSteps(); // map not required
        }
        f_label.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); commitLabel(); f_label.blur(); } });
        f_label.addEventListener('blur', commitLabel);

        // Others live
        f_ph.addEventListener('input', () => { step.placeholder = f_ph.value; });
        f_regex.addEventListener('input', () => { step.regex = f_regex.value || undefined; });
        f_err.addEventListener('input', () => { step.error = f_err.value || undefined; });
        f_reqmsg.addEventListener('input', () => { step.requiredMessage = f_reqmsg.value || undefined; });
        f_img.addEventListener('input', () => { step.img_b64 = f_img.value || undefined; });
        f_img_file.addEventListener('change', ev => handleImageToBase64(ev, uri => { step.img_b64 = uri; f_img.value = uri; }));
        f_next.addEventListener('change', () => { step.next = f_next.value || undefined; renderGraph(); });
      }
      else if (step.type === 'select') {
        const f_label = box.querySelector('#f_label');
        const f_display = box.querySelector('#f_display');
        const f_mode = box.querySelector('#f_mode');
        const f_min = box.querySelector('#f_min');
        const f_max = box.querySelector('#f_max');
        const f_minmsg = box.querySelector('#f_minmsg');
        const f_maxmsg = box.querySelector('#f_maxmsg');
        const addOptBtn = box.querySelector('#addOptBtn');
        const f_next = box.querySelector('#f_next');

        // Label: commit on Enter/blur
        function commitLabel() {
          const v = f_label.value.trim();
          if ((step.label || '') === v) return;
          step.label = v;
          // renderSteps();
        }
        f_label.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); commitLabel(); f_label.blur(); } });
        f_label.addEventListener('blur', commitLabel);

        // Others live
        f_display.addEventListener('change', () => { step.display = f_display.value; });
        f_mode.addEventListener('change', () => { step.mode = f_mode.value; });
        f_min.addEventListener('input', () => { step.min = f_min.value === '' ? undefined : Number(f_min.value); });
        f_max.addEventListener('input', () => { step.max = f_max.value === '' ? undefined : Number(f_max.value); });
        f_minmsg.addEventListener('input', () => { step.minMessage = f_minmsg.value || undefined; });
        f_maxmsg.addEventListener('input', () => { step.maxMessage = f_maxmsg.value || undefined; });
        f_next.addEventListener('change', () => { step.next = f_next.value || undefined; renderGraph(); });

        addOptBtn.addEventListener('click', () => {
          step.options = step.options || [];
          step.options.push({ value: 'opt_' + (step.options.length + 1), label: 'Option ' + (step.options.length + 1) });
          renderInspector();
          renderGraph();
        });

        // Options table row wiring
        box.querySelectorAll('[data-opt-idx]').forEach(row => {
          const i = Number(row.dataset.optIdx);
          const o = step.options[i];
          const fv = row.querySelector('.f_opt_value');
          const fl = row.querySelector('.f_opt_label');
          const fh = row.querySelector('.f_opt_hint');
          const fn = row.querySelector('.f_opt_next');
          // const fi = row.querySelector('.f_opt_img');
          const ff = row.querySelector('.f_opt_file');
          const fd = row.querySelector('.f_opt_del');

          fv.addEventListener('input', () => { o.value = slugify(fv.value) || 'opt'; renderGraph(); });
          fl.addEventListener('input', () => { o.label = fl.value; });
          fh.addEventListener('input', () => { o.hint = fh.value || undefined; });
          fn.addEventListener('change', () => { o.next = fn.value || undefined; renderGraph(); });
          // fi.addEventListener('input', () => { o.img_b64 = fi.value || undefined; });
          // ff.addEventListener('change', ev => handleImageToBase64(ev, uri => { o.img_b64 = uri; fi.value = uri; }));
          fd.addEventListener('click', () => { step.options.splice(i, 1); renderInspector(); renderGraph(); });
        });
      }
    }

    /*** Graph ***/
    let mapZoom = 0;
    let mapPan = { x: 0, y: 0 };
    let drag = { active: false, start: { x: 0, y: 0 }, pan0: { x: 0, y: -8 }, vw: 0, vh: 0, wpp: 1 };
    let lastGraphSize = { width: 900, height: 600 };

    let placingFree = false;
    let ghostPos = null; // {x, y} in world coords

    let draggingStepId = null;
    let dragOffset = null;
    let lastPositions = {}; // stepId -> {x,y} snapshot from last render





    // (function initGraphZoom() {
    //   mapZoom = 2.4;
    //   mapPan = { x: 0, y: -20 }
    // })

    (function initGraphZoom() {
      resetGraphZoom();
    })();

    function resetGraphZoom() {
      mapZoom = 2.4;
      mapPan = { x: 0, y: -20 }
    };

    function clientToWorld(e) {
      const bb = graphSvg.getBoundingClientRect();
      const vw = 1000, vh = 1000; // must match renderGraph() viewBox world size
      const x = mapPan.x + (e.clientX - bb.left) * (vw / mapZoom) / bb.width;
      const y = mapPan.y + (e.clientY - bb.top) * (vh / mapZoom) / bb.height;
      return { x, y };
    }


    function formatGraph() {
      const st = getStarter(); if (!st) return;
      (st.steps || []).forEach(s => { s.pos = null; }); // drop manual positions
      ensureSopPositions();

      // renderAll(); // layoutVertical will place everything
      renderGraph();
    }

    function getStepPos(id) {
      const st = getStarter();
      const step = st?.steps?.find(s => s.id === id);
      if (step?.pos) return { ...step.pos };            // stored pos
      if (lastPositions?.[id]) return { ...lastPositions[id] }; // computed pos
      return null;
    }

    function persistMissingPositionsFromLayout() {
      const st = getStarter(); if (!st) return false;
      let changed = false;
      (st.steps || []).forEach(s => {
        if (!s.pos && lastPositions?.[s.id]) {
          s.pos = { ...lastPositions[s.id] };
          changed = true;
        }
      });
      if (changed) setDirty(true);
      return changed;
    }

    // MOUSE DOWN
    // graphSvg.addEventListener('mousedown', (e) => {
    //   e.preventDefault();
    //   drag.active = true;
    //   drag.start = { x: e.clientX, y: e.clientY };
    //   drag.pan0 = { ...mapPan };

    //   const bb = graphSvg.getBoundingClientRect();
    //   lastGraphSize.width = bb.width;
    //   lastGraphSize.height = bb.height;

    //   // These MUST match the viewBox setup in renderGraph()
    //   const worldW = 1000 / mapZoom;
    //   const worldH = 1000 / mapZoom;

    //   // world-units per pixel on each axis
    //   drag.wppX = worldW / bb.width;
    //   drag.wppY = worldH / bb.height;

    //   graphSvg.classList.add('dragging');
    //   graphPanel.classList.add('dragging');
    // });

    // graphSvg.addEventListener('mousedown', (e) => {
    //   if (!placingFree || !ghostPos) return;
    //   const st = getStarter(); if (!st) return;
    //   const step = makeStep('instruction');
    //   step.pos = { x: ghostPos.x, y: ghostPos.y };
    //   st.steps.push(step);
    //   viewState.selectedStepId = step.id;
    //   placingFree = false; ghostPos = null;
    //   setDirty(true);
    // }, true);


    // addEventListener('mousemove', (e) => {
    //   if (!placingFree) return;
    //   const bb = graphSvg.getBoundingClientRect();
    //   // convert client ‚Üí world
    //   const vw = 1000, vh = 1000;
    //   const wx = mapPan.x + (e.clientX - bb.left) * (vw / mapZoom) / bb.width;
    //   const wy = mapPan.y + (e.clientY - bb.top) * (vh / mapZoom) / bb.height;
    //   ghostPos = { x: wx, y: wy };
    //   renderGraph();
    // }, true);

    //   ]

    graphSvg.addEventListener('mousemove', (e) => {
      if (!placingFree) return;
      ghostPos = clientToWorld(e);
      renderGraph();
    }, true);


    // graphSvg.addEventListener('mousemove', (e) => {
    //   if (!placingFree) return;
    //   const bb = graphSvg.getBoundingClientRect();
    //   const vw = 1000, vh = 1000; // same virtual canvas you render with
    //   const wx = mapPan.x + (e.clientX - bb.left) * (vw / mapZoom) / bb.width;
    //   const wy = mapPan.y + (e.clientY - bb.top) * (vh / mapZoom) / bb.height;
    //   ghostPos = { x: wx, y: wy };
    //   renderGraph();
    // }, true);

    // graphSvg.addEventListener('mousedown', (e) => {
    //   const rect = e.target.closest('rect');
    //   if (!rect) return;
    //   const id = rect.getAttribute('step-id');
    //   if (!id || !lastPositions[id]) return;

    //   const p0 = clientToWorld(e);
    //   const p = lastPositions[id];
    //   draggingStepId = id;
    //   dragOffset = { dx: p.x - p0.x, dy: p.y - p0.y };
    //   e.preventDefault();
    //   e.stopPropagation();
    // }, true);

    graphSvg.addEventListener('mousedown', (e) => {
      // A) PLACE NEW STEP if we're in Add (ghost) mode
      if (placingFree) {
        const pt = clientToWorld(e);
        const st = getStarter(); if (!st) return;
        const step = makeStep('instruction');
        step.pos = { x: pt.x, y: pt.y };
        st.steps.push(step);
        viewState.selectedStepId = step.id;
        placingFree = false; ghostPos = null;
        setDirty(true);

        renderGraph();
        renderInspector();

        // focus the editor instead of leaving focus on the Add button
        queueMicrotask(() => {
          document.activeElement?.blur();
          const first = document.querySelector('#inspector input, #inspector textarea, .inspector input, .inspector textarea');
          first?.focus();
        });

        e.preventDefault();
        e.stopPropagation();
        return; // don't fall through to drag
      }

      // B) DRAG EXISTING NODE
      const rect = e.target.closest('rect');
      if (!rect) return;
      const id = rect.getAttribute('step-id');
      if (!id || !lastPositions[id]) return;

      const p0 = clientToWorld(e);
      const p = lastPositions[id];
      draggingStepId = id;
      dragOffset = { dx: p.x - p0.x, dy: p.y - p0.y };
      e.preventDefault();
      e.stopPropagation();
    }, true);


    addEventListener('mousemove', (e) => {
      if (!draggingStepId) return;
      const st = getStarter(); if (!st) return;
      const step = (st.steps || []).find(s => s.id === draggingStepId);
      if (!step) return;

      const pt = clientToWorld(e);
      step.pos = { x: pt.x + dragOffset.dx, y: pt.y + dragOffset.dy };
      renderGraph(); // live move
    }, true);

    addEventListener('mouseup', () => {
      if (!draggingStepId) return;
      draggingStepId = null;
      dragOffset = null;
      // we have to check here, as if it's already dirty, we should not save it, 
      // we're only going to save only if it's not dirty which means we are only saving the position when changed

      if (!isDirty) {
        isDirty = true;
        performSave();
      }

      queueMicrotask(() => {
        const first = document.querySelector('#inspector input, #inspector textarea, .inspector input, .inspector textarea');
        first?.focus();
      });
      // setDirty(true); // enable Save button
    }, true);




    graphSvg.addEventListener('wheel', (e) => {
      e.preventDefault(); // stop the page from scrolling
      const k = 1 / mapZoom; // keep speed consistent under zoom
      // vertical wheel ‚Üí move up/down, horizontal wheel (trackpads) ‚Üí left/right
      mapPan.x += e.deltaX * k;
      mapPan.y += e.deltaY * k;
      // renderAll();
      renderGraph();
    }, { passive: false });

    graphSvg.addEventListener('click', () => {
      if (!placingFree || !ghostPos) return;
      const st = getStarter(); if (!st) return;
      const step = makeStep('instruction');
      step.pos = { x: ghostPos.x, y: ghostPos.y }; // lock position
      st.steps.push(step);
      viewState.selectedStepId = step.id;
      placingFree = false; ghostPos = null;
      setDirty(true);
      // renderAll();

    }, true);


    function renderGraph() {
      const st = getStarter();
      const steps = st?.steps || [];
      if (!steps.length) {
        graphSvg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#98a2b3" font-size="14">No steps in this starter</text>';
        return;
      }
      const { nodes, edges } = buildGraph(st);
      const layout = layoutVertical(nodes, edges);
      lastPositions = layout;
      const svg = graphSvg;
      svg.innerHTML = `
                      <defs>
                        <marker id="arrow" viewBox="0 0 12 12" refX="12" refY="6"
                                markerWidth="10" markerHeight="10" markerUnits="userSpaceOnUse"
                                orient="auto">
                          <path d="M0 0 L12 6 L0 12 Z" fill="#98a2b3"></path>
                        </marker>
                      </defs>
                    `;


      const g = svg; // root
      const vw = 1000, vh = 1000; // world units used by layout
      const viewBox = `${mapPan.x} ${mapPan.y} ${vw / mapZoom} ${vh / mapZoom}`;
      svg.setAttribute('viewBox', viewBox);


      // edges (orthogonal: down then across)
      edges.forEach(e => {
        const s = layout[e.from], t = layout[e.to];
        if (!s || !t) return;
        const midY = (s.y + t.y) / 2;
        const d = `M ${s.x} ${s.y + 28} L ${s.x} ${midY} L ${t.x} ${midY} L ${t.x} ${t.y - 28}`;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', d);
        path.setAttribute('class', 'edge');
        path.setAttribute('marker-end', 'url(#arrow)');
        g.appendChild(path);

        if (e.label) {
          const tx = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          tx.setAttribute('class', 'edge-label');
          tx.setAttribute('x', (s.x + t.x) / 2);
          tx.setAttribute('y', midY - 4);
          tx.setAttribute('text-anchor', 'middle');
          tx.textContent = e.label;
          g.appendChild(tx);
        }
      });

      // nodes
      nodes.forEach(n => {
        const grp = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        grp.setAttribute('transform', `translate(${layout[n.id].x}, ${layout[n.id].y})`);
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('class', 'node-rect' + (n.id === viewState.selectedStepId ? ' current' : ''));
        rect.setAttribute('x', -80); rect.setAttribute('y', -28); rect.setAttribute('width', 160); rect.setAttribute('height', 56);
        rect.setAttribute('step-id', n.id);
        rect.style.cursor = 'move';


        grp.appendChild(rect);

        const tx = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tx.setAttribute('class', 'node-label');
        tx.setAttribute('text-anchor', 'middle');
        tx.setAttribute('y', 4);
        tx.textContent = n.label;
        tx.setAttribute('pointer-events', 'none');
        grp.appendChild(tx);

        grp.addEventListener('click', () => {
          viewState.selectedStepId = n.id;
          renderInspector();
          renderGraph();
          // updateAddAfterState(); // disable Add After when 'done' is selected
        });

        g.appendChild(grp);
      });

      if (placingFree && ghostPos) {
        const grp = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        grp.setAttribute('transform', `translate(${ghostPos.x}, ${ghostPos.y})`);
        grp.setAttribute('opacity', '0.35');
        grp.setAttribute('pointer-events', 'none');

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', -80); rect.setAttribute('y', -28);
        rect.setAttribute('width', 160); rect.setAttribute('height', 56);
        rect.setAttribute('rx', 8);
        rect.setAttribute('class', 'node-rect');
        rect.setAttribute('stroke-dasharray', '6,6');
        grp.appendChild(rect);

        const tx = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tx.setAttribute('class', 'node-label');
        tx.setAttribute('text-anchor', 'middle');
        tx.setAttribute('y', 4);
        tx.textContent = 'New step';
        grp.appendChild(tx);

        g.appendChild(grp);
      }

    }

    // function updateAddAfterState() {
    //   const btn = document.getElementById('addAfterBtn');
    //   if (!btn) return;
    //   const st = getStarter();
    //   const cur = st?.steps?.find(s => s.id === viewState.selectedStepId);
    //   // if (!!(cur && cur.type === 'end')) {
    //   //   btn.toggleAttribute('disabled', true);
    //   //   // btn.classList.add('disabled');
    //   //   // return;
    //   // }
    //   btn.toggleAttribute('disabled', !!(cur && isEndStep(cur)));
    //   btn.title = (cur && isEndStep(cur)) ? 'Cannot add step after the terminal "end" step' : 'Add step after current';
    //   // btn.classList.toggle('disabled', !!(cur && cur.type === 'end'));
    // }


    function buildGraph(starter) {
      const steps = starter.steps || [];
      // const nodes = steps.map(s => ({ id: s.id, label: s.title || s.label || s.id }));
      const nodes = steps.map(s => ({
        id: s.id,
        label: s.id || s.title || s.label,
        pos: s.pos || null
      }));
      const edges = [];

      for (let i = 0; i < steps.length; i++) {
        const s = steps[i];
        // const defaultNext = steps[i + 1]?.id || null; // ‚Üê fall back to sequential order
        // const defaultNext = null;



        if (s.type === 'instruction' || s.type === 'input') {
          // const target = s.next || defaultNext;
          // if (target) edges.push({ from: s.id, to: target });
          const target = s.next || null;
          if (target) edges.push({ from: s.id, to: target });

          (s.options || []).forEach(o => {
            if (o && o.next) edges.push({ from: s.id, to: o.next, label: o.label || '' });
          });

        }
        else if (s.type === 'select') {
          // option-level branches (single-select)
          if (Array.isArray(s.options)) {
            for (const o of s.options) {
              if (o?.next) {
                edges.push({ from: s.id, to: o.next, label: (o.label || o.value || '') });
              }
            }
          }

          if (s.mode === 'multi') {
            // multi-select: go to step.next or next step after selection phase
            // const target = s.next || defaultNext;
            // if (target) edges.push({ from: s.id, to: target, label: 'after' });
            // multi-select ‚Üí only if step.next is set
            const target = s.next || null;
            if (target) edges.push({ from: s.id, to: target, label: 'after' });

          } else {
            // single-select: if no option.next and no step.next, fall back to sequential
            // const hasOptNext = (s.options || []).some(o => o?.next);
            // const target = s.next || (!hasOptNext ? defaultNext : null);
            // if (target) edges.push({ from: s.id, to: target });
            const hasOptNext = (s.options || []).some(o => o?.next);
            const target = s.next || null;
            if (target) edges.push({ from: s.id, to: target });
          }
        }
        // 'end' has no outgoing edges
      }

      return { nodes, edges };
    }




    function layoutVertical(nodes, edges) {
      if (!nodes.length) return {};

      const nodeById = Object.fromEntries(nodes.map(n => [n.id, n]));


      // adjacency for forward edges
      const adj = {};
      nodes.forEach(n => adj[n.id] = []);
      edges.forEach(e => { (adj[e.from] ||= []).push(e.to); });

      // start from the first node (treat as root)
      const depth = {};
      const start = nodes[0].id;
      depth[start] = 0;

      // initial BFS
      const q = [start];
      while (q.length) {
        const u = q.shift();
        for (const v of adj[u] || []) {
          if (depth[v] == null) {
            depth[v] = depth[u] + 1;
            q.push(v);
          }
        }
      }
      // assign depth 0 for any isolated/unreached nodes
      nodes.forEach(n => { if (depth[n.id] == null) depth[n.id] = 0; });

      // relax depths so every edge goes strictly downward
      // if depth[to] <= depth[from], push it down
      let changed = true, guard = 0;
      while (changed && guard < 50) {
        changed = false; guard++;
        for (const e of edges) {
          const a = depth[e.from], b = depth[e.to];
          if (a != null && b != null && b <= a) {
            depth[e.to] = a + 1;
            changed = true;
          }
        }
      }

      // group nodes by depth (rows)
      const rows = {};
      nodes.forEach(n => {
        const d = depth[n.id] || 0;
        (rows[d] ||= []).push(n.id);
      });

      // order within each row (stable by original order)
      const colIndex = {};
      Object.keys(rows).sort((a, b) => a - b).forEach(d => {
        rows[d].forEach((id, i) => colIndex[id] = i);
      });

      // compute positions (vertical lanes)
      // const colWidth = 200;    // horizontal spacing
      // const rowGap = 140;     // vertical 
      // const x0 = 200, y0 = 60; // top-left origin

      // const pos = {};
      // nodes.forEach(n => {
      //   // console.log(`n`, n);
      //   // const d = depth[n.id] || 0;
      //   // const i = colIndex[n.id] || 0;

      //   pos[n.id] = n.pos ? { x: n.pos.x, y: n.pos.y }
      //     : { x: x0 + i * colWidth, y: y0 + d * rowGap };

      //   // pos[n.id] = { x: n.pos.x, y: n.pos.y }

      //   pos[n.id] = { x: x0 + i * colWidth, y: y0 + d * rowGap };
      // });

      const pos = {};
      nodes.forEach(n => {

        pos[n.id] = { x: n.pos.x, y: n.pos.y }
      });


      return pos;
    }


    /*** Actions ***/



    // function addStepRelative(where) {
    //   const st = getStarter(); if (!st) return;

    //   const idx = st.steps.findIndex(s => s.id === viewState.selectedStepId);
    //   const insertAt = (idx < 0 ? st.steps.length : idx + 1);
    //   const current = idx >= 0 ? st.steps[idx] : null;

    //   // create the new step
    //   const step = makeStep('instruction');

    //   // only when adding AFTER an instruction/input: rewire "next"
    //   if (where === 'after' && current && (current.type === 'instruction' || current.type === 'input')) {
    //     const prevNext = (typeof current.next !== 'undefined') ? current.next : null;
    //     step.next = prevNext || null;      // new step points to what current used to point to
    //     current.next = step.id;            // current now points to the new step
    //   } 
    //   // else if (where === 'before' && current && (current.type === 'instruction' || current.type === 'input')) {
    //   //   // place new step before current in the flow
    //   //   step.next = current.id; // new ‚Üí current
    //   //   // redirect predecessor (if any) to point to the new step
    //   //   const pred = st.steps.find(s => s.next === current.id);
    //   //   if (pred) pred.next = step.id;
    //   // }


    //   st.steps.splice(insertAt, 0, step);
    //   if (where === 'before' && current && (current.type === 'instruction' || current.type === 'input')) step.next = current.id;

    //   viewState.selectedStepId = step.id;
    //   setDirty(true);
    // }

    // async function addStepRelative(where) {
    //   // when done and 'after' is requested, show dialog and abort on confirm
    //   if (where === 'after') {
    //     const st = getStarter(); if (!st) return;
    //     const cur = st.steps.find(s => s.id === viewState.selectedStepId);
    //     if (cur && isEndStep(cur)) {
    //       const ok = await confirmDialog({
    //         // title: '??',
    //         title: 'Inspector hacks won‚Äôt work: adding after the terminal end step is forbidden.',
    //         confirmText: 'I am sorry and I won‚Äôt do that again üòî',
    //         // cancelText: 'Cancel',
    //         variant: 'danger',
    //         one: true
    //       });
    //       return;
    //     }
    //   }
    //   const st = getStarter(); if (!st) return;

    //   const idx = st.steps.findIndex(s => s.id === viewState.selectedStepId);
    //   const current = idx >= 0 ? st.steps[idx] : null;

    //   // always create an instruction (your button semantics)
    //   const step = makeStep('instruction');

    //   if (where === 'after') {
    //     if (current && (current.type === 'instruction' || current.type === 'input')) {
    //       // insert after an instruction/input and splice the flow
    //       const prevNext = ('next' in current) ? current.next : null;
    //       step.next = (prevNext || 'done');   // new ‚Üí old next (or done)
    //       current.next = step.id;             // current ‚Üí new
    //       st.steps.splice(idx + 1, 0, step);  // place after current
    //     } else {
    //       // no selection or non-actionable selection: append and point to done if present
    //       const done = st.steps.find(s => s.type === 'end') || st.steps.find(s => s.id === 'done');
    //       step.next = done ? done.id : null;
    //       st.steps.splice(idx < 0 ? st.steps.length : idx + 1, 0, step);
    //     }
    //   } else {
    //     // fallback (if someone calls 'before'): insert before without rewiring
    //     st.steps.splice(idx < 0 ? st.steps.length : idx, 0, step);
    //   }

    //   viewState.selectedStepId = step.id;
    //   // renderAll();
    //   renderGraph();
    //   renderInspector();
    //   setDirty(true);
    // }



    function dupStep() {
      const st = getStarter(); const s = st.steps.find(x => x.id === viewState.selectedStepId); if (!s) return;
      const c = JSON.parse(JSON.stringify(s));
      c.id = uniqueId(s.id + '_copy');
      st.steps.splice(st.steps.findIndex(x => x.id === s.id) + 1, 0, c);
      viewState.selectedStepId = c.id;
      // renderAll();
      // renderGraph();
      // renderInspector();
      setDirty(true);

      // if (studioMode === 'view') renderViewAndEditLanding();

    }
    function delStep() {
      const st = getStarter(); const i = st.steps.findIndex(x => x.id === viewState.selectedStepId); if (i < 0) return;
      const delId = st.steps[i].id;
      st.steps.splice(i, 1);
      // remove refs
      for (const step of st.steps) {
        if ((step.type === 'instruction' || step.type === 'input') && step.next === delId) delete step.next;
        if (step.type === 'select') {
          (step.options || []).forEach(o => { if (o.next === delId) delete o.next; });
          if (step.next === delId) delete step.next;
        }
      }
      viewState.selectedStepId = st.steps[Math.max(0, i - 1)]?.id || null;
      setDirty(true);

      // renderAll();
      ensureSopMandatory();

      renderGraph();
      renderInspector();
      renderViewStep();
      queueMicrotask(() => {
        document.activeElement?.blur();
        const first = document.querySelector('#inspector input, #inspector textarea, .inspector input, .inspector textarea');
        first?.focus();
      });
      // if (studioMode === 'view') renderViewAndEditLanding();

    }
    function replaceStep(id, repl) {
      const st = getStarter();
      const i = st.steps.findIndex(x => x.id === id);
      if (i >= 0) st.steps[i] = repl;
    }
    function rewriteRefs(oldId, newId) {
      if (oldId === newId) return;
      const st = getStarter();
      for (const step of st.steps) {
        if ((step.type === 'instruction' || step.type === 'input') && step.next === oldId) step.next = newId;
        if (step.type === 'select') {
          (step.options || []).forEach(o => { if (o.next === oldId) o.next = newId; });
          if (step.next === oldId) step.next = newId;
        }
      }
    }

    function resetListenersByClone(el) {
      if (!el) return null;
      const clone = el.cloneNode(true);
      el.parentNode.replaceChild(clone, el);
      return clone;
    }


    // Custom confirm dialog (uses CSS classes + your vars)
    function confirmDialog({ title = 'Confirm', message = '', confirmText = 'OK', cancelText = 'Cancel', variant = 'primary', one = false } = {}) {
      const okClass =
        variant === 'neutral' ? 'cfm-btn cfm-btn--neutral' :
          variant === 'subtleDanger' ? 'cfm-btn cfm-btn--subtleDanger' :
            variant === 'danger' ? 'cfm-btn cfm-btn--ok cfm-btn--danger' :
              'cfm-btn cfm-btn--ok';


      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'cfm-overlay';

        const panel = document.createElement('div');
        panel.className = 'cfm-panel';

        const actionsHtml = one
          ? `<div class="cfm-actions">
                <button id="cfmOk" class="${okClass}">${confirmText}</button>
              </div>`
          : `<div class="cfm-actions">
                <button id="cfmCancel" class="cfm-btn cfm-btn--cancel">${cancelText}</button>
                <button id="cfmOk" class="${okClass}">${confirmText}</button>
              </div>`;

        panel.innerHTML = `
            <div class="cfm-title">${title}</div>
            <div class="cfm-msg">${message}</div>
            ${actionsHtml}
          `;


        overlay.appendChild(panel);
        document.body.appendChild(overlay);

        const done = (val) => {
          document.removeEventListener('keydown', onKey);
          overlay.remove();
          resolve(val);
        };
        const onKey = (e) => {
          if (e.key === 'Escape') done(false);
          if (e.key === 'Enter') done(true);
        };

        const btnCancel = panel.querySelector('#cfmCancel');
        const btnOk = panel.querySelector('#cfmOk');

        btnCancel?.addEventListener('click', () => done(false));
        btnOk.addEventListener('click', () => done(true));
        overlay.addEventListener('click', (e) => { if (e.target === overlay) done(false); });
        document.addEventListener('keydown', onKey);

      });
    }

    function viewEscape(s) { return String(s ?? '').replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m])); }

    function viewBodyHtml(body) {
      if (!body) return '';
      if (Array.isArray(body)) {
        return `<ul>${body.map(li => `<li>${viewSafeInterpolate(String(li))}</li>`).join('')}</ul>`;
      }
      return `<p>${viewSafeInterpolate(String(body))}</p>`;
    }

    // --- helpers for {{var}} interpolation in Studio Preview ---
    function viewSafeInterpolate(str) {
      // supports {{var}}, {{var.label}}, and multi-select join
      return String(str).replace(/\{\{\s*([\w.]+)\s*\}\}/g, (_, path) => viewEscape(viewReadAnswerPath(path)));
    }

    function viewReadAnswerPath(path) {
      const [head, ...rest] = String(path).split('.');
      const base = (viewState && viewState.answers) ? viewState.answers[head] : undefined;
      return viewFormatAnswerPath(base, rest);
    }

    function viewFormatAnswerPath(base, props) {
      if (base == null) return '';
      if (Array.isArray(base)) {
        if (props && props.length) {
          return base.map(x => viewPickPath(x, props)).filter(v => v != null && v !== '').join(', ');
        }
        return base.map(x => (x && (x.label || x.value)) || String(x)).join(', ');
      }
      if (typeof base === 'object') {
        if (props && props.length) return viewPickPath(base, props) ?? '';
        return base.label || base.value || '';
      }
      return String(base);
    }

    function viewPickPath(obj, props) {
      let cur = obj;
      for (const p of props) { if (cur == null) return ''; cur = cur[p]; }
      return cur ?? '';
    }



    async function exportCurrentHTMLAsViewer() {
      // ensure latest header inputs are reflected
      // if (typeof syncHeaderInputsIntoSop === 'function') syncHeaderInputsIntoSop();

      //  btnPreview?.addEventListener('click', async () => {

      let loadSopFromSaved = false;
      if (isDirty) {
        if (savedSop) {
          const ok = await confirmDialog({
            title: 'Export last saved version?',
            message: 'You have unsaved changes. Export the last saved version and keep your current edits?',
            confirmText: 'Export Saved Version',
            cancelText: 'Cancel',
            // variant: 'neutral'
          });
          if (!ok) return;
          loadSopFromSaved = true;
          // return;
        }
      }

      // changeDataMode('view');
      // renderAll();
      // });


      const slot = document.getElementById('jsonEmbedded');
      if (!slot) { alert('Missing #jsonEmbedded'); return; }

      try {

        // embed current sop or replace json in existing html <script id="jsonEmbedded">/script>
        slot.textContent = JSON.stringify(loadSopFromSaved ? savedSop : sop, null, 2) + '\n';
        // switch to guide mode (removes editor-only UI)
        changeRunMode('guide');
        // download current html 
        downloadCurrentHTML((typeof slugify === 'function' ? slugify(sop?.title || 'sop-viewer') : 'sop-viewer') + '.html');
        // switch back to studio mode
        changeRunMode('studio');


      } catch (e) {
        alert('Failed to stringify SOP JSON: ' + (e?.message || e));
      }
    }

    function downloadCurrentHTML(filename) {
      // filename fallback
      const title = (document.title || 'page').toString();
      const slug = title.toLowerCase().replace(/[^\w]+/g, '-').replace(/^-+|-+$/g, '');
      const name = filename || (slug ? `${slug}.html` : 'page.html');

      // build <!DOCTYPE> safely
      const d = document.doctype;
      const doctype = d
        ? `<!DOCTYPE ${d.name}${d.publicId ? ` PUBLIC "${d.publicId}"` : ''}${d.systemId ? ` "${d.systemId}"` : ''}>`
        : '<!DOCTYPE html>';

      // serialize current DOM "as is"
      const html = `${doctype}\n${document.documentElement.outerHTML}`;

      // download
      const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 300);
    }

    // this is useless, i am not gonna use it, it just only one time will be called by browser console only if needed
    /**
 * Add step-level "next" pointers within each starter (no cross-starter links).
 * - Preserves any existing step.next
 * - Adds step.next to any step missing it (points to the next step's id)
 * - Never sets next on the final step of a starter (removes it if present)
 * - Never adds next to steps of type "end"
 */
    function addNextPointers(sop) {
      const clone = (obj) =>
      (typeof structuredClone === "function"
        ? structuredClone(obj)
        : JSON.parse(JSON.stringify(obj)));

      const out = clone(sop);
      if (!out || !Array.isArray(out.starters)) return out;

      out.starters.forEach((starter) => {
        const steps = Array.isArray(starter.steps) ? starter.steps : [];
        for (let i = 0; i < steps.length; i++) {
          const step = steps[i];

          // Last step: ensure no "next"
          if (i === steps.length - 1) {
            if (step && Object.prototype.hasOwnProperty.call(step, "next")) {
              delete step.next;
            }
            continue;
          }

          // For non-last steps: add "next" only if missing and not an "end" step
          if (
            step &&
            step.type !== "end" &&
            !Object.prototype.hasOwnProperty.call(step, "next")
          ) {
            const nextId = steps[i + 1] && steps[i + 1].id;
            if (nextId) step.next = nextId;
          }
        }
      });

      return out;
    }




    async function handleImportSop() {
      // 1) pick a file
      const file = await pickFile('.html,.htm');
      if (!file) return;

      // 2) read & parse
      let text = await file.text();

      // unescape if entity-escaped html
      if (/&lt;html\b/i.test(text) && !/<html\b/i.test(text)) {
        text = text
          .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"').replace(/&#39;/g, "'")
          .replace(/&amp;/g, '&');
      }

      const doc = new DOMParser().parseFromString(text, 'text/html');
      let jsonText = '';

      // prefer your embedded viewer slot
      const slotPlain = doc.querySelector('script#jsonEmbedded');
      if (slotPlain && slotPlain.textContent.trim()) jsonText = slotPlain.textContent.trim();

      // fallback: default-sop JSON
      if (!jsonText) {
        const slotDefault = doc.querySelector('script#default-sop[type="application/json"]');
        if (slotDefault && slotDefault.textContent.trim()) jsonText = slotDefault.textContent.trim();
      }

      // fallback: any JSON script that looks like a SOP
      if (!jsonText) {
        const anyJson = Array.from(doc.querySelectorAll('script[type="application/json"]'))
          .find(s => /\bstarters\b/.test(s.textContent || ''));
        if (anyJson) jsonText = anyJson.textContent.trim();
      }

      let parsed;
      try {
        parsed = JSON.parse(jsonText);
        if (!parsed || !Array.isArray(parsed.starters)) throw new Error('Missing starters[]');
      } catch (err) {
        alert('Could not import this file.\n\n' + (err?.message || 'Invalid or missing SOP JSON.'));
        return;
      }

      // 3) confirm
      const ok = await confirmDialog({
        title: 'Import SOP?',
        message: `Replace the current SOP with ‚Äú${file.name}‚Äù?`,
        confirmText: 'Import',
        cancelText: 'Cancel',
        variant: 'subtleDanger' // calm but distinct
      });
      if (!ok) return;

      // 4) apply, save, refresh UI
      sop = parsed;
      // console.log('Before SOP Position set', JSON.stringify(sop.starters[0].steps, null, 2));
      ensureSop();
      // console.log('After SOP Position set', JSON.stringify(sop.starters[0].steps, null, 2));
      viewState.starterIdx = 0;
      viewState.selectedStepId = sop.starters[0]?.steps?.[0]?.id || null;
      setDirty(true);
      const saved = await performSave();   // persists + updates savedSop
      if (!saved) return;

      // renderAll();
      renderViewAndEditLanding();
      // renderStarters();
      changeScreen('landing');
      changeDataMode('edit');
      if (typeof updateSaveBtn === 'function') updateSaveBtn();
    }

    // tiny file picker (no permanent DOM needed)
    function pickFile(accept = '') {
      return new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        if (accept) input.accept = accept;
        input.addEventListener('change', () => resolve(input.files?.[0] || null), { once: true });
        input.click();
        // cleanup next tick
        setTimeout(() => input.remove(), 0);
      });
    }

    function setTheme(mode) {
      document.documentElement.setAttribute('data-theme', mode);
      localStorage.setItem('theme', mode);
      // if (btn) btn.textContent = (mode === 'dark') ? 'üåû Light' : 'üåô Dark';
    }


    async function createNewSop() {
      const ok = await confirmDialog({
        title: 'New SOP?',
        message: 'This will delete the saved SOP in this browser and start a brand-new one.',
        confirmText: 'Proceed',
        cancelText: 'Cancel',
        variant: 'subtleDanger',
      });
      if (!ok) return;

      try { await idbDel('opsPathDB', 'sops', 'current'); } catch (e) { /* ignore */ }

      // fresh model + clean state
      sop = makeBlankSOP();
      ensureSopPositions();
      savedSop = structuredClone(sop);
      isDirty = true;
      performSave();
      isDirty = false;
      // formDirty = false;

      // reset pointers
      viewState.starterIdx = 0;
      viewState.selectedStepId = sop.starters[0]?.steps?.[0]?.id || null;

      // show edit landing for the new SOP
      changeDataMode('edit');
      changeScreen('landing');
      renderViewAndEditLanding();
      updateSaveBtn?.();
    }

    function openSettingsMenu(anchorBtn) {
      // prevent duplicates
      if (document.getElementById('settingsOverlay')) return;

      // overlay (click outside to close)
      const overlay = document.createElement('div');
      overlay.id = 'settingsOverlay';
      overlay.className = 'settings-overlay';

      // panel
      const panel = document.createElement('div');
      panel.className = 'settings-panel';

      // current theme from DOM
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
      const options = [
        { label: 'New SOP', action: 'new-sop', attrs: { 'data-hide': 'guide' } },
        { label: 'Import', action: 'import', attrs: { 'data-hide': 'guide' } },
        { label: 'Export', action: 'export', attrs: { 'data-hide': 'guide' } },
        { label: (currentTheme === 'dark') ? 'üåû Light' : 'üåô Dark', action: 'theme' },
      ];

      // build items
      panel.innerHTML = options.map(o => {
        const base = { 'data-action': o.action, ...(o.attrs || {}) }; // ensure data-action exists
        const attrs = Object.entries(base).map(([k, v]) => {
          if (v === true) return ` ${k}`;                 // boolean attribute
          if (v === false || v == null) return '';        // skip
          return ` ${k}="${String(v).replace(/"/g, '&quot;')}"`;
        }).join('');
        return `<button class="settings-item"${attrs}>${o.label}</button>`;
      }).join('');

      // place panel near the anchor button
      document.body.appendChild(overlay);
      document.body.appendChild(panel);
      const rect = anchorBtn.getBoundingClientRect();
      const top = rect.bottom + 6 + window.scrollY;
      const left = Math.min(
        rect.left + window.scrollX,
        window.scrollX + document.documentElement.clientWidth - panel.offsetWidth - 12
      );
      panel.style.top = `${top}px`;
      panel.style.left = `${left}px`;

      // handlers
      const onItemClick = async (e) => {
        const btn = e.target.closest('.settings-item');
        if (!btn) return;
        const action = btn.getAttribute('data-action');
        if (action == "new-sop") {
          createNewSop();
        } else if (action == "import") {
          // importHTML();
          await handleImportSop();
        } else if (action == "export") {
          cleanup();
          exportCurrentHTMLAsViewer();

        } else if (action == "theme") {

          const nextTheme = (currentTheme === 'light') ? 'dark' : 'light';
          setTheme(nextTheme);
          // toggleTheme();

        }

        cleanup();
      };
      const onOutside = (e) => { if (e.target === overlay) cleanup(); };
      const onEsc = (e) => { if (e.key === 'Escape') cleanup(); };

      panel.addEventListener('click', onItemClick);
      overlay.addEventListener('click', onOutside);
      document.addEventListener('keydown', onEsc);

      function cleanup() {
        panel.removeEventListener('click', onItemClick);
        overlay.removeEventListener('click', onOutside);
        document.removeEventListener('keydown', onEsc);
        panel.remove();
        overlay.remove();
      }
    }

    // Wire it
    // In wireGlobal(), add:
    document.getElementById('settingsBtn')?.addEventListener('click', (e) => {
      openSettingsMenu(e.currentTarget);
    });



    function countReachable(starter) {
      const steps = starter?.steps || [];
      if (!steps.length) return 0;

      const byId = new Map(steps.map((s, i) => [s.id, i]));

      function outgoing(s, i) {
        const out = new Set();

        if (s.type === 'instruction' || s.type === 'input') {
          // explicit next OR fallback to the next step in the array
          let n = s.next;
          if (!n && i < steps.length - 1) n = steps[i + 1].id;
          if (n && byId.has(n)) out.add(n);
        }
        else if (s.type === 'select') {
          const mode = (s.mode === 'multi') ? 'multi' : 'single';

          // option-level next
          if (Array.isArray(s.options)) {
            for (const o of s.options) {
              let n = o.next;
              // for single-select options, fallback to step.next or linear next
              if (!n && mode === 'single') {
                n = s.next || (i < steps.length - 1 ? steps[i + 1].id : undefined);
              }
              if (n && byId.has(n)) out.add(n);
            }
          }

          // step-level next (used esp. for multi-select after)
          if (s.next && byId.has(s.next)) out.add(s.next);

          // multi-select fallback to linear next when no step.next provided
          if (mode === 'multi' && !s.next && i < steps.length - 1) {
            const n = steps[i + 1].id;
            if (byId.has(n)) out.add(n);
          }
        }

        return Array.from(out);
      }

      const visited = new Set();
      const stack = [steps[0].id];
      while (stack.length) {
        const id = stack.pop();
        if (visited.has(id)) continue;
        visited.add(id);

        const i = byId.get(id);
        if (i == null) continue;

        for (const nid of outgoing(steps[i], i)) {
          if (!visited.has(nid)) stack.push(nid);
        }
      }
      return visited.size;
    }

    function renderViewAndEditLanding() {
      const landing = document.getElementById('vwLanding');   // preview landing host
      if (!landing) return;

      const title = String(sop?.title || 'New SOP Library');
      const desc = String(sop?.description || 'Describe your library');
      const starters = Array.isArray(sop?.starters) ? sop.starters : [];

      // Build landing (viewer-like)
      landing.innerHTML = `
      <div class="wrap">
      <!-- VIEW block -->
      <div id="vwHeader" style="margin:16px 0 14px">
        <h1 style="margin:8px 0 6px">${escapeHtml(title)}</h1>
        <p class="small" style="margin:0 0 12px">${escapeHtml(desc)}</p>
      </div>

      <!-- EDIT block -->
      <div id="vwHeaderEditor">
        <input id="vwTitleInput" type="text" value="${escapeAttr(title)}"
          style="width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:var(--card);color:var(--fg);font-size:20px;" />
        <input id="vwDescInput" type="text" value="${escapeAttr(desc)}"
          style="width:100%;padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:var(--card);color:var(--fg);font-size:14px;margin-top:8px;" />
        <div style="display:flex;gap:8px;margin-top:10px">
        </div>
      </div>
    </div>

    <div class="vw-grid">
      ${starters.map((st, idx) => `
        <div class="starter-dual" data-idx="${idx}">
          <!-- read-only card (shown in view mode) -->
          <button class="vw-card" data-idx="${idx}" onclick="enterViewOrEditStarter(${idx})">
            <h3>${escapeHtml(st.label)}</h3>
            ${st.summary ? `<p>${escapeHtml(st.summary)}</p>` : ``}
            <div class="vw-pill">
              <span>Steps</span>
              <strong>${(typeof countReachable === 'function' ? countReachable(st) : (st.steps || []).length)}</strong>
            </div>
          </button>

          <!-- editable card (shown in edit mode) -->
          <div class="vw-card vw-card--edit" data-action="starter-edit" data-idx="${idx}">
            <input class="st-label" type="text"
                  placeholder="Label"
                  value="${escapeAttr(st.label)}" />
            <input class="st-summary" type="text"
                  placeholder="Summary"
                  value="${escapeAttr(st.summary || '')}" />
            <div class="vw-card__meta">
              <div class="vw-pill">
                <span>Steps</span>
                <strong>${(typeof countReachable === 'function' ? countReachable(st) : (st.steps || []).length)}</strong>
              </div>
            </div>
            <div class="vw-card__actions" >
              <button class="cfm-btn cfm-btn--subtleDanger" data-action="starter-delete">Delete</button>
            </div>
          </div>
        </div>
      `).join('')}



      <!-- ‚Äú+ New‚Äù card -->
      <button type="button" class="vw-card vw-card--add" data-action="create-starter" >
        <span class="vw-card--add-icon" >+</span>
        <h4>Create new starter</h4>
      </button>
    </div>



  </div>
`;
    }
    function isEditMode() { return document.documentElement.getAttribute('data-mode') === 'edit'; }

    function enterViewOrEditStarter(idx) {
      // if (isEditMode()) {
      //   enterEditStarter(idx);
      // }
      // else {
      //   enterViewStarter(idx);
      // }

      resetStarterValues(idx);

      // viewState.starterIdx = idx;
      // viewState.selectedStepId = sop.starters[idx]?.steps?.[0]?.id || null;
      changeScreen('starter');
      const st = sop.starters[idx];
      document.getElementById('vwStarterTitle').textContent = st?.label || 'Starter';
      // resetGraphZoom();
      // ensuremandatory must came before ensurepositions to make starters has starter step

      // renderAll();


      renderAll();

    }

    // Run data normalization (ids/types/nexts/startId) for every starter.
    // Returns true if anything changed.
    function ensureSopMandatory() {
      console.log('ensureSopMandatory called');
      if (!sop || !Array.isArray(sop.starters)) return false;
      let changed = false;

      for (const st of sop.starters) {
        if (!st || !Array.isArray(st.steps)) continue;

        // Legacy field: prefer startId; fall back to rootStepId if present
        if (typeof st.startId !== 'string' && typeof st.rootStepId === 'string') {
          st.startId = st.rootStepId;
          changed = true;
        }

        if (ensureMandatory(st)) changed = true;
      }
      // console.log('Starter after ensuring mandatory: ', JSON.stringify(sop.starters[0], null, 2));

      return changed;
    }

    // Ensure positions for every starter (assign only when missing).
    // Returns true if anything changed.
    function ensureSopPositions() {
      if (!sop || !Array.isArray(sop.starters)) return false;
      let changed = false;

      for (const st of sop.starters) {
        if (!st || !Array.isArray(st.steps)) continue;
        if (ensurePositions(st)) changed = true;
      }
      return changed;
    }

    // Convenience wrapper: run both; marks dirty if anything changed.
    function ensureSop() {
      const changed = !!(ensureSopMandatory() | ensureSopPositions());
      // if (changed && typeof setDirty === 'function') setDirty(true);
      return changed;
    }


    // Ensure every step has a pos; keep existing pos untouched.
    // Vertical-first grid: fills rows top‚Üíbottom, then moves to next column.

    // function ensurePositions(starter) {
    //   if (!starter) return false;
    //   const steps = starter.steps || [];
    //   if (!steps.length) return false;

    //   const x0 = 200, y0 = 60;    // start origin
    //   const colWidth = 220;       // horizontal gap
    //   const rowGap = 140;         // vertical gap

    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const hasPos = s => s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);

    //   // pick the start from starter.startId if valid; else first step
    //   const start = (typeof starter.startId === 'string' && byId[starter.startId])
    //     ? byId[starter.startId]
    //     : steps[0];

    //   console.log(`start`, start);

    //   let changed = false;
    //   const visited = new Set();

    //   // 1) Main chain: follow .next from START downward (only assigns if missing)
    //   let cur = start;
    //   let y = y0;
    //   const x = x0;
    //   const guardMax = steps.length + 5;

    //   for (let guard = 0; cur && guard < guardMax; guard++) {
    //     if (!hasPos(cur)) { cur.pos = { x, y }; changed = true; }
    //     visited.add(cur.id);

    //     const nxt = (cur.next && byId[cur.next]) ? byId[cur.next] : null;
    //     if (!nxt || visited.has(nxt.id)) break; // end/missing/cycle
    //     y += rowGap;
    //     cur = nxt;
    //   }

    //   // 2) Everything not on the main chain ‚Üí top row to the right
    //   let col = 1; // start at next column so we don't overlap the start
    //   for (const s of steps) {
    //     if (visited.has(s.id)) continue;
    //     if (!hasPos(s)) {
    //       s.pos = { x: x0 + colWidth * col, y: y0 };
    //       changed = true;
    //     }
    //     visited.add(s.id);
    //     col++;
    //   }

    //   console.log(`visited`, visited);

    //   return changed;
    // }



    // function ensurePositions(starter) {
    //   if (!starter) return false;
    //   const steps = starter.steps || [];
    //   if (!steps.length) return false;
    //   // debugger;

    //   const x0 = 200, y0 = 60;    // origin
    //   const colWidth = 220;       // horizontal gap
    //   const rowGap = 140;         // vertical gap

    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const hasPos = s => s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);

    //   // pick explicit start (supports legacy rootStepId), else first step
    //   const startId =
    //     (typeof starter.startId === 'string' && byId[starter.startId]) ? starter.startId :
    //       (typeof starter.rootStepId === 'string' && byId[starter.rootStepId]) ? starter.rootStepId :
    //         steps[0].id;

    //   // compute in-degree (count step.next and select option.next)
    //   const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
    //   for (const s of steps) {
    //     if (s.next && byId[s.next]) indeg[s.next] += 1;
    //     if (s.type === 'select') {
    //       for (const o of (s.options || [])) {
    //         if (o && o.next && byId[o.next]) indeg[o.next] += 1;
    //       }
    //     }
    //   }

    //   // roots: the chosen start first, then other nodes with in-degree 0 (order preserved)
    //   const roots = [];
    //   if (byId[startId]) roots.push(byId[startId]);
    //   for (const s of steps) {
    //     if (s.id !== startId && indeg[s.id] === 0) roots.push(s);
    //   }

    //   let changed = false;
    //   const visited = new Set();
    //   let col = 0;

    //   // lay a single .next chain vertically in a column (don‚Äôt overwrite pos)
    //   const layChain = (node) => {
    //     let cur = node;
    //     let row = 0;
    //     const guardMax = steps.length + 5;
    //     for (let g = 0; cur && g < guardMax; g++) {
    //       if (!visited.has(cur.id)) {
    //         if (!hasPos(cur)) {
    //           cur.pos = { x: x0 + colWidth * col, y: y0 + rowGap * row };
    //           changed = true;
    //         }
    //         visited.add(cur.id);
    //         row++;
    //       }
    //       const nxtId = (cur.next && byId[cur.next]) ? cur.next : null;
    //       if (!nxtId || visited.has(nxtId)) break;
    //       cur = byId[nxtId];
    //     }
    //   };

    //   // 1) place each root‚Äôs chain in its own column
    //   for (const r of roots) {
    //     if (visited.has(r.id)) continue;
    //     layChain(r);
    //     col++;
    //   }

    //   // 2) any leftover nodes (cycles/broken refs) ‚Üí top row to the right
    //   for (const s of steps) {
    //     if (visited.has(s.id)) continue;
    //     if (!hasPos(s)) {
    //       s.pos = { x: x0 + colWidth * col, y: y0 };
    //       changed = true;
    //     }
    //     visited.add(s.id);
    //     col++;
    //   }

    //   // normalize to startId for future saves (optional)
    //   if (starter.startId !== startId) {
    //     starter.startId = startId;
    //     changed = true;
    //   }

    //   return changed;
    // }

    // function ensurePositions(starter) {
    //   console.log('ensurePositions called');
    //   if (!starter) return false;
    //   const steps = starter.steps || [];
    //   if (!steps.length) return false;

    //   const x0 = 200, y0 = 60;    // origin
    //   const colWidth = 220;       // horizontal gap
    //   const rowGap = 140;         // vertical gap

    //   const byId = Object.fromEntries(steps.map(s => [s.id, s]));
    //   const hasPos = s => s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);

    //   // explicit start (supports legacy), else first step
    //   const startId =
    //     (typeof starter.startId === 'string' && byId[starter.startId]) ? starter.startId :
    //       (typeof starter.rootStepId === 'string' && byId[starter.rootStepId]) ? starter.rootStepId :
    //         steps[0].id;

    //   // in-degree (counts step.next and select option.next)
    //   const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
    //   for (const s of steps) {
    //     if (s.next && byId[s.next]) indeg[s.next] += 1;
    //     if (s.type === 'select') {
    //       for (const o of (s.options || [])) {
    //         if (o && o.next && byId[o.next]) indeg[o.next] += 1;
    //       }
    //     }
    //   }

    //   // roots: chosen start first, then other in-degree-0 nodes
    //   const roots = [];
    //   if (byId[startId]) roots.push(byId[startId]);
    //   for (const s of steps) if (s.id !== startId && indeg[s.id] === 0) roots.push(s);

    //   let changed = false;
    //   const visited = new Set();

    //   const place = (col, row, node) => {
    //     if (!hasPos(node)) {
    //       node.pos = { x: x0 + colWidth * col, y: y0 + rowGap * row };
    //       changed = true;
    //     }
    //     visited.add(node.id);
    //   };

    //   // Lay a chain with branching:
    //   // - primary child (first) continues downward in same column
    //   // - additional children start new columns to the right at (row+1)
    //   const layFrom = (startNode, baseCol, baseRow) => {
    //     let rightmost = baseCol;
    //     let node = startNode, col = baseCol, row = baseRow;
    //     const guardMax = steps.length * 3;
    //     const queue = [];

    //     for (let g = 0; node && g < guardMax; g++) {
    //       if (!visited.has(node.id)) place(col, row, node);

    //       // gather children
    //       const children = [];
    //       if (node.type === 'select') {
    //         for (const o of (node.options || [])) {
    //           if (o && o.next && byId[o.next]) children.push(byId[o.next]);
    //         }
    //       } else if (node.next && byId[node.next]) {
    //         children.push(byId[node.next]);
    //       }

    //       if (!children.length) break;

    //       // enqueue side branches (each to the right)
    //       for (let i = 1; i < children.length; i++) {
    //         const branchCol = col + i;
    //         rightmost = Math.max(rightmost, branchCol);
    //         queue.push({ node: children[i], col: branchCol, row: row + 1 });
    //       }

    //       // continue with primary child downward
    //       node = children[0];
    //       row += 1;
    //     }

    //     // process queued branches (breadth-first)
    //     while (queue.length) {
    //       const { node: seedNode, col: seedCol, row: seedRow } = queue.shift();
    //       if (visited.has(seedNode.id)) continue;
    //       rightmost = Math.max(rightmost, layFrom(seedNode, seedCol, seedRow));
    //     }

    //     return rightmost;
    //   };

    //   // 1) layout each root chain; keep track of rightmost used column
    //   let nextRootCol = 0;
    //   for (const r of roots) {
    //     if (visited.has(r.id)) continue;
    //     const right = layFrom(r, nextRootCol, 0);
    //     nextRootCol = right + 1;
    //   }

    //   // 2) leftover nodes (cycles/broken links) ‚Üí top row, continuing columns
    //   for (const s of steps) {
    //     if (visited.has(s.id)) continue;
    //     if (!hasPos(s)) {
    //       s.pos = { x: x0 + colWidth * nextRootCol, y: y0 };
    //       changed = true;
    //     }
    //     visited.add(s.id);
    //     nextRootCol++;
    //   }

    //   // normalize to startId for future saves
    //   if (starter.startId !== startId) {
    //     starter.startId = startId;
    //     changed = true;
    //   }

    //   return changed;
    // }


    function ensurePositions(starter) {
      if (!starter || !Array.isArray(starter.steps)) return false;
      const steps = starter.steps;
      if (!steps.length) return false;

      // NODES & EDGES (mirror layoutVertical)
      const nodes = steps.map(s => ({ id: s.id, pos: s.pos }));
      const edges = [];
      for (const s of steps) {
        if (s.next) edges.push({ from: s.id, to: s.next });
        if (s.type === 'select') {
          for (const o of (s.options || [])) if (o && o.next) edges.push({ from: s.id, to: o.next });
        }
      }

      if (!nodes.length) return false;

      // adjacency
      const adj = {};
      nodes.forEach(n => adj[n.id] = []);
      edges.forEach(e => { (adj[e.from] ||= []).push(e.to); });

      // depths from FIRST node (same as layoutVertical)
      const depth = {};
      const start = nodes[0].id;
      depth[start] = 0;

      // BFS
      const q = [start];
      while (q.length) {
        const u = q.shift();
        for (const v of adj[u] || []) {
          if (depth[v] == null) {
            depth[v] = (depth[u] || 0) + 1;
            q.push(v);
          }
        }
      }
      // unreached ‚Üí depth 0
      nodes.forEach(n => { if (depth[n.id] == null) depth[n.id] = 0; });

      // relax so every edge goes downward
      let changedDepth = true, guard = 0;
      while (changedDepth && guard < 50) {
        changedDepth = false; guard++;
        for (const e of edges) {
          const a = depth[e.from], b = depth[e.to];
          if (a != null && b != null && b <= a) {
            depth[e.to] = a + 1;
            changedDepth = true;
          }
        }
      }

      // rows & stable order within row
      const rows = {};
      nodes.forEach(n => {
        const d = depth[n.id] || 0;
        (rows[d] ||= []).push(n.id);
      });
      const colIndex = {};
      Object.keys(rows).sort((a, b) => a - b).forEach(d => {
        rows[d].forEach((id, i) => colIndex[id] = i);
      });

      // compute lane positions (same constants as layoutVertical)
      const colWidth = 200;    // horizontal spacing
      const rowGap = 140;     // vertical spacing
      const x0 = 200, y0 = 60; // origin

      // WRITE BACK positions only if missing
      let wroteAny = false;
      for (const n of nodes) {
        const s = steps.find(x => x.id === n.id);
        const has = s.pos && Number.isFinite(s.pos.x) && Number.isFinite(s.pos.y);
        if (!has) {
          const d = depth[n.id] || 0;
          const i = colIndex[n.id] || 0;
          s.pos = { x: x0 + i * colWidth, y: y0 + d * rowGap };
          wroteAny = true;
        }
      }

      if (wroteAny && typeof setDirty === 'function') setDirty(true);
      return wroteAny;
    }







    // Normalize & validate a starter in place.
    // - Converts legacy `end` steps ‚Üí `instruction` (implicit ends = no `next`)
    // - Ensures a single valid `startId` on the starter (defaults to a root or first step)
    // - Ensures step ids are unique
    // - Cleans invalid/empty `next` refs
    // - Normalizes select steps (options array, unique option values)
    // Returns true if it changed anything.
    function ensureMandatory(starter) {
      if (!starter || !Array.isArray(starter.steps)) return false;
      const steps = starter.steps;
      if (!steps.length) return false;

      let changed = false;

      // 0) Ensure starter label exists: "starter <idx>"
      if (typeof starter.label !== 'string' || !starter.label.trim()) {
        const idx = (Array.isArray(sop?.starters) ? sop.starters.indexOf(starter) : -1);
        const n = (idx >= 0 ? idx + 1 : 1);
        starter.label = 'starter ' + n; // as requested: "starter + idx"
        changed = true;
      }

      // 1) Make step ids unique (stable rename with suffixes when needed)
      // const seen = new Set();
      // for (const s of steps) {
      //   if (typeof s.id !== 'string' || !s.id.trim()) {
      //     s.id = 'step'; changed = true;
      //   }
      //   let base = s.id.trim();
      //   let out = base, i = 1;
      //   while (seen.has(out)) { out = base + '_' + (++i); }
      //   if (out !== s.id) { s.id = out; changed = true; }
      //   seen.add(out);
      // }

      // 2) Legacy type: 'end' ‚Üí 'instruction' (implicit end = no next)
      // for (const s of steps) {
      //   if (s.type !== 'instruction' || s.type !== 'input' || s.type !== 'select') {
      //     s.type = 'instruction'; changed = true;
      //   }
      // }

      // 2) Normalize type and coerce unknowns ‚Üí 'instruction'
      for (const s of steps) {
        let t = (s.type ?? 'instruction');
        if (typeof t !== 'string') t = 'instruction';
        t = t.trim().toLowerCase();

        if (t !== 'instruction' && t !== 'input' && t !== 'select') {
          if (s.type !== 'instruction') { s.type = 'instruction'; changed = true; }
        } else if (s.type !== t) {
          s.type = t; // normalize casing
          changed = true;
        }
      }


      // 3) Build byId and clean `next` (empty or missing target -> remove)
      const byId = Object.fromEntries(steps.map(s => [s.id, s]));
      for (const s of steps) {
        if (s.next == null || s.next === '') continue;
        if (!byId[s.next]) { delete s.next; changed = true; }
      }

      // 4) Normalize select steps
      for (const s of steps) {
        if (s.type !== 'select') continue;
        if (!Array.isArray(s.options)) { s.options = []; changed = true; }
        // Ensure unique option values and non-empty labels
        const valSeen = new Set();
        for (let i = 0; i < s.options.length; i++) {
          const o = s.options[i] || {};
          if (typeof o.value !== 'string' || !o.value) { o.value = 'opt' + (i + 1); changed = true; }
          if (typeof o.label !== 'string') { o.label = String(o.value); changed = true; }
          // Dedup option values by suffixing
          let v = o.value, k = 1;
          while (valSeen.has(v)) { v = o.value + '_' + (++k); }
          if (v !== o.value) { o.value = v; changed = true; }
          valSeen.add(o.value);
          // Clean empty next on options
          if (o.next === '') { delete o.next; changed = true; }
          s.options[i] = o;
        }
        // Mode defaults
        if (s.mode !== 'multi' && s.mode !== 'single') { s.mode = 'single'; changed = true; }
      }

      // 5) Ensure single valid startId at starter level
      //    Prefer a node with in-degree 0; among them prefer one that has an outgoing edge; else first.
      // console.log('hello');
      // if (!(typeof starter.startId === 'string' && byId[starter.startId])) {

      //   const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
      //   for (const s of steps) {
      //     if (s.next && byId[s.next]) indeg[s.next] += 1;
      //     if (s.type === 'select') {
      //       for (const o of (s.options || [])) {
      //         if (o && o.next && byId[o.next]) indeg[o.next] += 1;
      //       }
      //     }
      //   }

      //   // roots: in-degree = 0, kept in original order
      //   const roots = steps.filter(s => indeg[s.id] === 0);

      //   // helper: does this step have any outgoing edge?
      //   const hasOut = (s) =>
      //     !!s.next ||
      //     (s.type === 'select' && (s.options || []).some(o => o && o.next));

      //   let candidate = steps[0]; // fallback
      //   if (roots.length) {
      //     const prefer = roots.find(hasOut);
      //     candidate = prefer || roots[0];
      //   }

      //   if (typeof starter.startId !== 'string' || !byId[starter.startId]) {
      //     starter.startId = candidate.id;
      //     changed = true;
      //   }


      // }


      // if (!(typeof starter.startId === 'string' && byId[starter.startId])) {
      // starter.startId = candidate.id;

      const startId = getStarterStartId(starter);
      if (startId && starter.startId !== startId) {
        starter.startId = startId;
        changed = true;
      }
      // }
      return changed;
    }

    // Decide the best start step id for a single starter and set it.
    // Rules:
    // 1) Prefer roots (in-degree 0) that have an outgoing edge (step.next or select option.next).
    // 2) If multiple, take the first by steps order.
    // 3) Else fall back to any root.
    // 4) Else fall back to the first step.
    function getStarterStartId(starter) {
      if (!starter || !Array.isArray(starter.steps) || starter.steps.length === 0) return null;

      const steps = starter.steps;
      const byId = Object.fromEntries(steps.map(s => [s.id, s]));

      // in-degree (count step.next and select option.next)
      const indeg = Object.fromEntries(steps.map(s => [s.id, 0]));
      for (const s of steps) {
        if (s.next && byId[s.next]) indeg[s.next] += 1;
        if (s.type === 'select') {
          for (const o of (s.options || [])) {
            if (o && o.next && byId[o.next]) indeg[o.next] += 1;
          }
        }
      }

      const hasOut = (s) => !!s.next || (s.type === 'select' && (s.options || []).some(o => o && o.next));

      const rootWithOut = steps.filter(s => indeg[s.id] === 0 && hasOut(s));
      const anyRoot = steps.filter(s => indeg[s.id] === 0);

      const candidate =
        rootWithOut[0] ||   // best: root that leads somewhere
        anyRoot[0] ||     // otherwise: any root
        steps.find(hasOut) || // otherwise: any node that leads somewhere
        steps[0];           // absolute fallback

      const startId = candidate?.id || null;

      return startId;
    }


    // Wire live editing of title/description (landing, edit mode)
    (function wireTitleDesc() {
      if (window.titleDescWired) return; window.titleDescWired = true;

      document.addEventListener('input', (e) => {
        if (!isEditMode()) return;
        const t = e.target;
        if (t.id !== 'vwTitleInput' && t.id !== 'vwDescInput') return;

        const v = (t.value || '').trim();

        if (t.id === 'vwTitleInput') {
          if ((sop.title || '') !== v) { sop.title = v; setDirty?.(true); }
          return;
        }
        if (t.id === 'vwDescInput') {
          if ((sop.description || '') !== v) { sop.description = v; setDirty?.(true); }
          return;
        }
      }, true);
    })();



    // Inline edit for starter cards (landing, edit mode)
    let starterCardWired = false;
    (function wireStarterCards() {
      if (starterCardWired) return; starterCardWired = true;

      // Update label/summary live
      document.addEventListener('input', (e) => {

        if (!isEditMode()) return;
        const inp = e.target;
        if (!inp.classList?.contains('st-label') && !inp.classList?.contains('st-summary')) return;
        const card = inp.closest('.vw-card--edit');
        if (!card) return;
        const idx = parseInt(card.dataset.idx, 10);
        const st = sop.starters[idx]; if (!st) return;

        if (inp.classList.contains('st-label')) st.label = inp.value;
        if (inp.classList.contains('st-summary')) st.summary = inp.value;
        setDirty?.(true);
      }, true);

      // Edit / Delete buttons
      // document.addEventListener('click', (e) => {
      //   const btn = e.target.closest('[data-action="starter-edit"],[data-action="starter-delete"]');
      //   if (!btn) return;
      //   const idx = parseInt(btn.dataset.idx, 10);


      document.addEventListener('click', async (e) => {
        if (!isEditMode()) return;
        // delete button inside the card
        const del = e.target.closest('[data-action="starter-delete"]');
        if (del) {
          const card = del.closest('.vw-card[data-idx]');
          if (!card) return;
          const idx = parseInt(card.dataset.idx, 10);
          const label = sop.starters[idx]?.label || `Starter ${idx + 1}`;

          let haveOneStarterOnly = false;
          if (sop?.starters?.length === 1) {
            haveOneStarterOnly = await confirmDialog({
              // title: '??',
              title: 'You must have at least one starter.',
              confirmText: 'Okay',
              // cancelText: 'Cancel',
              variant: 'neutral',
              one: true
            });

            // return false;
          }
          if (haveOneStarterOnly) return;



          const ok = await confirmDialog({
            title: `Delete ‚Äú${label}‚Äù?`,
            message: `Are you sure you want to delete ‚Äú${label}‚Äù and  all its steps? This action cannot be undone.`,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            variant: 'subtleDanger'   // ‚Üê small ‚Äúdanger‚Äù cue, not aggressive
          });

          if (!ok) return;

          deleteStarter(idx);

          setDirty?.(true);
          renderViewAndEditLanding();


          return;
        }

        if (e.target.closest('input, textarea, select, [contenteditable="true"]')) return;


        // open on any click inside the card
        const card = e.target.closest('.vw-card[data-idx]');
        if (!card) return;
        const idx = parseInt(card.dataset.idx, 10);
        // check if edit mode
        enterViewOrEditStarter(idx);
      });

    })();


    // function enterEditStarter(idx) {
    //   resetStarterValues();
    //   resetGraphZoom();
    //   viewState.starterIdx = idx;
    //   viewState.selectedStepId = sop.starters[idx]?.steps?.[0]?.id || null;;
    //   changeScreen('starter');
    //   renderAll();



    //   // optional crumbs
    //   // const crumbs = document.getElementById('breadcrumbs');
    //   // if (crumbs) crumbs.textContent = `Home ¬∑ ${st.label || `Starter ${idx + 1}`} (Edit)`;
    // }

    // function resetStarterValues(idx) {
    //   viewState.starterIdx = 0;
    //   viewState.stepIdx = 0;
    //   viewState.answers = {};
    // }

    function getStepIndexById(steps, id) {
      if (!Array.isArray(steps) || steps.length === 0) return 0;
      if (typeof id !== 'string') return 0;
      const i = steps.findIndex(s => s && s.id === id);
      return (i >= 0) ? i : 0;
    }

    // Reset viewState for a given starter index (or 0 if invalid).
    // Sets stepIdx to the starter's startId (or 0 if invalid).
    function resetStarterValues(starterIdx) {
      const starters = sop?.starters || [];
      const si = (Number.isInteger(starterIdx) && starterIdx >= 0 && starterIdx < starters.length) ? starterIdx : 0;

      viewState.starterIdx = si;
      viewState.answers = {};

      const st = starters[si];
      const steps = st?.steps || [];
      const startId = (typeof st?.startId === 'string') ? st.startId : steps[0]?.id;
      // const startId = 2;

      viewState.stepIdx = getStepIndexById(steps, startId);
      viewState.selectedStepId = startId || null;
    }





    // function enterViewStarter(idx) {
    //   resetStarterValues();
    //   viewState.starterIdx = idx;
    //   viewState.selectedStepId = sop.starters[idx]?.steps?.[0]?.id || null;
    //   changeScreen('starter');

    //   const st = sop.starters[idx];
    //   document.getElementById('vwStarterTitle').textContent = st?.label || 'Starter';
    //   resetGraphZoom();
    //   renderAll();

    // }

    // Creates a new starter, re-renders grid (optional), and returns its index.
    function createNewStarter() {
      // const starterIdx = 
      // viewState.selectedStepId = starterIdx;
      const idx = sop.starters.length;

      const newStarter = {
        id: 'starter_' + (idx + 1),
        label: 'Starter ' + (idx + 1),
        steps: []
      };

      const step1 = makeStep('instruction', newStarter);
      step1.id = "welcome_step";
      step1.label = "Welcome";
      newStarter.steps.push(step1);

      const step2 = makeStep('instruction', newStarter);
      step2.id = "end_step";
      step2.label = "The End";
      newStarter.steps.push(step2);

      step1.next = step2.id;

      sop.starters.push(newStarter);
      ensureMandatory(newStarter);
      ensurePositions(newStarter);

      console.log(`newStarter`, newStarter);
      return sop.starters.length - 1;
    }

    function deleteStarter(idx) {
      const starters = (sop && Array.isArray(sop.starters)) ? sop.starters : null;
      if (!starters || idx == null || idx < 0 || idx >= starters.length) return;



      // remove
      starters.splice(idx, 1);

      // fix selection/index if needed
      if (typeof viewState === 'object') {
        const n = starters.length;
        if (typeof viewState.currentStarterIdx === 'number') {
          if (viewState.currentStarterIdx === idx) {
            viewState.currentStarterIdx = Math.min(idx, n - 1);
          } else if (viewState.currentStarterIdx > idx) {
            viewState.currentStarterIdx -= 1;
          }
        }

        // leave edit mode if it pointed to a deleted starter
        // if (viewState.mode === 'edit' && (viewState.currentStarterIdx < 0 || viewState.currentStarterIdx >= n)) {
        //   viewState.mode = 'home';
        // }
      }

      // mark dirty and re-render
      // if (typeof setDirty === 'function') setDirty(true);

      // refresh UI (call whatever you have; fallbacks included)
      // if (typeof renderLibrary === 'function') renderLibrary();
      // else if (typeof renderHome === 'function') renderHome();
    }



    document.addEventListener('click', onCreateStarterClick);

    function onCreateStarterClick(e) {
      const add = e.target.closest('[data-action="create-starter"], .vw-card--add');
      if (!add) return;
      openNewStarterDialog();
    }

    function openNewStarterDialog() {
      const modal = document.getElementById('dlgNewStarter');
      if (!modal) return; // fail-safe

      const labelI = document.getElementById('nsLabel');
      const summaryI = document.getElementById('nsSummary');
      const btnCreate = document.getElementById('nsCreate');
      const btnCancel = document.getElementById('nsCancel');
      const labelErr = document.getElementById('nsLabelErr');

      // seed defaults + reset errors
      labelI.value = `Starter ${sop.starters.length + 1}`;
      summaryI.value = '';
      labelI.classList.remove('is-invalid');
      if (labelErr) labelErr.textContent = '';

      // helpers
      const clearInvalid = () => {
        if (labelI.value.trim()) {
          labelI.classList.remove('is-invalid');
          if (labelErr) labelErr.textContent = '';
        }
      };
      const onOverlay = (ev) => { if (ev.target === modal) cleanup(); };
      const onCancel = () => cleanup();
      const onEsc = (ev) => { if (ev.key === 'Escape') cleanup(); };

      const onCreate = () => {
        const label = (labelI.value || '').trim();
        if (!label) {
          labelI.classList.add('is-invalid');
          if (labelErr) labelErr.textContent = 'Label is required';
          labelI.focus();
          return;
        }
        const exists = sop.starters.some(s =>
          (s && typeof s.label === 'string' ? s.label.trim().toLowerCase() : '') === label.toLowerCase()
        );
        if (exists) {
          labelI.classList.add('is-invalid');
          if (labelErr) labelErr.textContent = 'Label must be unique';
          labelI.focus();
          return;
        }

        const idx = createNewStarter(); // pushes new object, returns index
        const st = sop.starters[idx];
        st.label = label;
        st.summary = (summaryI.value || '').trim();

        cleanup();

        // if (typeof renderStarters === 'function')
        if (viewState) viewState.starterIdx = idx;
        setDirty(true);
        enterViewOrEditStarter(idx);
      };

      function cleanup() {
        modal.classList.add('hidden');
        btnCreate.removeEventListener('click', onCreate);
        btnCancel.removeEventListener('click', onCancel);
        modal.removeEventListener('click', onOverlay);
        document.removeEventListener('keydown', onEsc);
        labelI.removeEventListener('input', clearInvalid);
      }

      // open
      modal.classList.remove('hidden');
      setTimeout(() => labelI.focus(), 0);

      // one-time listeners per open
      labelI.addEventListener('input', clearInvalid, { passive: true });
      btnCreate.addEventListener('click', onCreate);
      btnCancel.addEventListener('click', onCancel);
      modal.addEventListener('click', onOverlay);
      document.addEventListener('keydown', onEsc);
    }


    function setNextEnabled(enabled) {
      const n = document.getElementById('vwNext');
      if (n) n.disabled = !enabled;
    }

    // put this *after* setNextEnabled(...)
    function validateValueForStep(step, value) {
      if (step.required) {
        if (step.type === 'input') {
          if (!String(value || '').trim()) return { ok: false, msg: step.requiredMessage || 'This field is required' };
        } else if (step.type === 'select') {
          if (step.mode === 'multi') {
            if (!Array.isArray(value) || value.length === 0) return { ok: false, msg: step.requiredMessage || 'Select at least one' };
          } else {
            if (!value) return { ok: false, msg: step.requiredMessage || 'Please choose an option' };
          }
        }
      }
      if (step.type === 'input' && step.regex) {
        try {
          const re = new RegExp(step.regex);
          if (!re.test(String(value || ''))) return { ok: false, msg: step.error || 'Invalid format' };
        } catch (e) { /* ignore invalid regex */ }
      }
      if (step.type === 'select' && step.mode === 'multi') {
        const count = Array.isArray(value) ? value.length : 0;
        if (typeof step.min === 'number' && count < step.min) return { ok: false, msg: step.minMessage || `Select at least ${step.min}` };
        if (typeof step.max === 'number' && count > step.max) return { ok: false, msg: step.maxMessage || `Select at most ${step.max}` };
      }
      return { ok: true, msg: '' };
    }

    // has no next step implicitly (no indicator)
    const isEndStep = (s) => !s?.next;



    function renderViewStep() {
      // console.trace('called here'); // shows who called foo (and the chain)

      const st = sop.starters[viewState.starterIdx];
      const steps = st.steps || [];
      let i = viewState.stepIdx;
      const stepCnt = steps.length;

      document.getElementById('vwProgress').textContent = `Step ${Math.min(i + 1, stepCnt)} of ${stepCnt}`;
      const box = document.getElementById('vwStep');
      box.innerHTML = '';
      const step = steps[i];
      if (!step) { setNextEnabled(false); return; }
      // const isDoneStep = step.type === 'end';

      let node;
      if (step.type === 'instruction') {
        node = document.createElement('div');
        node.innerHTML = `
      ${step.title ? `<h3>${viewEscape(step.title)}</h3>` : ''}
      ${viewBodyHtml(step.body)}
      ${step.img_b64 ? `<img class="thumb" src="${step.img_b64}" alt="">` : ''}
    `;
        box.appendChild(node);
        setNextEnabled(true);
      }
      else if (step.type === 'input') {
        node = document.createElement('div');
        node.innerHTML = `
      ${step.label ? `<label for="vw_inp">${viewEscape(step.label)}</label>` : ''}
      <input id="vw_inp" type="text" class="text-input" placeholder="${viewEscape(step.placeholder || '')}">
      ${step.img_b64 ? `<img class="thumb" src="${step.img_b64}" alt="">` : ''}
    `;
        box.appendChild(node);
        const inp = node.querySelector('#vw_inp');
        const img = node.querySelector('.thumb');              // ‚Üê add this
        inp.value = viewState.answers[step.id] || '';
        const err = document.createElement('div');
        err.className = 'error';
        err.style.display = 'none';
        // node.appendChild(err);                               // ‚Üê remove this
        img ? img.before(err) : inp.insertAdjacentElement('afterend', err);  // ‚Üê insert here


        function refreshInput() {
          const res = validateValueForStep(step, inp.value);
          err.textContent = res.ok ? '' : res.msg;
          err.style.display = res.ok ? 'none' : '';
          setNextEnabled(res.ok);
        }
        inp.addEventListener('input', () => {
          viewState.answers[step.id] = inp.value;
          refreshInput();
        });
        refreshInput();  // initial

      }
      else if (step.type === 'select') {
        node = document.createElement('div');
        if (step.label) node.innerHTML = `<h3>${viewEscape(step.label)}</h3>`;
        const wrap = document.createElement('div');
        wrap.className = 'vw-grid-sel';
        const mode = step.mode === 'multi' ? 'multi' : 'single';
        let sel = viewState.answers[step.id] ?? (mode === 'multi' ? [] : null);

        (step.options || []).forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'vw-option';
          btn.innerHTML = `<strong>${viewEscape(opt.label)}</strong>${opt.hint ? `<div class="small">${viewEscape(opt.hint)}</div>` : ''}`;
          const isSel = mode === 'multi' ? (Array.isArray(sel) && sel.some(o => (o?.value ?? o) === opt.value))
            : (sel && ((sel?.value ?? sel) === opt.value));
          if (isSel) btn.classList.add('selected');
          btn.addEventListener('click', () => {
            if (mode === 'multi') {
              sel = Array.isArray(viewState.answers[step.id]) ? [...viewState.answers[step.id]] : [];
              const k = sel.findIndex(o => (o?.value ?? o) === opt.value);
              if (k >= 0) { sel.splice(k, 1); btn.classList.remove('selected'); }
              else { sel.push({ value: opt.value, label: opt.label }); btn.classList.add('selected'); }
              viewState.answers[step.id] = sel;
              // setNextEnabled(sel.length > 0 || !step.required);
              // validate

              refreshSelect();
            } else {
              viewState.answers[step.id] = { value: opt.value, label: opt.label, next: opt.next };
              wrap.querySelectorAll('.vw-option').forEach(el => el.classList.remove('selected'));
              btn.classList.add('selected');
              // setNextEnabled(true);
              refreshSelect();

            }
          });
          wrap.appendChild(btn);
        });

        node.appendChild(wrap);
        // error message area
        const err = document.createElement('div');
        err.className = 'error';
        err.style.display = 'none';
        node.appendChild(err);

        function refreshSelect() {
          const res = validateValueForStep(step, viewState.answers[step.id]);
          err.textContent = res.ok ? '' : res.msg;
          err.style.display = res.ok ? 'none' : '';
          setNextEnabled(res.ok);
        }

        refreshSelect();

        box.appendChild(node);
        const hasSel = mode === 'multi' ? (Array.isArray(sel) && sel.length > 0) : Boolean(sel);
        setNextEnabled(hasSel || !step.required);
      }
      else if (isEndStep(step)) {
        node = document.createElement('div');
        node.innerHTML = `
      ${step.title ? `<h3>${viewEscape(step.title)}</h3>` : '<h3>Completed</h3>'}
      ${viewBodyHtml(step.body)}`;
        box.appendChild(node);
        setNextEnabled(false);
      } else {
        box.textContent = 'Unknown step type';
        setNextEnabled(false);
      }

      // nav buttons
      document.getElementById('vwPrev').disabled = i === 0;
      const nextBtn = document.getElementById('vwNext');
      nextBtn.textContent = isEndStep(step) ? 'Finish' : 'Next';

      // document.getElementById('vwBackHome').onclick = renderViewAndEditLanding;

      document.getElementById('vwPrev').onclick = () => {
        if (viewState.stepIdx > 0) { viewState.stepIdx--; }
      };
      nextBtn.onclick = () => {
        if (!isEndStep(step)) {
          // branch support
          const currentStep = steps[viewState.stepIdx];
          if (currentStep && currentStep.type === 'select' && currentStep.mode !== 'multi') {
            const choice = viewState.answers[currentStep.id];
            if (choice && choice.next) {
              // jump to label
              const to = steps.findIndex(x => x.id === choice.next);
              if (to >= 0) {
                viewState.stepIdx = to;
                viewState.selectedStepId = to;
                renderViewStep();
                return;
              }
            }
          }
          // step-level next
          if (currentStep && currentStep.next) {
            const to = steps.findIndex(x => x.id === currentStep.next);
            if (to >= 0) {
              viewState.stepIdx = to;
              renderViewStep();
              return;
            }
          }
          // default: linear
          // viewState.stepIdx++; 
          renderViewStep();
        }
      };
    }

    function getStarter() {
      return sop.starters[viewState.starterIdx];
    }

    function makeBlankSOP() {
      return {
        version: "1.3",
        title: "New SOP Library",
        description: "Describe your library",
        starters: [{
          id: "starter_1",
          label: "Starter 1",
          summary: "",
          description: "",
          steps: [
            {
              type: "instruction",
              id: "welcome",
              title: "Welcome",
              body: "Start here.",
              next: "done",
              // pos: { x: 200, y: 60 }
            },
            {
              type: "instruction",
              id: "done",
              title: "Done",
              body: "All set.",
              // pos: { x: 200, y: 200 }

            }
          ]
        }]
      };
    }
    function makeStep(type, starter = getStarter()) {
      const id = uniqueId(type, starter);
      if (type === 'instruction') return { type, id, title: "Instruction", body: "" };
      if (type === 'input') return { type, id, label: "Input", placeholder: "", required: false };
      if (type === 'select') return { type, id, label: "Choose", display: "cards", mode: "single", required: false, options: [{ value: "opt1", label: "Option 1" }] };
      // if (type === 'end') return { type, id, title: "End", body: "" };
      return { type: 'instruction', id, title: "Instruction", body: "" };
    }

    function uniqueId(base, starter) {
      const ids = new Set((starter?.steps || []).map(s => s.id));
      let i = 1, v = slugify(base || 'step');

      let out = v;
      while (ids.has(out)) {
        out = v + '_' + (++i);
      }
      return out;
    }

    function slugify(s) { return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, ''); }
    function escapeHtml(str) { return String(str).replace(/[&<>"']/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[s])); }
    function escapeAttr(str) { return String(str).replace(/"/g, '&quot;'); }
    function nextSummary(step) {
      if (step.type === 'select') {
        const optEdges = (step.options || []).filter(o => o.next).length;
        return (optEdges > 0 ? (optEdges + ' paths') : '') + (step.next ? (optEdges > 0 ? ' + ' : '') + 'after‚Üí' + step.next : (optEdges > 0 ? '' : '‚Äî'));
      }
      return step.next || '‚Äî';
    }
    function nextSelectHtml(steps, cur) {
      const selfId = viewState?.selectedStepId; // current node being edited
      const opts = steps
        .filter(s => s.id !== selfId) // hide itself
        .map(s => `<option value="${s.id}" ${s.id === cur ? 'selected' : ''}>${escapeHtml(s.id)}</option>`)
        .join('');
      return `<select id="f_next"><option value="">‚Äî</option>${opts}</select>`;
    }


    function optionRowHtml(o, i, steps) {
      return `
    <tr data-opt-idx="${i}">
      <td><input class="f_opt_value" type="text" value="${escapeAttr(o.value || '')}"/></td>
      <td><input class="f_opt_label" type="text" value="${escapeAttr(o.label || '')}"/></td>
      <td><input class="f_opt_hint" type="text" value="${escapeAttr(o.hint || '')}"/></td>
      <td>
        <select class="f_opt_next">
          ${steps.map(s => {
        const text = s.title || s.label || s.id;
        return `<option value="${s.id}" ${s.id === (o.next || '') ? 'selected' : ''}>${escapeHtml(text)}</option>`;
      }).join('')}
        </select>
      </td>
      
      <td class="center"><button class="f_opt_del">üóë</button></td>
    </tr>
  `;
    }
    function handleImageToBase64(ev, cb) {
      const f = ev.target.files?.[0]; if (!f) return;
      const r = new FileReader();
      r.onload = () => { cb(String(r.result)); };
      r.readAsDataURL(f);
    }

    function validateSOP() {
      const errors = [];
      if (!Array.isArray(sop.starters) || sop.starters.length === 0) errors.push('No starters');
      sop.starters.forEach((st, si) => {
        if (!Array.isArray(st.steps) || st.steps.length === 0) errors.push(`Starter[${si}] has no steps`);
        const ids = new Set();
        (st.steps || []).forEach((step, idx) => {
          if (!step.id) errors.push(`Starter[${si}] step[${idx}] missing id`);
          if (ids.has(step.id)) errors.push(`Starter[${si}] duplicate id ${step.id}`); ids.add(step.id);

          if (step.type === 'input' && step.regex) {
            try { new RegExp(step.regex); } catch { errors.push(`Invalid regex at ${step.id}`); }
          }
          if (step.type === 'select' && step.mode === 'multi') {
            const c = (Array.isArray(step.options) ? step.options.length : 0);
            if (step.min != null && step.min > c) errors.push(`min > options at ${step.id}`);
            if (step.max != null && step.max > c) errors.push(`max > options at ${step.id}`);
          }
          if (step.type === 'select' && step.mode === 'single') {
            // warn if no option.next and no step.next (unreachable continuation)
            const hasOptNext = (step.options || []).some(o => o.next);
            if (!hasOptNext && !step.next) errors.push(`No path from single-select ${step.id}`);
          }
        });
      });
      return { ok: errors.length === 0, errors };
    }

    function tidyIds() {
      sop.starters.forEach(st => {
        st.id = slugify(st.id || 'starter');
        (st.steps || []).forEach(s => {
          s.id = slugify(s.id || s.type || 'step');
          if (s.type === 'select' && Array.isArray(s.options)) {
            s.options.forEach(o => { o.value = slugify(o.value || o.label || 'opt'); });
          }
        });
      });
    }



  </script>


</body>

</html>